/*
  Copyright (C) 2018, 2019 cc9cii

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  cc9cii cc9c@iinet.net.au

*/

 Object Instances
 =================

 Objects (i.e. cell references) are constructed from ESM/ESP and NIF files.

 The NIF files are like object specifications or 'templates'.  ESM/ESP data specify the
 object's location, rotation, scale, etc.

 When loading a NIF file, rather than creating a single object instance, various Ogre
 framework components are filled with Ogre objects.

 For example, an Ogre::Mesh is created from a NIF file (see NIFMeshLoader::createSubMesh).

 Then an Ogre::Entity associated with that mesh is created.  That entity is furnished with
 material controllers, skeleton, etc and stored in ObjectScene.  (see
 NIFObjectLoader::createEntity)

 Finally the entities in ObjectScene are attached to an Ogre::SceneNode (see
 NIFObjectLoader::createObjects)

 ObjectScene is probably the closest to being the "instantiation" of a NIF.

 TODO: lifetime of the objects


 Collaboration (simplified)
 -------------

      MWRender::Animation o------------ MWWorld::Ptr
            o     o            mPtr
            |     |
            |     +------------------+
            |                        |
            | mObjectRoot            | mInsert
            |                        |
            |                   Ogre::SceneNode*
      NifOgre::ObjectScene*          o
            o                        |
            | mEntities              | Ogre::ObjectMap
            |                        |
            +------------------ Ogre::Entity*
                                     o
                                     | mMesh
                                     |
                                Ogre::Mesh*


 MWWorld::Scene::insertCell calls InsertFunctor that calls ::addObject which in turn
 calls RenderingManager::addObject then the class's insertObject

 NifOgre::Loader::createObjects creates a new instance of ObjectScene
 (see components/nifogre/ogrenifloader.cpp) then returns its pointer to the caller
 (e.g. Animation::setObjectRoot which then stores it as Animation::mObjectRoot)

 Looks like there is one ObjectScene for each NIF.


   Scene::insertCell                                               | apps/openmw/mwworld/scene.cpp
     ::InsertFunctor::operator()                                   | apps/openmw/mwworld/scene.cpp
       ::addObject                                                 | apps/openmw/mwworld/scene.cpp
         MWRender::RenderingManager::addObject                     | apps/openmw/mwrender/renderingmanager.cpp
        :  MWClass::ForeignBook::insertObjectRendering             | apps/openmw/mwclass/foreignbook.cpp
        :    MWRender::Objects::insertModel                        | apps/openmw/mwrender/objects.cpp
        :
        :        <- sets scale to SceneNode and set as the baseNode to Ptr
        :
        :      MWRender::Animation::setObjectRoot                  | apps/openmw/mwrender/animation.cpp
        :
        :          <- maybe Ptr needs to be passed in when calling createObjects to set scale
        :
        :        NifOgre::Loader::createObjects (new ObjectScene)  | components/nifogre/ogrenifloader.cpp
        :          NifOgre::NIFObjectLoader::load                  | components/nifogre/nifobjectloader.cpp
        :
         MWClass::ForeignBook::insertObject                        | apps/openmw/mwclass/foreignbook.cpp
           MWWorld::PhysicsSystem::addObject                       | apps/openmw/mwworld/physicssystem.cpp
             OEngine::Physic::PhysicEngine::createAndAdjustRigidBody libs/openengine/bullet/physic.cpp
               NifBullet::ManualBulletShapeLoader::load            | components/nifbullet/bulletnifloader.cpp


 Resource Management
 ===================

 Ogre's resource management framework is used in several places:

   1. Mesh (for rendering, see components/nifogre/mesh.cpp)

      Below collaboration diagram highlights the key relationships (Warning: simplified).


                                                                      Ogre::Resource
                                                                            ^
                                                                            |
        Ogre::ResourceManager          Ogre::ManualResourceLoader ----o Ogre::Mesh
                  ^                               ^    ^
                  |    --------------------------/     |
                  |   /                                |
        Ogre::MeshManager::createManual(fullname,...)  |
                                                       |
                                                       |
                                map<fullname, NifOgre::NIFMeshLoader>
                                (map is static, i.e. stays forever)

        Ogre::SceneManager::createEntity(fullname)
        (the pointer to the entities are stored in ObjectScene for later destruction)
        (TODO: check if the meshes are unloaded or destoyed)


     MWClass::ForeignStatic::insertObjectRendering
       MWRender::Objects::insertModel
         MWRender::Animation::setObjectRoot
           NifOgre::Loader::createObjects
           : NifOgre::NIFObjectLoader::load
           :   NifOgre::NIFObjectLoader::createObjects
           :     NifOgre::NIFObjectLoader::createEntity
           :       NifOgre::NIFMeshLoader::createMesh......
           :         Ogre::MeshManager::createManual      :
           :               :                              v
           :               :                   NifOgre::NIFMeshLoader::NIFMeshLoader
           :               :                    (construct a loader)
           :           (callback)
           :               :
           :               v
           :    NifOgre::NIFMeshLoader::loadResource
           :      NifOgre::NIFMeshLoader::createSubMesh
           :
          (attach Ogre::Entity in ObjectScene to the parent Ogre::SceneNode)


   2. Skeleton (for Animation)

        Ogre::ResourceManager        Ogre::ManualResourceLoader
                  ^                              ^
                  |                              |
        Ogre::SkeletonManager        NifOgre::NIFSkeletonLoader


   3. Physics (see libs/openengine/bullet/physic.cpp)

        Below diagram highlights the key relationships (Warning: not complete).

                                Ogre::Resource
                                      ^
                                      |
                           OEngine::Physic::BulletShape

        Ogre::ResourceManager                       Ogre::ManualResourceLoader
                  ^                                              ^
                  |                                              |
       OEngine::Physic::BulletShapeManager        OEngine::Physic::BulletShapeLoader
                                                                 ^
                                                                 |
                                                  NifBullet::ManualBulletShapeLoader

                               btRigidBody
                                      ^
                                      |
                          OEngine::Physic::RigidBody

       PhysicEngine::mCollisionObjectMap keeps Physic::RigidBody* for later destruction
       (might be better to keep them in ObjectScene?)

     MWClass::ForeignStatic::insertObject
       MWWorld::PhysicsSystem::addObject
         OEngine::Physic::PhysicEngine::createAndAdjustRigidBody
           NifBullet::ManualBulletShapeLoader::load
             OEngine::Physic::BulletShapeManager::create
               Ogre::ResourceManager::createResource
                               :               :
                               :               v
                               :            OEngine::Physic::BulletShapeManager::createImpl
                               :              Ogre::ResourceManager::createImpl
                               :               (creates a new BulletShape)
                           (callback)
                               :
                               v
                 NifBullet::ManualBulletShapeLoader::loadResource
                  (loads the BulletShape created above and creates a Physic::RigidBody)


   4. NIF (TODO)


 Resource Granularity
 ====================

 Mesh (actually SubMesh)
 ----

   ::addObject
     MWClass::ForeignStatic::getModel                     | returns "meshes\\"+model path from ESM
     MWRender::RenderingManager::addObject                | const std::string &model
       MWClass::ForeignStatic::insertObjectRendering      | const std::string &model
         MWRender::Objects::insertModel                   | const std::string &mesh
           MWRender::Animation::setObjectRoot             | const std::string &model
             NifOgre::Loader::createObjects               | std::string name <- to lower case for loading
               NifOgre::NIFObjectLoader::load             | const std::string &name

                 <-- Nif::Cache called with 'name' before calling createObjects

                 NifOgre::NIFObjectLoader::createObjects  | const std::string &name
                   NifOgre::NIFObjectLoader::createEntity | const std::string &name

                      <-- here 'fullname' is created, looks like
                      "meshes\\clutter\\fightersguild\\targetheavy01.nif@index=25@shape=targetchainright01:1"

                     NIFMeshLoader::createMesh            | const std::string &name
                       NIFMeshLoader::NIFMeshLoader       | const std::string &name
                       Ogre::MeshManager::createManual   <-- 'fullname'

   "fullname" used as the key for Ogre::MeshManager (which "is a" Ogre::ResourceManager):

 When calling Ogre::SceneManager::createEntity (in NifOgre::NIFObjectLoader::createEntity)
 the same 'fullname' must be used so that Ogre knows where to find the mesh.
 NOTE: Ogre versions 1.9+ allows Mesh* to be used instead of 'fullname'

 NOTE: Not sure of the reason in using 'fullname' with NIF index and shape string appended,
 it doesn't seem likely that any reuse can happen (probably just used to allow Ogre::Entity
 to find the corresponding mesh)

 Physics
 -------

   ::addObject
     MWClass::ForeignStatic::getModel                     | returns "meshes\\"+model path from ESM
     MWClass::ForeignStatic::insertObject                 | const std::string &model
       MWWorld::PhysicsSystem::addObject                  | const std::string &mesh
         OEngine::Physic::PhysicEngine::createAndAdjustRigidBody | const std::string &mesh

            <-- here 'outputstring' is created, looks like "meshes\\f\\Flora_BC_mushroom_02.NIF001.000"

           NifBullet::ManualBulletShapeLoader::load       | const std::string &name
             OEngine::Physic::BulletShapeManager::create  | const Ogre::String& name
               Ogre::ResourceManager::createResource
                               :
                           (callback)
                               :
                               v
                 NifBullet::ManualBulletShapeLoader::loadResource
                 (strip 7 chars before calling Nif::Cache, note bug where name is not lower case)

 In the old implementation, a string composed of mesh name and scale is used, see:
 OEngine::Physic::PhysicEngine::createAndAdjustRigidBody

 But that makes the granularity of reusable resource at mesh+scale level.  This might still be
 ok.  But then it might be better at a RigidBody level, and maybe ragdolls have other
 unexpected consequences (since there are multiple RigidBodies involved).

 To use Ogre resource management, either this class needs to be derived (multiple
 inheritance) or needs to 'have' a derived class for loading (via callback).

 Alternatively, leave the resource management at NIF level (or even 'fullname' level) and any
 bullet collision shapes can be contained in the model.

 Not sure if Ogre resource management should continue to be used for physics, since uniquely
 identifying re-usable bullet shapes may not be trivial.

 TODO: also check future direction of Ogre 2.1 resource management

 FIXME: How to pass the scale of the physics object from the ESM/ESP?
        One possibility is to store the scale value in ObjectScene from Loader::createObjects
        since the parameter parentNode should already have the scale from ESM/ESP.

 FIXME: Where is the scale applied to Ogre objects?
        Is it in MWRender::Objects::insertModel setting scale to SceneNode and setting as the
        baseNode to Ptr?  If so do child SceneNodes inherit scaling?

    MWRender::Objects::insertModel               | Ptr
      MWRender::Objects::insertBegin             | Ptr::mRef::mData::mBaseNode set with pos & (uniform) scale
      MWRender::ObjectAnimation::ObjectAnimation |
        MWRender::Animation::Animation           | mInsert set with above
          MWRender::Animation::setObjectRoot     |
            NifOgre::Loader::createObjects       | *parentNode
              NifOgre::NIFObjectLoader::load     | *sceneNode <- points to Ptr::mRef::mData::mBaseNode


 Collision Shapes and Ragdolls
 =============================

 TES4/TES5 NIF files may contain collision shapes as well as ragdoll information.

 In the old implementation the NIF file was loaded at least twice (once for the Ogre
 rendering mesh and again for bullet shapes).  Possibly another load for skeleton as well.

 With this new implementation, the NIF file is loaded once.  All the relevant objects should
 be created during the load, including the physics objects.

 FIXME: In order to minimise the impact to the existing code, allow rendering code to remain
        separate to physics code.  This decision may need to be reviewed.

 However, loading of the collision and ragdoll info from NIF will still be done while the
 rendering objects are being built.  The registration of the physics objects to Bullet will
 be done when the physics code path is executed.  (e.g. calling
 btDiscreteDynamicsWorld::addRigidBody)

 Once the physics objects are built, where are they going to be stored?

 One option is to store the physics objects in ObjectScene even though it is probably meant
 for Ogre objects only. See: components/nifogre/objectscene.hpp

 For non-actors (e.g. Clutter/FightersGuild/TargetHeavy01.NIF) ragdoll should be active at
 the point of instantiation. i.e. when the physics code path reaches it

 For actors and creatures ragdoll is enabled when they die.  That means Ptr should have access
 to the ObjectScene somehow. e.g. via MWBase::Environment::get().getWorld()->getAnimation()


 Physics Scaling
 ===============

 See notes near PhysicEngine::createRagdoll (libs/openengine/bullet/physic.cpp)
 TODO: maybe move the notes here?


 Collision Masks
 ===============

    enum CollisionType {
        CollisionType_Nothing    = 0,    //<Collide with nothing
        CollisionType_World      = 1<<0, //<Collide with world objects
        CollisionType_Actor      = 1<<1, //<Collide with actors
        CollisionType_HeightMap  = 1<<2, //<collide with heightmap
        CollisionType_Raycasting = 1<<3,
        CollisionType_Projectile = 1<<4,
        CollisionType_Water      = 1<<5
    };

HeightField CollisionType_HeightMap  CollisionType_Actor|CollisionType_Raycasting|CollisionType_Projectile
Raycasting  CollisionType_Raycasting CollisionType_Raycasting|CollisionType_Projectile
!Raycasting CollisionType_World      CollisionType_Actor|CollisionType_HeightMap
Actor       CollisionType_Actor      CollisionType_World|CollisionType_HeightMap
                                             |CollisionType_Actor|CollisionType_Projectile(|CollisionType_Water)

Terrain     collides with Actor        Raycasting Projectile
Raycasting  collides with              Raycasting Projectile
World       collides with Actor                               Terrain
Actor       collides with Actor World             Projectile? Terrain (Water)
Water       collides with Actor

Q: Why does Actor collide with Actor?  Isn't there only one Actor?
A: Probably includes NPCs and Creatures

Q: What is the purpose of Raycasting objects?






(addHeightField)
Terrain <-> Actor      /* same as master */   Actor <-> Terrain
Terrain <-> Raycasting /* not in master  */
Terrain <-> Projectile /* same as master */ Projectile <-> Terrain (rayTest2 from ProjectileManager)

(createAndAdjustRigidBody)
Raycasting <-> Raycasting
Raycasting <-> Projectile Projectile <-> Raycasting (rayTest2 from ProjectileManager)

(createAndAdjustRigidBody)
World <-> Actor   Actor <-> World (updateCollisionMask)
World <-> Terrain (??)

(updateCollisionMask)
Actor <-> World      World <-> Actor
Actor <-> Terrain    Terrain <-> Actor
Actor <-> Actor      Actor <-> Actor
Actor <-> Projectile Projectile <-> Actor (rayTest2 from ProjectileManager)
Actor <-> Water      Water <-> Actor (updateWater)
Actor <-> Door // added in the latest master

Actor (getFilteredContact) <-> World, Terrain, Actor // master adds Door and is in getHitContact

Projectile <-> Raycasting (rayTest2 from ProjectileManager)
Projectile <-> Actor      (rayTest2 from ProjectileManager)
Projectile <-> Terrain    (rayTest2 from ProjectileManager)

Any <-> Actor      (rayTest)
Any <-> Raycasting (rayTest) <- check who calls rayTest with raycastingObjectOnly
                                 <- castRay doesn't seem to use Raycasting
                                 <- getFacedHandle doesn't seem to be called at all?
                                 <- getLOS calls rayTest but not with raycastingObjetOnly
  or
Any <-> World      (rayTest)

Any <-> Actor      (rayTest2 from getFacedHandles)
Any <-> Raycasting (rayTest2 from getFacedHandles)
Any <-> Terrain    (rayTest2 from getFacedHandles)



All <-> CollisionType_World (traceDown) CollisionType_HeightMap (traceDown) // same in master

 getFacedHandle, getFacedHandles, rayTest and rayTest2 are no longer used in master
 probably getting data directly from Osg meshes






    std::pair<const RigidBody*,btVector3> PhysicEngine::getFilteredContact(const std::string &filter,
                                                                           const btVector3 &origin,
                                                                           btCollisionObject *object)
    {
        DeepestNotMeContactTestResultCallback callback(filter, origin);
        callback.m_collisionFilterGroup = CollisionType_Actor;
        callback.m_collisionFilterMask = CollisionType_World | CollisionType_HeightMap | CollisionType_Actor;


    void PhysicEngine::addHeightField(const float* heights,
        mDynamicsWorld->addRigidBody(body,
                                    CollisionType_HeightMap,
                                    CollisionType_Actor|CollisionType_Raycasting|CollisionType_Projectile);

    RigidBody* PhysicEngine::createAndAdjustRigidBody(const std::string &mesh, const std::string &name,

        if (!raycasting)
        {
            assert (mCollisionObjectMap.find(name) == mCollisionObjectMap.end());
            mCollisionObjectMap[name] = body;
            mDynamicsWorld->addRigidBody(body,
                                    CollisionType_World,
                                    CollisionType_Actor|CollisionType_HeightMap);
        }
        else
        {
            assert (mRaycastingObjectMap.find(name) == mRaycastingObjectMap.end());
            mRaycastingObjectMap[name] = body;
            mDynamicsWorld->addRigidBody(body,
                                    CollisionType_Raycasting,
                                    CollisionType_Raycasting|CollisionType_Projectile);
            body->setCollisionFlags(body->getCollisionFlags() | btCollisionObject::CF_DISABLE_VISUALIZE_OBJECT);
        }

    void PhysicActor::updateCollisionMask()
        mEngine->mDynamicsWorld->removeRigidBody(mBody);

        int collisionMask = CollisionType_World | CollisionType_HeightMap;

        if (mExternalCollisionMode)
            collisionMask |= CollisionType_Actor | CollisionType_Projectile;

        if (mCanWaterWalk)
            collisionMask |= CollisionType_Water;

        mEngine->mDynamicsWorld->addRigidBody(mBody, CollisionType_Actor, collisionMask);

    std::pair<std::string,float> PhysicEngine::rayTest(const btVector3 &from, const btVector3 &to, bool raycastingObjectOnly, bool ignoreHeightMap, Ogre::Vector3* normal)

        if(raycastingObjectOnly)
            resultCallback1.m_collisionFilterMask = CollisionType_Raycasting|CollisionType_Actor;
        else
            resultCallback1.m_collisionFilterMask = CollisionType_World;

        if(!ignoreHeightMap)
            resultCallback1.m_collisionFilterMask = resultCallback1.m_collisionFilterMask | CollisionType_HeightMap;

        mDynamicsWorld->rayTest(from, to, resultCallback1);

    std::vector< std::pair<float, std::string> > PhysicEngine::rayTest2(const btVector3& from, const btVector3& to, int filterGroup)
        resultCallback1.m_collisionFilterGroup = filterGroup;
        resultCallback1.m_collisionFilterMask = CollisionType_Raycasting|CollisionType_Actor|CollisionType_HeightMap;

        mDynamicsWorld->rayTest(from, to, resultCallback1);

        std::vector< std::pair<float, std::string> > rayTest2(const btVector3 &from, const btVector3 &to,
        int filterGroup=0xff);

    std::vector < std::pair <float, std::string> > PhysicsSystem::getFacedHandles (float queryDistance)
        /* auto */ results = mEngine->rayTest2(origin, dest); // i.e. default group used

    std::vector < std::pair <float, std::string> > PhysicsSystem::getFacedHandles (float mouseX, float mouseY, float queryDistance)
        /* auto */ results = mEngine->rayTest2(_from,_to); // i.e. default group used

    void ProjectileManager::moveMagicBolts(float duration)
            std::vector<std::pair<float, std::string> > collisions = mPhysEngine.rayTest2(from, to,
                                          OEngine::Physic::CollisionType_Projectile);

    void ProjectileManager::moveProjectiles(float duration)
            std::vector<std::pair<float, std::string> > collisions = mPhysEngine.rayTest2(from, to,
                                          OEngine::Physic::CollisionType_Projectile);

    void World::castSpell(const Ptr &actor)
            std::vector<std::pair<float, std::string> > collisions
            = mPhysEngine->rayTest2(btVector3(origin.x, origin.y, origin.z),
                                    btVector3(dest.x, dest.y, dest.z)); // i.e. default group
                                    used

    void PhysicsSystem::updateWater()
    {
        if (mWaterCollisionObject.get())
        {
            mEngine->mDynamicsWorld->removeCollisionObject(mWaterCollisionObject.get());
        }

        if (!mWaterEnabled)
            return;

        mWaterCollisionObject.reset(new btCollisionObject());
        mWaterCollisionShape.reset(new btStaticPlaneShape(btVector3(0,0,1), mWaterHeight));
        mWaterCollisionObject->setCollisionShape(mWaterCollisionShape.get());
        mEngine->mDynamicsWorld->addCollisionObject(mWaterCollisionObject.get(), OEngine::Physic::CollisionType_Water,
                                                    OEngine::Physic::CollisionType_Actor);

See Bug #550
commit d7c4a622cf196e84c337a9eed31929e82a0429d6
Author: scrawl <scrawl@baseoftrash.de>
Date:   Fri Mar 8 23:46:25 2013 +0100

    Create a separate rigid body / shape with full details for raycasting, remove the occlusion query hack


 vim: spell spelllang=en_us syntax=cpp
