/*

  Copyright (C) 2018-2020 cc9cii

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  cc9cii cc9c@iinet.net.au

*/

# [17/12/18] NIF Design

Ideally minimise unnecessary loops or processing duplications.

## Cache objects

But at what level?  The choices seem to be:

  * NIF after parsing - each of the object instances based on the same NIF needs to be built
  * already built object instance - everything is the same except position/rotation/etc
    (how to clone?)

## Building object instances

### Object Scope and Lifetime

    NIF Object      | Ogre Object            | Ogre Instance
    ----------------+------------------------+-------------------------
    NIF             | NiModel                | BtOgreInst (has pos/rot/scale/etc from ESM/ESP)
    NiNode          | Ogre::Mesh             | Ogre::Entity
    NiGeometry      |   submesh              |   sub-entity
                    |     material           |
                    |   animation            |
                    |   pose (vertex anim)   |
    ----------------+------------------------+-------------------------
    SkeletonRoot    | Ogre::Skeleton         | Ogre::SkeletonInstance
    Bone            |  bone                  |


One design consideration is when does the Ogre objects (e.g. `Mesh`) get built?

Currently the build is triggered when the associated `Entity` is built (via a loader callback mechanism).  This may not be efficient if the same mesh are re-used often (e.g. `skeleton.nif`, but have not tested if true - **EDIT: 22/02/19** Not true since an often used mesh will be retrieved from the `MeshManager`'s cache.  Also see below paragraph.).

Note that I may be misunderstanding some stuff here.  For example, the built meshes are managed by the `MeshManager` so they won't be built again. Similarly the skeletons are managed by the `SkeletonManager`.

An alternative might be to create the Ogre objects as each of the NIF files are read.  But doing this can lead to a large number of Ogre objects being loaded (Q: do Ogre resource managers ever unload? A: yes)

Some `NiTimeControllers` may work with different Ogre objects.  For example:

  * `NiGeomMorpherController` is setup while creating a sub-mesh (vertex animation) `SceneManager::_applySceneAnimations` will then call the `apply()` method of each of the animations

  * `NiUVController` seems to work at each of the sub-entity level by modifying the associated
    material (texture scroll)

# [23/12/2018] Some unrelated notes

  1. Ogre resource searching is poor for NIF - multiple archives are searched for each and every resource in BSA (or loose files).  See `OgreResourceGroupManager.cpp`.

     Also, find out if the contents of the BSA can be registered(?) with `ArchiveManager` or `ResourceManager`.  It seems `grp->ResourceIndexCaseSensitive`, etc, are empty.

  2. Each of the sounds throw exception trying to find a `.wav` format, then finds `.mp3` format.  Do some intelligent detection while scanning resources?

  3. Subtitle message box height is too low and hence the bottom of the texts are not showing.

# [25/12/2018]

Decided to revert the `bhkNiTriStripsShape` packing optimisation.  `bhkNiTriStripsShape` shouldn't be occurring often with the newer NIF versions, anyway (hopefully).  Well, it turns out that there are a few - might be worth doing some profiling later.

[//]: # (                                                             {{{
    bhkNiTriStripsShape examples:
    ./meshes/architecture/arena/arenacolumn02.nif
    ./meshes/architecture/bridges/looseboard01.nif
    ./meshes/architecture/bridges/looseboardbroken.nif
    ./meshes/architecture/cheydinhal/woodplank01.nif
    ./meshes/clutter/bonemarrow.nif
    ./meshes/clutter/books/wantedposter01.nif
    ./meshes/clutter/books/wantedposter02.nif
    ./meshes/clutter/gnarlbark.nif
    ./meshes/clutter/houndstooth.nif
    ./meshes/clutter/hungertongue.nif
    ./meshes/clutter/ingredcinnabarpolyporecap01.nif
    ./meshes/clutter/ingredcinnabarpolyporecap02.nif
    ./meshes/clutter/middleclass/middlechestbrokenbottom02.nif
    ./meshes/clutter/middleclass/middlechestbrokenbottom03.nif
    ./meshes/clutter/scalonfin.nif
    ./meshes/clutter/se02handkerchief.nif
    ./meshes/clutter/sesmokedbaliwogleg.nif
    ./meshes/clutter/shamblesskull.nif
    ./meshes/clutter/USIPHoundsToothKey.NIF
    ./meshes/clutter/voidessence.nif
    ./meshes/dungeons/ayleidruins/exterior/cameronsparadise/cpscreen01.nif
    ./meshes/dungeons/ayleidruins/interior/arwelkydiholder01.nif
    ./meshes/dungeons/caves/cave03/cnhallhalf01a.nif
    ./meshes/dungeons/caves/clutter01/ancientscroll01.nif
    ./meshes/dungeons/caves/clutter01/animalrib01.nif
    ./meshes/dungeons/caves/clutter01/arch03.nif
    ./meshes/dungeons/caves/clutter01/arch04.nif
    ./meshes/dungeons/caves/clutter01/archfull01.nif
    ./meshes/dungeons/caves/clutter01/arrmwallexitwide01.nif
    ./meshes/dungeons/caves/clutter01/arrowrock01.nif
    ./meshes/dungeons/caves/clutter01/arwhalldeadend02.nif
    ./meshes/dungeons/caves/clutter01/arwhallendcrumblewall01.nif
    ./meshes/dungeons/caves/clutter01/ayleidplatform01.nif
    ./meshes/dungeons/caves/clutter01/batincage01.nif
    ./meshes/dungeons/caves/clutter01/beartrapclosed03.nif
    ./meshes/dungeons/caves/clutter01/brainvat01.nif
    ./meshes/dungeons/caves/clutter01/burnttranscript01.nif
    ./meshes/dungeons/caves/clutter01/ceismap01.nif
    ./meshes/dungeons/caves/clutter01/ceismap02.nif
    ./meshes/dungeons/caves/clutter01/ceismap03.nif
    ./meshes/dungeons/caves/clutter01/ceismap04.nif
    ./meshes/dungeons/caves/clutter01/ceismap05.nif
    ./meshes/dungeons/caves/clutter01/ceismap06.nif
    ./meshes/dungeons/caves/clutter01/celestialring01.nif
    ./meshes/dungeons/caves/clutter01/centurionsphere01.nif
    ./meshes/dungeons/caves/clutter01/circularartifact01.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup01.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup02.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup03.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup04.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup05.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup06.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup07.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup08.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup09.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup10.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup11.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup12.nif
    ./meshes/dungeons/caves/clutter01/displayglass01.nif
    ./meshes/dungeons/caves/clutter01/displayglasswide01.nif
    ./meshes/dungeons/caves/clutter01/dragon01.nif
    ./meshes/dungeons/caves/clutter01/dragonegg01.nif
    ./meshes/dungeons/caves/clutter01/dragonskull01.nif
    ./meshes/dungeons/caves/clutter01/dwemercog01.nif
    ./meshes/dungeons/caves/clutter01/dwemercylinder01.nif
    ./meshes/dungeons/caves/clutter01/dwemerpiston01.nif
    ./meshes/dungeons/caves/clutter01/dwemerspiderleg01.nif
    ./meshes/dungeons/caves/clutter01/emptycage01.nif
    ./meshes/dungeons/caves/clutter01/fireflycage01.nif
    ./meshes/dungeons/caves/clutter01/forgering01.nif
    ./meshes/dungeons/caves/clutter01/forgering02.nif
    ./meshes/dungeons/caves/clutter01/geode01.nif
    ./meshes/dungeons/caves/clutter01/geodestatic01.nif
    ./meshes/dungeons/caves/clutter01/gong01.nif
    ./meshes/dungeons/caves/clutter01/gongbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/gongbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/guildgarden01.nif
    ./meshes/dungeons/caves/clutter01/hollowstump01.nif
    ./meshes/dungeons/caves/clutter01/hornofzyyr01.nif
    ./meshes/dungeons/caves/clutter01/landdreughhead01.nif
    ./meshes/dungeons/caves/clutter01/malevolentzinj01.nif
    ./meshes/dungeons/caves/clutter01/malevolentzinjstatic01.nif
    ./meshes/dungeons/caves/clutter01/meteorite01.nif
    ./meshes/dungeons/caves/clutter01/minotaurstatue01.nif
    ./meshes/dungeons/caves/clutter01/minotaurstatue02.nif
    ./meshes/dungeons/caves/clutter01/musicbox01.nif
    ./meshes/dungeons/caves/clutter01/post01.nif
    ./meshes/dungeons/caves/clutter01/post02.nif
    ./meshes/dungeons/caves/clutter01/post03.nif
    ./meshes/dungeons/caves/clutter01/post04.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase02.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase03.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase04.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/pyre01.nif
    ./meshes/dungeons/caves/clutter01/rock01.nif
    ./meshes/dungeons/caves/clutter01/runesofcyrodiil01.nif
    ./meshes/dungeons/caves/clutter01/rythorspendant02.nif
    ./meshes/dungeons/caves/clutter01/rythorspendant03.nif
    ./meshes/dungeons/caves/clutter01/sarcophagus01.nif
    ./meshes/dungeons/caves/clutter01/scaffolding01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn04.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom04.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/shaft01.nif
    ./meshes/dungeons/caves/clutter01/shard01.nif
    ./meshes/dungeons/caves/clutter01/shipwreck02.nif
    ./meshes/dungeons/caves/clutter01/spire01.nif
    ./meshes/dungeons/caves/clutter01/spire02.nif
    ./meshes/dungeons/caves/clutter01/spire03.nif
    ./meshes/dungeons/caves/clutter01/spiredoor01.nif
    ./meshes/dungeons/caves/clutter01/spiredoor02.nif
    ./meshes/dungeons/caves/clutter01/spiredoor03.nif
    ./meshes/dungeons/caves/clutter01/spiredoor04.nif
    ./meshes/dungeons/caves/clutter01/spiredoor05.nif
    ./meshes/dungeons/caves/clutter01/tallcensor01.nif
    ./meshes/dungeons/caves/clutter01/tallcensorbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/tallcensorbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/tallmushroom01.nif
    ./meshes/dungeons/caves/clutter01/talon01.nif
    ./meshes/dungeons/caves/clutter01/teavscorpse01.nif
    ./meshes/dungeons/caves/clutter01/teavssword01.nif
    ./meshes/dungeons/caves/clutter01/tent02.nif
    ./meshes/dungeons/caves/clutter01/test01.nif
    ./meshes/dungeons/caves/clutter01/test02.nif
    ./meshes/dungeons/caves/clutter01/trilobite02.nif
    ./meshes/dungeons/caves/clutter01/twist01.nif
    ./meshes/dungeons/caves/clutter01/twist03.nif
    ./meshes/dungeons/caves/clutter01/twist04.nif
    ./meshes/dungeons/caves/clutter01/twist05.nif
    ./meshes/dungeons/caves/clutter01/twist06.nif
    ./meshes/dungeons/caves/clutter01/twist07.nif
    ./meshes/dungeons/caves/clutter01/twist08.nif
    ./meshes/dungeons/caves/clutter01/twist09.nif
    ./meshes/dungeons/caves/clutter01/twist10.nif
    ./meshes/dungeons/caves/clutter01/twist11.nif
    ./meshes/dungeons/caves/clutter01/twist12.nif
    ./meshes/dungeons/caves/clutter01/twist13.nif
    ./meshes/dungeons/caves/clutter01/twist14.nif
    ./meshes/dungeons/caves/clutter01/twist15.nif
    ./meshes/dungeons/caves/clutter01/twist16.nif
    ./meshes/dungeons/caves/clutter01/twist17.nif
    ./meshes/dungeons/caves/clutter01/twist18.nif
    ./meshes/dungeons/caves/clutter01/twist19.nif
    ./meshes/dungeons/caves/clutter01/twist20.nif
    ./meshes/dungeons/caves/clutter01/twistpiece01.nif
    ./meshes/dungeons/caves/clutter01/twistpiece02.nif
    ./meshes/dungeons/caves/clutter01/twistpiece03.nif
    ./meshes/dungeons/caves/clutter01/twistpiece04.nif
    ./meshes/dungeons/caves/clutter01/upcolumn01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase02.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase03.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase04.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom01.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom02.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom03.nif
    ./meshes/dungeons/caves/clutter01/warlockartifact01.nif
    ./meshes/dungeons/caves/clutter01/warlockchest01.nif
    ./meshes/dungeons/caves/clutter01/warlockcoffer01.nif
    ./meshes/dungeons/caves/clutter01/warlockcoffer02.nif
    ./meshes/dungeons/caves/clutter01/warlockskeleton01.nif
    ./meshes/dungeons/caves/clutter01/warlockspellshrine01.nif
    ./meshes/dungeons/caves/clutter01/warlocktile01.nif
    ./meshes/dungeons/caves/clutter01/warlocktile02.nif
    ./meshes/dungeons/caves/clutter01/warlocktile03.nif
    ./meshes/dungeons/caves/clutter01/warlocktile04.nif
    ./meshes/dungeons/caves/clutter01/warlocktile05.nif
    ./meshes/dungeons/caves/clutter01/warlocktile06.nif
    ./meshes/dungeons/caves/clutter01/warlocktile07.nif
    ./meshes/dungeons/caves/clutter01/warlocktile08.nif
    ./meshes/dungeons/caves/clutter01/warlocktile09.nif
    ./meshes/dungeons/caves/clutter01/warlocktile10.nif
    ./meshes/dungeons/caves/clutter01/warlocktile11.nif
    ./meshes/dungeons/misc/ricketyfence01.nif
    ./meshes/dungeons/Root/Interior/Misc/gnarlspawner.nif
    ./meshes/dungeons/Root/Interior/Misc/spiketrap.nif
    ./meshes/furniture/middleclass/bearskinrug01.nif
    ./meshes/furniture/middleclass/middlewolfrug01.nif
    ./meshes/furniture/middleclass/ms51rewardpainting.nif
    ./meshes/Museum/HoundsToothKey.NIF
    ./meshes/oblivion/clutter/traps/hallwaytrackbladetrap02.nif
    ./meshes/oblivion/clutter/traps/hallwaytrackbladetrap02b.nif
    ./meshes/plants/Dementia/blisterpodcap.nif
    ./meshes/plants/Dementia/DDigestiveSlime.NIF
    ./meshes/plants/Dementia/dpodpit.nif
    ./meshes/plants/Mania/alocasiafruit.nif
    ./meshes/plants/Mania/kelpgasbladder.nif
    ./meshes/plants/Mania/wormheadcap.nif                             }}})

# [25/12/2018]

## Rough sequence of events:

  * Load cell
  * Insert objects as per ESM/ESP references
  * Read NIF model from BSA or loose files (cache the NIF?  probably best to cache the `NiModel`)
  * Build the Ogre "templates" such as Mesh, Skeleton, Vertex Animation, etc, and store them in
    their respective resource managers
  * Create Ogre Entities (actually, trying to create an `Ogre::Entity` triggers the first time
    'loading' of the resources such as meshes)
  * Also create Bullet objects
  * Associate entity controllers (for some animation types)

## Some more detail:

### NiNode
`NiNode` is a `Mesh` if any of the children is an `NiGeometry`, which is a sub-mesh.  A sub-mesh may have its own animation (time controllers from `NiGeometry`)

Ogre `MeshManager` needs a unique identifier (name?) for the `Mesh`.  For now the NIF model name plus the `NiNode` name is used but it may be possible to use a hash value + block number instead.

**TODO:** Since the meshes are loaded on-demand, and sub-meshes are created from a mesh, each of the `NiGeomerty` children are registered to a loader.  An alternative is to re-scan the children at build time.  Not sure which is more efficient.

The mesh loader should be part of `NiModel` so that the cached one also has the loader.

Any associated object, such as materials, animations and skeletons should also be loaded.

### NiGeometry
`NiGeometry` may have, in addition to an `NiGeometryData`:

     NiAVObject::NiProperties       : e.g. NiMaterialProperty, NiTexturingProperty, etc
                                    : each of these may have an NiTimeController
                                      e.g. NiMaterialColorController, NiFlipController
     NiObjectNET::NiTimeController  : applies at sub-mesh/sub-entity level
                                      e.g. NiUVController, NiGeomMorpherController
     NiSkinInstance                 : this will trigger a skeleton to be built
     Materials                      : (Skyrim)
     BS Properties                  : (Skyrim)

# [27/12/2018]

## NiProperty

`NiTriShape` seems to allow only two properties?

    Property Name           NIF              Ogre
    ----------------------+----------------+---------------------
    NiMaterialProperty      Ambient
                            Diffuse
                            Specular
                            Emissive
                            Glossiness
                            Alpha
                            Emit Multi
    ----------------------+----------------+---------------------
    NiTexturingProperty     Base      (0)
                            Dark      (1)
                            Detail    (2)
                            Gloss     (3)
                            Glow      (4)
                            Bump Map  (5)
                            Normal    (6)
                            Decal
                            Shader
    ----------------------+----------------+---------------------
    NiAlphaProperty         Transparency?
    NiVertexColorProperty
    NiZBufferProperty
    NiSpecularProperty      Shiny
    NiWireframeProperty     Wireframe
    NiStencilProperty       Draw both sides

    BSLightingShaderProperty
    BSEffectShaderProperty
    BSWaterShaderProperty
    Property

## Some notes on Shiny:

    transparent_sorting                Ogre::Pass::setTransparentSortingForced
    num_nipmaps                        Ogre::TextureUnitState::setNumMipmaps
    anim_texture2                      Ogre::TextureUnitState::setAnimatedTextureName
    diffuseMap, detailMap,             Ogre::TextureUnitState::setTextureName
    darkMap, emissiveMap
    lod_values                         Ogre::MaterialScriptContext (protected member of
                                             Ogre::MaterialSerializer)
    diffuse, specula,                  Ogre::AtrributeParserList (protected member of
                                             Ogre::MaterialSerializer)

    MaterialInstance::setProperty
      PropertySetGet::setProperty
        mProperties

    diffuse 1.0 1.0 1.0 1.0
    specular 0 0 0 0 1
    ambient 1.0 1.0 1.0
    emissive 0.0 0.0 0.0
    vertmode 0
    normalMap
    specMap
    use_emissive_map false
    use_detail_map false
    use_diffuse_map false
    use_dark_map false
    emissiveMapUVSet 0
    detailMapUVSet 0
    diffuseMapUVSet 0
    darkMapUVSet 0
    use_parallax false

    scene_blend default
    depth_write default
    depth_check default
    alpha_rejection default
    polygon_mode default
    env_map false
    env_map_color 1 1 1

    alphaTestMode 0
    alphaTestValue 0

## BtOgreInst

`BtOgreInst` should maintain the `Entities` and `SceneNodes` (probably also `RigidBodies`) It should "have" an `NiModel`, at least a pointer/reference to it.

When a `BtOgreInst` is built, it will in turn build its `NiModel` first.  The `NiModel` building process should result in finding out which entities are to be built (e.g. name of the `Mesh`)

## NiNode

`NiNode` may have an associated collision object(s).  These collision shapes and constraints are built in Bullet.

# [28/12/2018]

## Controllers:

   NiNode               NiVisController            idleobjects/genericbook.nif
                        NiTransformController      fire/firetorchlargesmoke.nif
                        NiKeyframeController

   NiGeometry           NiUVController
                        NiGeomMorpherController

   NiTexturingProperty  NiFlipController

   NiMaterialProperty   NiAlphaController
                        NiMaterialColorController

   ??                   ParticleSystem

# [29/12/2018]

## Animation

### Vertex Animation

  * `GeomMorpher` (`Morph` implemented by `Ogre::Pose`)
    - `Animation` added to a `Mesh`
    - `AnimationTrack` added to the Animation (its handle is `subMeshIndex+1`)
    - Each `Morph` is a `Pose` (all of the poses have the target of `subMeshIndex+1`)
    - Each `Morph` key is a `VertexPoseKeyFrame` (pose index points to a `Pose`)
      (from NIF 10.0.1.0 the keys are under `NiControllerSequence::mControlledBlocks`)
    - Note the current Ogre limitations on interpolator (lacks quadratic)

### Material Animation

  * All below affect an `Ogre::MovableObject` (but should be a `SubEntity`?)
   - UV
   - Alpha
   - Flip
   - MaterialColor

### Node Animation

  * visibility
     - affects the visibility of an `Ogre::Entity` (i.e. `NiNode`)
  * Transform/Keyframe
     - animates an `Ogre::Node`
  * `skeleton.nif` + `*.kf`
  * skinned
     - e.g. armour, clothes
     - how to attach to an existing skeleton?  by bone names?
     - note Skeleton Root can be different for each NiSkinInstance and they are not necessarily Scene Root

## Finding minimum size skeleton

  1. While constructing the objects (i.e. reading the NIF file), make a note of `NiNode` parent `NiNode`.
  2. Also make a note of leaf `NiNode`; `NiSkinInstance::mBones`, `NiTransformController::mTargetRef`, and maybe even `NiNodes` names starting with "`AttachLight`".
  3. Once all the blocks are read in, reverse search from each of the leaf nodes to the root node (prb. use the one in the footer?).  While doing this each of the `NiNode` should keep a list of child `NiNode` that will be bones.
  4.  Finally create a skeleton using the `SkeletonManager` and a `ManualResourceLoader`.  The name of the `Skeleton` should be the name of the `NiModel`.

## How to add (attach?) other NIF/kf files to a NIF?

e.g. weapons, armour to skeleton
e.g. fire to "`FlameNode`"

# [29/12/2018]

    mwscript/cellextensions.cpp       : opCOW

    mwclass/foreigndoor.cpp           : activate
    mwworld/actionteleportforeign.cpp : ActionTeleportForeign::teleport

    mwworld/worldimp.cpp              : changeToForeignWorldCell
    mwworld/scene.cpp                 : changeToForeignWorldCell     <---- sometimes not working

# [30/12/2018] removed some debugging printouts

    material.cpp          : unhandled texture controller
    ogrenifloader         : No bone named...
                          : Unsupported controller...
    foreignnpcanimation   : Inventory...
    scene.cpp             : dummy
    bulletnifloader       : (various)
    esm4/race.cpp         : skipping...


# [01/01/2018] A new start...

Well, a bit of rethink about object life cycle management now that the new rendering seems to work ok.  This was triggered by Bullet's need to have the collision shapes around during the lifetime of RigidBodies.

Embracing Ogre's resource management philosophy of on-demand resource loading, the NiModel's structure needs to change:


    SceneNode o-- Entity o-- Mesh o-- SubMesh o-- Material o-- Texture
                    o
                    |
              SkeletonInstance
                    ^
                    |
                 Skeleton (?)


If Ogre decides to create an `Entity`, it will be based on a `Mesh` retrieved from a `MeshManager`.  The `Mesh` in turn may use `MaterialManager` or `SkeletonManager`.

An ESM/ESP model (i.e. a NIF) may result in a Skeleton and a number of `Meshes` (and other things) to be built.  In OpenMW the ownership structure is roughly:


                                      Animation o-- ObjectScene o-- Entity, Light, Particles...
                                          ^
                                          |
    RenderingManager o-- Objects o-- ObjectAnimation
             o              o
             |              +------- SceneNode
             |
             +---------- Actors


And in a little more detail (but still simplified):


         MWRender::Animation o------------ MWWorld::Ptr
               o     o            mPtr
               |     |
               |     +------------------+
               |                        |
               | mObjectRoot            | mInsert
               |                        |
               |                   Ogre::SceneNode*
         NifOgre::ObjectScene*          o
               o                        |
               | mEntities              | Ogre::ObjectMap
               |                        |
               +------------------ Ogre::Entity*
                                        o
                                        | mMesh
                                        |
                                   Ogre::Mesh*


A `MeshManager` may call a `Mesh` loader which will need to refer to a NIF model (either loaded from a file or retrieved from a cache).  Currently the NIF model "owns" the loaders.  This may need to be flipped around, i.e. the loaders should be able to trigger the NIF models to be loaded/retrieved.

One way of achieving this could be to derive from an `Ogre::ResourceManager`. e.g.:


       ResourceManager   Singleton<NiModelManager>
                ^             ^
                |             |
                 \           /          Resource o------- ManualResourceLoader
                  \         /              ^                     ^
                   \       /               |                     |
                 NiModelManager            |                     |
                 ::createImpl()  . . .  NiModel           ManualNiModelLoader
                                        ::loadImpl()      ::loadResource()
                                        ::unloadImpl()    (NOTE: not implemented)


A manually loaded resource will retain a pointer to its loader (e.g. see `Ogre::Mesh`).  That means, for the resource to be reloaded (by its manager) the loader needs to remain valid.

With the current design where the loaders are "owned" by `NiModel`, `NiModel` needs to hang around until the resources (`Mesh`, `Skeleton`, etc) are no longer needed (e.g. unloading a cell).

One simple way could be to maintain a map of `NiModel` smart pointers in `ObjectScene` for deletion.  A slightly better way is to have a cache to avoid multiple loading of the same NIF files.  Or we could implement an `NiModelManager` as per above.  An `NiModel` can then be loaded on-demand.

(**EDIT: 22/02/19** looks like keeping the mesh loader with the `NiModel` in `ObjectScene` won't work since the same mesh for a different instance could be used)

**NOTE:** current implementation does not use a `ManualResourceLoader` which probably means `NiModel` cannot be reloaded automatically (actually, it can)

**IDEA:** Keep all the loaders in `ObjectScene`?  Or in `BtOgreInst` then have `ObjectScene` destroy `BtOgreInst` in the destructor?

`OEngine::Physic::PhysicEngine::mCollisionObjectMap` keeps `Physic::RigidBody*` for later destruction.  (and `mAnimatedShapes`, etc.)


    MWWorld::Scene::unloadCell
      PhysicsSystem::removeObject      (for ptr.getRefData().getBaseNode() and its children)
        OEngine::Physic::PhysicEngine::removeCharacter
        OEngine::Physic::PhysicEngine::removeRigidBody
          mDynamicsWorld->removeRigidBody
        OEngine::Physic::PhysicEngine::deleteRigidBody
          mAnimatedShapes.erase(body);
          delete body;


`btShapes` are deleted in `BulletShape` dtor and `BulletShape` is probably stored in `BulletShapeManager`.

# [02/01/2019] Physics continuing

  1. Get `NiModel` & get a list of target Entities; need as inputs `Ogre::SceneNode`, position, rotation and scale.  This means that the `Mesh`/`Entity` needs to have been created *before* physics.
  2. For each target Entity create the resource using the resource manager.
  3. Using the resource create the `btRigidBody` corresponding the `Entity`.
  4. Additional setup (e.g. constraints) needs to be done for ragdolls. (how to detect?)

# [02/01/2019] Physics continuing still

With `btCollisionShape` required for constructing `btRigidBody`, it turns out that a new one needs to be generated each time.  ([or at least a deep copy made?]( https://stackoverflow.com/questions/12255546/c-deep-copying-a-base-class-pointer))

# [06/01/2019] Issues found while running around

## exception

    COW "AnvilWorld" -46 -8

    exception     Ptr World::getPtrViaHandle (const std::string& handle)  Anvil Fighters Guild
    searches mActiveCells in CellStore

## wrong position and/or rotation

The shirt in display case is half clipping through the bottom (`ICMarketDistrictRedDiamondJewelry`)

# [06/01/2019] Get to some old code & comments

    Gdiff b44b4bad325296ca8ab7d519e33ca533f679abf8

# [08/01/2019] Some notes on odd build sequences

## NiTriBasedGeom (NiTriShapes/NiTriStrips)

**EDIT: 29/02/20** `MeshLoader` is being re-designed

  * in the constructor register self in `BuildData` (but first check if parent NiNode is named "`EditorMarker`")
  * during the registration a `MeshLoader` is created and associated with the parent `NiNode`
     (note that it is no longer done when a NiNode is building its children)
  * when the `NiModel` is 'instantiated' the `Mesh` and `SubMesh` are loaded when the `Entity` is created (using the `Mesh` pointer, but can be done with the `Mesh` name)
  * any vertex animations in a `SubMesh` are setup with the `Entity`
  * note that there may be more than one `Mesh` per `NiModel`
  * in future implementation the `MeshLoader` may need to be moved out of `BuildData`

## bhkEntity (bhkRigidBody/bhkRigidBodyT)

  * in the constructor of `NiCollisionObject` register the collision object body
    (**TODO:** should check if collision is enabled in BSX)
  * a `BtRigidBodyCI` object is created with the same name as the `NiModel`; it then looks for any registerd `bhkEntity` to build the `btShapes`, etc.
  * note that there may be more than one `RigidBody` per `NiModel` (these may need to be deleted manually)

# [18/02/2019] Animation re-write

The animation glitches, especially with the hand positions, may be due to the use of separate controllers for each of the bones.  It may be that each of the bones are showing rotations and/or positions at different points in time.

**NOTE:** experiments indicate that all the bones are updated at the same time... :-(

Nifskope uses `NiMultiTargetTransformController`, replacing the `NiTransformController` (which is *not* its parent class, interestingly) at the "Accum Root" bone specified in `NiControllerSequence`.

Each of the target bones in the *Controlled Blocks* are then added to `mExtraTargetRefs` and `mNumExtraTargets` updated (this method is prob. not necessary).  Note that if multiple anims are added to the skeleton then only the additional bones are added to `mExtraTargetRefs`.

# [18/02/2019] skeleton for children

Looks like the bones listed in the skinned meshes indicate the smaller size of the skeleton for children.  That means the body parts need to be added and the binding position re-set.

**TODO:** this might not be true at all, need to experiment

# [28/02/2019] instantiation refactoring

The existing OpenMW code is built around `ObjectScene` and `SkelBase` (`Ogre::Entity` at root).  It would be way too much work right now to move away from that.

Q: how best to hold the animation info?


        ObjectScenePtr
              o
              |
              +-------- BtOgreInst
                         o o o o
                         | | | |
                         | | | +------- SkelBase
                         | | +--------- NiModelPtr
                         | +----------- Animation info (textkeys, controllers)
                         +------------- std::vector<Ogre::Entity*>


# [06/03/2019] Havok

If Havok enabled, assign a child SceneNode for each `btRgidBody`.

Q: how to allow the SceneNode to move across cell boundary?  is it an issue?

# [08/03/2019] Havok

In order to make Havok physics work, there is a need to mix rendering instances (e.g.  `Ogre::SceneNode`) and physics instances (i.e. `btRigidBody`).

The way OpenMW is currently written, they diverge at `::addObject()` (see: `mwworld/scene.cpp`) Fortunately, both call path end up with the same class, i.e.:

```cpp
ptr.getClass().insertObjectRendering(ptr, model, renderingmanager);
ptr.getClass().insertObject (ptr, model, physics);
```

So we can "cheat" by using the class as an access path to get to the rendering instances data which is currently stored in `ObjectAnimation`.  Havok enabled classes include most:

    LIGH (CathedralCryptLight02.NIF)
    STAT (TargetHeavy01.NIF)
    CREA (Skeleton.nif)
    NPC_ (Skeleton.nif)
    BOOK (Octavo02.NIF)
    APPA (ApparatusRetortMaster.NIF)
    etc, etc

# [09/09/2019] FaceGen texture again

  * EGT A binary file format containing texture statistics data for each pixel for each mode.

  * SCM The mean colour map is a 24-bit RGB colour image. Each mode is stored as a signed RGB8 map, along with a floating point scaling factor. Vertex UV co-ordinates do not change.

    DXGI_FORMAT_BC3_UNORM
    8 bits per pixel
    Transparent Selection

Four-component block-compression format. For information about block-compression formats, see [Texture Block Compression in Direct3D 11](https://docs.microsoft.com/en-us/windows/win32/api/dxgiformat/ne-dxgiformat-dxgi_format).

## UrielSeptim

Tried to figure out how the vanilla engine is keeping the age value by changing UrielSeptim's age using the TES Construction Set and saving it as an ESP.  It appears that the age value itself is not stored but the `FGGS` and `FGTS` records change.  There must be a way to derive the age value from them.

### Oblivion - Textures - Compressed.bsa

    textures\faces\oblivion.esm\00023f2e_0.dds
     px x  px  mip level
    256 x 256     1
    128 x 128     2
     64 x  64     3
     32 x  32     4
     16 x  16     5
      8 x   8     6
      4 x   4     7
      4 x   4     8
      4 x   4     9

### Oblivion - Textures - Compressed.bsa

    textures\faces\oblivion.esm\00023f2e_1.dds
     px x  px  mip level
     32 x  32     1
     16 x  16     2
      8 x   8     3
      4 x   4     4
      4 x   4     5
      4 x   4     6

### Oblivion - Meshes.bsa

    meshes\characters\imperial\headhuman.egm
    meshes\characters\imperial\headhuman.egt
    meshes\characters\imperial\headhuman.nif
    meshes\characters\imperial\headhuman.tri
    meshes\characters\imperial\headhuman_50.egm
    meshes\characters\imperial\headhuman_50.egt
    meshes\characters\imperial\headhuman_50.nif
    meshes\characters\imperial\headhuman_50.tri

### Oblivion - Misc.bsa

    facegen\si.ctl (not sure how to use the control data)

`headhuman.egt` has 256 rows and 256 columns. There are 50 symmetric morph modes and 0 asymmetric ones.  The texture basis version is 0x51 = 81.

# [14/09/2019 - 13/10/2019 - 28/12/2019]

Posted a [question on the OpenMW form](https://forum.openmw.org/viewtopic.php?f=3&t=3017&start=325) for some help regarding the application of age related texture to `headhuman.dds`

ponyrider0 replied with this suggestion:

```cpp
(base texture) * (age map / 64) = (composited face texture)

(age map) = (composited face texture / base texture) * 64
```

# [11/02/2020] finally getting back to work

```cpp
mNpc->mFormId   = 0x0001C458
mNpc->mEditorId = "BeggarICMarketSimplicia"

mNpc->mFormId   = 0x00023F2E
mNpc->mEditorId = "UrielSeptim"
```

## EGM
A binary format containing the principal component modes as one standard deviation vertex deltas.
See [fileformats](https://facegen.com/dl/sdk/doc/manual/fileformats.html).

    char[8]               Magic number for this filetype: 'FREGM002'
    unsigned long         Number of vertices (V) (Should equal V+K in TRI file)
    unsigned long         Number of symmetric morph modes (S)
    unsigned long         Number of asymmetric morph modes (A)
    unsigned long         Geometry Basis Version
    char[40]              Reserved
    (float+(short*3)*V)*S Symmetric morph mode data for each vertex and all modes.
                          For each mode in S,
                          Start with a floating point scale value x
                          For each vertex in V,
                          The morph values are stored as 3 signed short m. The actual morph values should be m * x.
    (float+(short*3)*V)*A As above for the asymmetric morph modes.

`openmw/apps/openmw/mwrender/foreignnpcanimation.cpp`

```cpp
const std::vector<Ogre::Vector3>& vertices = tri.getVertices(); // V + K

const std::vector<float>& sCoeff = mNpc->mSymShapeModeCoefficients;
const std::vector<float>& aCoeff = mNpc->mAsymShapeModeCoefficients;
const std::vector<float>& sRaceCoeff = mRace->mSymShapeModeCoefficients;
const std::vector<float>& aRaceCoeff = mRace->mAsymShapeModeCoefficients;

Ogre::Vector3 sym;
Ogre::Vector3 asym;
std::vector<Ogre::Vector3> fgVertices;
fgVertices.resize(tri.getNumVertices());
for (size_t i = 0; i < fgVertices.size(); ++i)
{
    sym = Ogre::Vector3::ZERO;
    for (size_t j = 0; j < 50; ++j) // for TES4 always 50 sym modes
    {
        sym += (sRaceCoeff[j] + sCoeff[j])  * egm.mSymMorphModes[50*i + j];
        //            ^             ^                 ^
        //            |             |                 |
        //          float         float           Ogre::Vector3
        //          race          npc_            EGM for the mesh
        //          (guess)                       (scaled for mode j)
    }

    asym = Ogre::Vector3::ZERO;
    for (size_t k = 0; k < 30; ++k) // for TES4 always 30 asym modes
    {
        asym += (aRaceCoeff[k] + aCoeff[k]) * egm.mAsymMorphModes[30*i + k];
    }

    fgVertices[i] = vertices[i] + sym + asym;
    //                  ^           ^     ^
    //                  |            \   /
    //                 TRI       race, npc_ & EGM (at i)
}
```

## EGT

Base texture example: `Textures\Characters\imperial\headhuman.dds`


# [13/02/2020] Trying to remember how the code works

`NiModel` is created using `NiModelManager`. e.g.:

```cpp
NiModelPtr npcModel = NiBtOgre::NiModelManager::getSingleton().getOrLoadByName(model, group);
```

Often it is created in the constructor of `BtOgreInst`.

`NiObjects` are constructed in `NiModel::loadImpl()` and stored in `NiModel::mObjects`.  The NIF file should already be opened via `NiStream` created in the constructor of `NiModel`.

The constructor of the each of `NiObjects` read the NIF file stream and populate various data structures in advance for the actual instantiation of the object at a later point in time.

# [16/02/2020] Refactor code generating the body parts.

See `openmw/apps/openmw/mwrender/foreignnpcanimation.cpp`:

For TES4, ESM/ESP specify the game based on the resources in the BSA (or loose) files.  The graphics and physics models for a given scene needs to be constructed and passed onto the respective engines for rendering, collisions, etc.

When a character is placed into a scene we do a few extra things compared to a static (or Havok based) objects.

  * A character has a set of animations some of which may get played depending on the character's current movements.
  * A character with animations will have a skeleton.
  * A character is usually made from several parts - head, hair, hands, clothes/armour, weapons, etc.
  * A character's race and it's own data (`npc_` record) will determine which mesh and texture to use.  For weapons/armour/etc, the character's currently equipped inventory will be visible.
  * Many of the parts will be "skinned".
  * For some body parts FaceGen will be used to create unique, but realistic appearances.

i.e. the specified skeleton, inventory, body parts, etc need to be sourced from NIF and other resources to be ready for instantiation by the rendering engine.

It should be noted that the resource "templates" (for the want of a better description) may be used by many different characters or objects.  They need to be managed by resource managers some kind (even if it is a simple static map).

Obviously, care needs to be taken in creating these resource "templates" so that executing the same piece of calculations is avoided or minimised.  In some cases it may be worth ordering the data structures so that cache misses are minimised.

# [17/02/2020] Refactor FaceGen related code

    stat morph vertices in TRI
    0x4fb + 0x1cd = 461
    npc_::hairlength

Each of `npc_::mHair` are present in `hair` records.  I guess to be safe the race default should be checked if it is not found.

# [17/02/2020] FindFFmpeg.cmake seems to be broken

Thought that was fixed?  Had to manually delete the component include directories from MSVC properties.  This happened after checking out an old branch to test something.

# [18/02/2020] Hair and Eyes

Most of the hair found in the BSA files are used in the game, except maybe below:

    Characters\Hair\Emperor.nif/egm
    Characters\Hair\NordFemaleBunches.nif/egm/tri
    Characters\Hair\OrcFemaleBunches.nif/egm/tri

Some of the hairs in the BSA files do not have a corresponding TRI file.  For these, it may be necessary to get the vertices from the NIF files.

    Characters\Hair\Blindfold.NIF
    Characters\Hair\Emperor.nif
    Characters\Hair\KhajiitEarrings.NIF
    Characters\Hair\Style07.NIF

So the method of getting the files should be:

  * get mHair and mEyes from `NPC_`
  * find the mesh and texture file names from HAIR and EYES
    - if not found, get the default hair (male/female `FormId`) and eyes (left/right mesh) from the corresponding RACE
    [07/03/20] RACE doesn't have default eyes, just some choices - possibly need to select a random one.
  * for EYES the mesh name is only in the RACE records (but not the texture nor the EYE `FormId`)
    [07/03/20] this no longers makes sense - what was I thinking?
  * the corresponding EGM and TRI files should be in the same directory as the mesh (EGT not used?)
  * for some HAIR the corresponding TRI files are not present in the BSA - maybe try to get the vertices from the mesh

# [22/02/2020] Hair textures

Noticed that some hair textures have 4 different files in a set:

    grey.dds
    grey_hh.dds
    grey_hl.dds
    grey_n.dds

Also noticed that the decompiled [shaders](https://github.com/Alenett/TES-Shaders) that the following textures are used:

    sampler2D AnisoMap   : register(s3);
    sampler2D DiffuseMap : register(s0);
    sampler2D HeightMap  : register(s2);
    sampler2D LayerMap   : register(s5);
    sampler2D NormalMap  : register(s1);

Diffuse (`*.dds`) and normal (`*_n.dds`) are easy enough but which ones are Aniso/Height/Layer?

Some [clues](https://www.nexusmods.com/skyrim/mods/30745?tab=posts) on the different texture maps:

>  Edit : Here's more information on the types of textures used in skyrim :
>
>  in a "menu"-folder: User-interface element, alpha is element-mask
>  in a "landscapelod"- or "terrain"-folder: World-space normal-map for terrain, no alpha
>  "_n"-suffix: Tangent-space normal-map, alpha is specularity
>  "_msn"-suffix: Model-space normal-map, no alpha
>  "_g"-, "_glow"- or "_emit"-suffix: Glow-map, alpha is a mask
>  "_hh"-suffix: Gloss-map for hair, no alpha
>  "_hl"-suffix: Detail-map for hair, alpha is opacity
>  "_m"-suffix: Reflectivity-map for light-sources, no alpha
>  "_em"- or "_envmap"-suffix: Reflectivity-map for environment-maps, no alpha
>  "_e"-suffix: Environment-map (some are planar, some are cube-maps), no alpha
>  "_b"- or "_bl"-suffix: Backlight-map, no alpha
>  "_s"-suffix: Specularity-map for skins, no alpha
>  "_sk"-suffix: Tone-map for skins, no alpha
>  "_p"-suffix: Parallax-map, no alpha
>  "_d"-suffix: Diffuse-map, alpha is opacity
>  "_h"-suffix: Haze-map, alpha is unknown
>  All others are color-map, alpha is opacity or parallax

Initial guesses are:

    AnisoMap:  alpha channel of `_n.dds`
    HeightMap: `_hh.dds`  (hair heightmap?)
    LayerMap:  `_hl.dds`  (hair layermap?)

`PSHairTint` is probably `Npc::mHairColour`

# [22/02/2020] Which Shaders?

Wasn't sure if the [shaders from Alenett](https://github.com/Alenett/TES-Shaders) was the same as the official ones (e.g. shaderpackage013.sdp).  Tried to decompile them using [TimeSlip's tool](http://timeslip.chorrol.com/current/ShaderEdit.7z) but even running from Windows XP mode on a Windows 7 PC the program crashes (maybe missing .NET version 2.0).

But this post from [juhana](https://forums.uesp.net/viewtopic.php?f=10&t=6955) gave a hint on how to read the file.  Using [xvi32](http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm) the number of shaders is 0x028D or 653.

    cc9c@LAPTOP-Q4SRRS0H:~/dev/src/TES-Shaders/OblivionShaders
    $ ls Disassembly/ | wc -l
    653

Looks like we're not missing anything, although I'm still not sure if different shader packages have slightly different implentations based on the detected GPU capabilities.

# [27/02/2020] Back to `Ogre::Resources`

## Past Week on Shaders

Spent the past week on reading up various aspects of Oblivion shaders.  Long story short - for now I will have to create a new material, say hair.mat (to fit in with `Shiny` naming scheme) and implement the shaders.  Once I am in a position to move to Ogre 2.1 then I will need to revisit the code since HLMS will come into pay.

## Manual loading of Resources

Can't quite figure out the right paradigm for auto-loading the resources.  So for now I will go ahead and load the morphed resources manually.

## Which Resources to manage?

We already have `Ogre::TextureManager`, `Ogre::MeshManager` and `NiModelManager`.  Not keen to introduce any more.

But what about the use of `Ogre::MaterialManager`?  It normally expects to load the materials from the material scripts but we will need to use manual loading instead.

`Ogre::ManualResourceLoader` can be implemented in different ways.  Ogre itself has a few examples.  The `MeshManager` way is probably the right fit here.

### Let the Resource inherit from `Ogre::ManualresourceLoader`

                     Resource   ManualResourceLoader
                          ^        ^
                           \      /
                            \    /
                             Font

### Let the ResourceManager inherit from `Ogre::ManualResourceLoader`

    ResourceManager  Singleton<MeshManager>  ManualResourceLoader
               ^               ^                ^
               |               |                |
               +----------     |     -----------+
                          \    |    /
                           \   |   /
                          MeshManager

## NiModelManager

Normally specifying the NIF file to NiModelManager will be enough.  The mesh, sub-mesh and material details specified in the NIF file are then used to create the Ogre resources and the respective managers are called during the build of the NIF model.  But we now need to supply additional info to create the morphed resources (the morphed vertices for the mesh/sub-mesh and the morphed texture for the material).

The typical way to get a `NiModel` is to call `NiModelManager::getOrLoadByName()`.  However we don't want to create morphed resources each time so we should overload `getByName()` then afterwards use `create()` and `load()`.

# [28/02/2020] Consider creating NiMaterialManager

The materials used in NIF models are not loaded from material scripts and are most likely (always?) manually loaded.  `NiMaterialManager` can inherit from `Ogre::MaterialManager` and `Ogre::ManualResourceLoader`.

One possibility is to pass on the `FormId` of the resource in a string so that the manual resource loader can get the required details for the resource.  But this means the resource loader will need to know about the implementation of the asset store (tight coupling).  Perhaps the class can be further specialised to provide implementations to pure virtual functions?  e.g. `findFromStore()`

# [28/02/2020] What FaceGen resource management do we need?

In summary we need the base model (NIF file), base texture, Npc record (for FGGS, etc) and Race record (again, FGGS, etc).

**TODO:** It is unclear if the properties in the NIF should be used in creating the material.

  Record              | Data
  --------------------|-----
  Npc                 | FGGS, FGTS, FGGA, mRace, mHair, mEyes
  Race                | FGGS, FGTS, FGGA, mHeadParts (models and textures except for eyes), mBodyParts (body texture), mData (flags)
  Hair                | mModel (model), mIcon (texture), mData (flags)
  Eyes                | mIcon (texture), mData (flags)
  Clothing (only hood)| mModelMale/mModelFemale (model), mIconMale/mIconFemale (texture), mClothingFlags
  Armor (only helmet) | mModelMale/mModelFemale (model), mIconMale/mIconFemale (texture), mArmorFlags

## Helmets and Hoods

Not sure how we identify hood & helmet - possibly by checking mArmorFlags/mClothingFlags.  The following armor/clothing in Oblivion.esm have **only** the `ESM4::Race::TES4_Hair` slot indicated in mArmorFlags/mClothingFlags (NOTE: only the bottom 16 bits are relavant) - looks like all of them?

[//]: # (                                                             {{{
    SEAmberMagicHelmet2
    SEAmberMagicHelmet1
    SEAmberHelmet2
    SEAmberHelmet1
    SEDarkSeducerOfficerHelmet1
    SEDarkSeducerOfficerHelmet2
    SEDarkSeducerOfficerHelmet3
    SEDarkSeducerOfficerHelmet4
    SEDarkSeducerOfficerHelmet5
    SEDarkSeducerOfficerHelmet6
    SEGoldenSaintOfficerHelmet1
    SEGoldenSaintOfficerHelmet2
    SEGoldenSaintOfficerHelmet3
    SEGoldenSaintOfficerHelmet4
    SEGoldenSaintOfficerHelmet5
    SEGoldenSaintOfficerHelmet6
    SETEST07ADarkSeducerEliteHelmet
    SETESTDarkSeducerOfficerHelmet
    SETESTGoldenSaintOfficerHelmet
    SEGoldenSaintHelmetReward6Daedric
    SEGoldenSaintHelmetReward5Ebony
    SEGoldenSaintHelmetReward4Orcish
    SEGoldenSaintHelmetReward3Dwarven
    SEGoldenSaintHelmetReward2Steel
    SEGoldenSaintHelmetReward1Iron
    SEDarkSeducerHelmetReward6Glass
    SEDarkSeducerHelmetReward5Elven
    SEDarkSeducerHelmetReward4Mithril
    SEDarkSeducerHelmetReward3Chain
    SEDarkSeducerHelmetReward2Leather
    SEDarkSeducerHelmetReward1Fur
    SE07ThadonsCrown30
    SE07ThadonsCrown25
    SE07ThadonsCrown20
    SE07ThadonsCrown15
    SE07ThadonsCrown10
    SE07ThadonsCrown05
    SE07ThadonsCrown01
    SETESTSaintHelmet
    SETESTHelmet
    SE07ADarkSeducerEliteHelmet
    SEDarkSeducerOfficerHelmet
    SEGoldenSaintOfficerHelmet
    SEEnchOrcishHelmetNighteye
    SEEnchSteelHelmetResistMagicka
    SEEnchMithrilHelmetNighteye
    SEEnchChainmailHelmetDetectLife
    SEEnchLeatherHelmetResistMagic
    SEEnchFurHelmetFortMagicka
    SEGoldenSaintHelmet6Daedric
    SEGoldenSaintHelmet5Ebony
    SEGoldenSaintHelmet4Orcish
    SEGoldenSaintHelmet3Dwarven
    SEGoldenSaintHelmet2Steel
    SEDarkSeducerHelmet6Glass
    SEDarkSeducerHelmet5Elven
    SEDarkSeducerHelmet4Mithril
    SEDarkSeducerHelmet3Chain
    SEDarkSeducerHelmet2Leather
    SEDarkSeducerHelmet1Fur
    SEGoldenSaintHelmet1Iron
    SEAmberMagicHelmet6
    SEAmberMagicHelmet5
    SEAmberMagicHelmet4
    SEAmberMagicHelmet3
    SEAmberHelmet6
    SEAmberHelmet5
    SEAmberHelmet4
    SEAmberHelmet3
    SE12GnarlWidget
    SE12OrderWidget
    DAUmbraHelmet15
    DAUmbraHelmet9
    PitHelmet
    TG11ElvenHelmet
    replicaElvenHelmet
    UniqueOrcishHelmFerocity
    BladesHelmetAncient
    MS27LindaiAyleidCrown05
    MS27NenalataAyleidCrown25
    MS27NenalataAyleidCrown20
    MS27NenalataAyleidCrown15
    MS27NenalataAyleidCrown10
    MS27NenalataAyleidCrown05
    MS27LindaiAyleidCrown25
    MS27LindaiAyleidCrown20
    MS27LindaiAyleidCrown15
    MS27LindaiAyleidCrown10
    ArenaBladesHelmet
    ArenaEbonyHelmet
    ArenaOrcishHelmet
    ArenaSteelHelmet
    ArenaIronHelmet
    ArenaGlassHelmet
    ArenaElvenHelmet
    ArenaMithrilHelmet
    ArenaLeatherHelmet
    ArenaFurHelmet
    ImperialDragonHelmetLight
    ImperialDragonHelmetHeavy
    LegionHelmet
    DarkFinGleam
    BloodwormHelm25
    BloodwormHelm20
    BloodwormHelm15
    BloodwormHelm10
    BloodwormHelm05
    DarkCaeliaHelmet
    CGIronHelmet
    ImperialPalaceHelmet
    CGLeatherHelmetBandit
    FGC07AmelionHelmet
    MS27LindaiAyleidCrownBroken
    FGD09BearclawHelm
    MS27NenalataAyleidCrown01
    MS27LindaiAyleidCrown01
    ArenaChainmailHelmet
    EnchEbonyHelmetWaterbreathing
    EnchEbonyHelmetResistMagicka
    EnchEbonyHelmetDetectLife
    EnchOrcishHelmetWaterbreathing
    EnchOrcishHelmetNighteye
    EnchOrcishHelmetFortMagicka
    EnchOrcishHelmetDetectLife
    EnchSteelHelmetWaterbreathing
    EnchSteelHelmetResistMagicka
    EnchSteelHelmetFortMagicka
    EnchSteelHelmetDetectLife
    EnchIronHelmetWaterbreathing
    EnchIronHelmetResistMagicka
    EnchIronHelmetDetectLife
    EnchIronHelmetFortMagicka
    EnchGlassHelmetResistMagicka
    EnchGlassHelmetDetectLife
    EnchElvenHelmetResistMagicka
    EnchElvenHelmetDetectLife
    EnchMithrilHelmetResistMagicka
    EnchMithrilHelmetNighteye
    EnchMithrilHelmetFortMagicka
    EnchMithrilHelmetDetectLife
    EnchChainmailHelmetResistMagicka
    EnchChainmailHelmetNighteye
    EnchChainmailHelmetFortMagicka
    EnchChainmailHelmetDetectLife
    EnchLeatherHelmetResistMagic
    EnchLeatherHelmetFortMagicka
    EnchLeatherHelmetDetectLife
    EnchFurHelmetResistMagicka
    EnchFurHelmetFortMagicka
    EnchFurHelmetDetectLife
    EnchEbonyHelmetMage
    EnchMithrilHelmetMind
    BlackwoodHelmet
    BladesHelmetCG
    MG10ElvenHelmet
    EmperorHelmet
    BloodwormHelm01
    EbonyHelmet
    OrcishHelmet
    GlassHelmet
    DBLeatherHelmet
    MithrilHelmet
    TownguardHelmet
    LegionHelmetOld
    FurHelmet
    BladesHelmet
    LeatherHelmet
    ChainmailHelmet
    IronHelmet
    ElvenHelmet
    SteelHelmet
    SEZealotHood
    SEHereticHood
    UniqueClothingHoodDiplomat
    UniqueClothingHoodGatherer
    UniqueClothingHoodSeer
    UniqueClothingHoodDruid
    UpperRobe03hood
    UpperRobe02hood
    LowerRobe05hood
    LowerRobe04hood
    LowerRobe03hood
    MGRobeHood
    DBBlackHandHood
    BlackHood
    MageHood
    ArchMageHood
    KingofWormsHood
    NecromancerHood
    LowerRobe02hood
    MythicDawnRobeHood
    TGGrayFoxCowl                                                     }}})

## Resource naming convension

  Resource Type    | Naming Convension
  -----------------|------------------
  Mesh             | base model + skeleton name + # + NiNode index + @ + NiNode name (see note 1 below)
  Mesh (proposed)  | skeleton name + _ + base model + # + NiNode index + @ + NiNode name
  Texture          | base texture (specified in the NIF for the sub-mesh)
  Material         | base model + @ + NiTriBasedGeom name (each sub-mesh has its own material, see note 2 below)
  NiModel          | base model
  Morphed Mesh     | NPC name + _ + base model + @ + NiNode name
  Morphed texture  | NPC name + _ + base texture
  Morphed Material | NPC name + _ + base model + @ + NiTriBasedGeom name
  Morphed NiModel  | NPC name + _ + base model

Note that, unlike other objects, FaceGen morph NIF models have **exactly one** NiNode with a `NiTriBasedGeom`.  i.e. one mesh  This means that the resources (mesh/materail/model) can't be reused.

**NOTE 1:** In TES5 `Architecture\Solitude\SolitudeBase.nif` has several NiNode instances with the same name.  Hence *both* NiNode index and NiNode name are needed in the mesh name.  Just the index is enough but for now it is easier for debugging if the NiNode name is also present.

**NOTE 2:** Material name may not match the actual NIF or NiTriBasedGeom (the same material from another model will be used if found).

## Putting it all together for NiModel

```cpp
NiBtOgre::NiModelManager& modelManager = NiBtOgre::NiModelManager::getSingleton();

// nif and texture are resource path + filename + ext
// the logic to locate nif & texture are hard coded
std::string name = mNpc->mEditorId + "_" + nif;

// the logic to locate the FaceGen files are hard coded
NiModelPtr morphedModel = modelManager.getByName(name);
if (morphedModel.isNull())
    morphedModel = modelManager.createMorphedModel(nif, "General", mNpc, mRace, texture);
```

The diagram from 01/01/2018 needs to be updated:

       ResourceManager   Singleton<NiModelManager>   ManualResourceLoader
                ^                    ^                    ^
                |                    |                    |
                +---------------+    |    +---------------+
                                |    |    |
                                |    |    |           Resource
                                |    |    |           ::load()
                                |    |    |              ^
                               NiModelManager            |
                               ::createImpl()  .....  NiModel
                               ::loadResource()       ::loadImpl()
                                                      ::unloadImpl()
                                                      ::prepareImpl()
                                                      ::unprepareImpl()


`NiModel::prepareImpl()` creates the NIF data stream and reads the header.  `NiModel::unprepareImpl()` undos `prepareImpl()`.  These are only called by `Ogre::Resource::load()` if NiModel is not manually loaded.  **TODO:** check if we have to call `prepareImpl()` for manual loading as well?

**NOTE:** consider changing `prepareImpl()` s.t. the NIF file is pre-buffered similar to `Ogre::Mesh::prepareImpl()`.  Below method implements the pre-buffering:

```cpp
Ogre::MemoryDataStream::MemoryDataStream(const String& name,
                                         const DataStreamPtr& sourceStream,
                                         bool freeOnClose = true,
                                         bool readOnly = false )
```

`NiModel::loadImpl()` parses the NIF data stream to create the objects.

Simplified interaction diagram for NiModel retrieving and manual loading sequences:
**NOTE:** NiModel is loaded immediately upon creation (like manual loading Ogre::Mesh).

        application    NiModelManager    ResourceManager   ManualResourceLoader   Resource
            |                 |                   |                 |                 |
            | getByName()     |                   |                 |                 |
            |---------------->|                   |                 |                 |
            |                 |getResourceByName()|                 |                 |
            |                 |------------------>|                 |                 |
            |                 |         Resource* |                 |                 |
            |      NiModelPtr |<------------------|                 |                 |
            |<----------------|                   |                 |                 |
            :                 :                   :                 :                 :
            :                 :                   :                 :                 :
            | createMorphedModel()                |                 |                 |
            |---------------->|                   |                 |                 |
            |                 |--+                |                 |                 |
            |                 |  | createManual() |                 |                 |
            |                 |<-+                |                 |                 |
            |                 |--+                |                 |                 |
            |                 |  | create()       |                 |                 |
            |                 |<-+                |                 |                 |
            |                 | createResource()  |                 |                 |
            |                 |------------------>|                 |                 |
            |                 |      createImpl() |                 |                 |
            |                 |<------------------|                 |                 |
            |                 | load()            |                 |                 |
            |                 |------------------------------------------------------>|
            |                 |                   |                 |  loadResource() |
            |                 |                   |  loadResource() |<----------------|
            |                 |<------------------------------------|                 |
            |                 |--+                |                 |                 |
            |                 |  | ...            |                 |                 |
            |      NiModelPtr |<-+                |                 |                 |
            |<----------------|                   |                 |                 |
            |                 |                   |                 |                 |


# [29/02/2020] Redesign mesh loading

Currently `Ogre::Mesh` is created and loaded *only* when an `Ogre::Entity` is instantiated.  That means, at least with the current design, NiModel is not fully built after `load()`.  It also means that any `Ogre::Material` used by the meshes are not created/loaded, either.

So, if we are to retain our current design, any morphed vertices or textures need to be prepared for loading the meshes and/or material at a later point in time.

For the morphed vertices, we can directly modify the vertices read in from the NIF file.  The vertices are read and stored from the constructor (in `NiGeometryData::mVertices` as `std::vector<Ogre::Vector3>`).

**TODO:** Current design uses the vertices from the TRI file, if available, rather than the one from the NIF.  These are slightly different (see `Characters\Imperial\HeadHumah.TRI`).  Alternatively, both sets of vertices could be stored at the cost of some memory so that the solution can be fine tuned later.

**FIXME:** Should the normals, tangents and bitangents in NiGeometryData be re-calculated once the vertices are morphed?

Current design:

        BtOgreInst   Ogre::MeshManager    NiModel             NiNode        NiTriBasedGeom
           |               |                |                   |                 |
           |               |                |                   |                 |--+
           |               |                |                   |registerSubMesh()|  | ctor
           |               |                |       insert      |<----------------|  |
           |               |                |  mMeshBuildList[] |                 |<-+
           |               |                |<------------------|                 |
           :               :                :                   :                 :
           :               :                :                   :                 :
           | instantiate() |                |                   |                 |
           |------------------------------->|                   |                 |
           |               |                |--+                |                 |
           |               |                |  |                |                 |
           |               |                |<-+                |                 |
           |               |                |                   |                 |
           |               | createManual() |--+                |                 |
           |               |<---------------|  |                |                 |
           |               |                |<-+ loop           |                 |
           |               |                |  mMeshBuildList[] |                 |
           |               |                |                   |                 |


Proposed change:

        BtOgreInst   Ogre::MeshManager    NiModel             NiNode        NiTriBasedGeom
           |               |                |                   |                 |
           |               |                |                   |                 |--+
           |               |                |                   |registerSubMesh()|  | ctor
           |               |                |       insert      |<----------------|  |
           |               |                |  mMeshBuildList[] |                 |<-+
           |               |                |<------------------|                 |
           |               |                |--+                |                 |
           |               |                |  | ...            |                 |
           |               |                |<-+                |                 |
           |               |                |                   |                 |
           |               | createManual() |--+                |                 |
           |               |<---------------|  |                |                 |
           |               |                |<-+ loop           |                 |
           |               |                |  mMeshBuildList[] |                 |
           :               :                :                   :                 :
           :               :                :                   :                 :
           | instantiate() |                |                   |                 |
           |------------------------------->|                   |                 |
           |               |                |                   |                 |


Rather than creating a new resource manager based on `Ogre::MeshManager`, we can try creating NiMeshLoader as a singleton.

NiModel is either created from the NIF file, via `NiModel::loadImpl()`, or manually via `NiModelManager::createMorphedModel()` and `NiModelManager::loadResource()`.  In former case, the NIF file name can be deduced from the mesh name by takeing away the skeleton name (if any) and the NiNode name.  In latter case, re-loading the NiModel appears a little more difficult.

**IDEA:** It might be possible to get Ogre to do most of the work - maybe just remember the resource name and get NiModelPtr from NiModelManager singleton?  Or just save a `NiModel*` and use it during `loadResource()`.

Simplified create and load interactions of NiMeshLoader:

        application      MeshManager   ResourceManager NiMeshLoader  ManualResourceLoader  Resource
            |                |                  |           |                |                |
            | createXXXXXX() |                  |           |                |                |
            |---------------------------------------------->|                |                |
            |                |               createManual() |                |                |
            |                |<-----------------------------|                |                |
            |                | createResource() |           |                |                |
            |                |----------------->|           |                |                |
            |                |     createImpl() |           |                |                |
            |                |<-----------------|           |                |                |
            |                | new Mesh         |           |                |                |
            |                |----------------->|           |                |                |
            |                |           Mesh*  |           |                |                |
            |                |<-----------------|           |                |                |
            |                | MeshPtr          |           |                |                |
            |                |----------------------------->|                |                |
            |                |                  |           |--+ store       |                |
            |                |                  |           |  | param       |                |
            |                |                  |   MeshPtr |<-+             |                |
            |<----------------------------------------------|                |                |
            :                :                  :           :                :                :
            :                :                  :           :                :                :
            |--------------->|                  |           |                |                |
            |                | load()           |           |                |                |
            |                |--------------------------------------------------------------->|
            |                |                  |           |                | loadResource() |
            |                |                  |           | loadResource() |<---------------|
            |                |                  |           |<---------------|                |
            |                |                  |           |--+             |                |
            |                |                  |           |  | ...         |                |
            |                |                  |           |<-+             |                |
            |                |                  |           |                |                |


## ToDo

  * Mesh and Material creation parts from NiModel should be moved to the loading stage.  i.e. at least create the meshes during NiModel load stage - currently the meshes are created during instantiation

  * Need to fix `SkeletonLoader` and `BtRigidBodyCIManager`.

# [01/03/2020] Material

## FaceGenMap in shaders

Looking at the decompiled [shaders](https://github.com/Alenett/TES-Shaders) again and noticed that all of the ones with FaceGenMap have 2 of them.  Most of them are numbered 0 and 1, e.g. FaceGenMap0, FaceGenMap1.  One of them must be the NPC specific detail map in `textures\faces\oblivion.esm`.  But what is the other one?  It must be either the second, smaller detail map in the same directory (`DXGI_FORMAT_BC3_UNORM`, 32x32 only) or the age-based detail texture for headhuman.dds (`DXGI_FORMAT_BC1_UNORM`, 256x256).

Either way, still need to figure out how to determine the NPC's age just by examininig their FGGS and/or FGTS.  See previous notes from 09/09/2019.

The normal map for `headhuman.dds` must be age-based as well? (i.e. replace, not merge with `headhuman_n.dds`)
**TODO:** experiement and compare the in-game visuals

## NPC Age

Figured out how to get the NPC age value.

# [02/03/2020] Commit the changes since 17/02/2020

  * equipment slot handling as per OpenMW's implementation
  * moved FaceGen code to extern/fglib
  * FaceGen NPC age
  * redesigned resource management for `NiModel` and `NiMesh` (still to fix `Skeleton` and `BtRigidBodyCI`)

## SkeletonLoader

Make `SkeletonLoader` work the same way as NiMeshLoader.  Not too happy about creating so many singletons, however.  Is there another way to ensure the skeleton manual loader to hang around?

There are 3 different use cases for skeletons.

  1. An NiModel may need to build a skeleton to animate the entities/meshes in the Model.
  2. An NiModel may be "skinned", i.e. depends on an external skeleton (see below).  **NOTE:** there may be several different skeletons, so there needs to several different NiModels even with the same base NIF.
  3. An NiModel may be a skeleton itself.  In TES4, BSX flag will indicate if a NIF is a skeleton.

## `MWRender::Animation::setObjectRoot()`

`ESM4::Npc::mModel` for TES4 or `ESM4::Race::mModelMale`/`ESM4::Race::mModelFemale` for TES5 are the skeletal models for an NPC.

# [03/03/2020] Skeletons

Manual creation for a skeleton `NiModel`:

        application    NiModelManager       NiModel        NiNode    NiSkeletonLoader  Ogre::Skeleton
          |               |                   |              |               |                |
          | getByName()   |                   |              |               |                |
          |-------------->|                   |              |               |                |
          |    NiModelPtr |                   |              |               |                |
          |<--------------|                   |              |               |                |
          |               |                   |              |               |                |
          |createSkeletonModel()              |              |               |                |
          |-------------->|                   |              |               |                |
          |               |                   |              |               |                |
          |               | load()            |              |               |                |
          |               |------------------>|              |               |                |
          |               | loadResource()    |              |               |                |
          |               |<------------------|              |               |                |
          |               |                   |              |               |                |
          |               | createNiObjects() |              |               |                |
          |               |------------------>|              |               |                |
          |               |                   |              |               |                |
          |               |buildFullSkeleton()|              |               |                |
          |               |------------------>|              |               |                |
          |               |                   | createFullSkeleton()         |                |
          |               |                   |----------------------------->|                |
          |               |                   |    Ogre::SkeletonPtr         |                |
          |               |                   |<-----------------------------|                |
          |               |                   |              |               |                |
          |               |                   | load()       |               |                |
          |               |                   |---------------------------------------------->|
          |               |                   |              |               | loadResource() |
          |               |                   |              |               |<---------------|
          |               |                   |              | addAllBones() |                |
          |               |                   |              |<--------------|                |
          |               |                   |              | createBone()  |                |
          |               |                   |              |------------------------------->|
          |               | createDummyMesh() |              |               |                |
          |               |------------------>|              |               |                |
          |               |                   |              |               |                |


Creation for a normal `NiModel`:
**NOTE:** `createSkeleton()` is currently triggered by build() which seems too late
**NOTE:** `createSkeleton()`/`addBones()` uses `NiNode::mChildBoneNodes` whereas `createFullSkeleton()`/`addAllBones()` uses `NiNode::mChildren`

        application    NiModelManager    NiModel            NiNode   NiSkeletonLoader  Ogre::Skeleton
          |               |                |                  |              |                |
          |getOrLoadByName()               |                  |              |                |
          |-------------->|                |                  |              |                |
          |               | load()         |                  |              |                |
          |               |--------------->|                  |              |                |
          |               |                |--+ prepareImpl() |              |                |
          |               |                |<-+               |              |                |
          |               |                |                  |              |                |
          |               |                |--+ loadImpl()    |              |                |
          |               |                |  |               |              |                |
          |               |                | createNiObjects()|              |                |
          |               |                | buildBones()     |              |                |
          |               |                |  | findBones()   |              |                |
          |               |                |  | ------------->|--+           |                |
          |               |                |<-+              mChildBoneNodes |                |
          |               |                |                  |<-+           |                |
          :               :                :                  :              :                :
          :               :                :                  :              :                :
          | build()       |                |                  |              |                |
          |------------------------------->|                  |              |                |
          |     ^         |                | createSkeleton() |              |                |
          |     |         |                |-------------------------------->|                |
          |   remove      |                |    Ogre::SkeletonPtr            |                |
          |    call       |                |<--------------------------------|                |
          |               |                |                  |              |                |
          |               |                | load()           |              |                |
          |               |                |------------------------------------------------->|
          |               |                |                  |              | loadResource() |
          |               |                |                  |              |<---------------|
          |               |                |                  | addBones()   |                |
          |               |                |                  |<-------------|                |
          |               |                |                  | createBone() |                |
          |               |                |                  |------------------------------>|
          |               | createMesh()   |                  |              |                |
          |               |--------------->|                  |              |                |
          |               |                |                  |              |                |


**NOTE:** After all that effort, the new method of using `createFullSkeleton()/addAllBones()` turned out to be inferior and had to revert to using `createSkeleton()/buildSkeletion()/addBones()` even for skeleton.nif, etc.

# [04/03/2020] Trying to get doors working again.

  * [15/02/19] af0e502c75c2df5ab8853ef43e38fc60558863b3 doors work
  * [17/02/20] 004a1d72985115fed43acd644f5da8ce2d90d302 doors no longer work

But so much change in a year - don't know where to start.  Looking at the call stack:

    openmw.exe!MWWorld::Scene::searchPtrViaHandle(const std::string & handle) Line 956	C++
    openmw.exe!MWWorld::World::searchPtrViaHandle(const std::string & handle) Line 734	C++
    openmw.exe!MWWorld::World::getPtrViaHandle(const std::string & handle) Line 723	C++
    openmw.exe!MWWorld::World::getFacedObject() Line 1126	C++
    openmw.exe!MWWorld::World::updateWindowManager() Line 1797	C++

Maybe we're not storing the physics handles properly?  Placed a breakpoint at `PhysicEngine::createAndAdjustRagdollBody()` to track `Dungeons\Chargen\impDunDoor02.NIF`:

```cpp
RigidBody* PhysicEngine::createAndAdjustRigidBody(const std::string &mesh, const std::string &name,
```

The comparison of ptr.mRef.mData.mBaseNode.mName with OEngine::Physic::RigidBody::mName is done here:

```cpp
Ptr World::getPtrViaHandle (const std::string& handle)
{
    Ptr res = searchPtrViaHandle (handle);
    if (res.isEmpty ())
        throw std::runtime_error ("unknown Ogre handle: " + handle);
    return res;
}
```

Ok, that means the handle in `InsertFunctor::operator()` (scene.cpp) should be the same as the on returned by `rayTest()` and subsequently getPrtViaHandle().

```cpp
try
{
    addObject(ptr, mPhysics, mRendering);   // <---- check here
    updateObjectLocalRotation(ptr, mPhysics, mRendering);
    if (ptr.getRefData().getBaseNode())
```

It should be noted that RigidBody::mName is the same for **all** rigid bodies in a NIF.  There are some overly complicated code to handle this.

After some stepping through the debugger, it turns out that the raycast creation was not done, see below:

```cpp
if (objAnim && !objAnim->getPhysicsNodeMap().empty())  // FIXME: this is such a bad hack
{
    mEngine->createAndAdjustRagdollBody(
        mesh, node->getName(), objAnim->getPhysicsNodeMap(), ptr.getCellRef().getScale(), node->getPosition(), node->getOrientation(), 0, 0, false, placeable);
    return;
}
```

## FIXME #1

Index number looks wrong?

    havok meshes\dungeons\chargen\idcrumblewall01.nif#44@IDCrumbleBrick05
    havok meshes\dungeons\chargen\idcrumblewall01.nif#61@IDCrumbleBrick06
    havok meshes\dungeons\chargen\idcrumblewall01.nif#72@IDCrumbleBrick07
    havok meshes\dungeons\chargen\idcrumblewall01.nif#83@IDCrumbleBrick08
    havok meshes\dungeons\chargen\idcrumblewall01.nif#94@IDCrumbleBrick09
    havok meshes\dungeons\chargen\idcrumblewall01.nif#105@IDCrumbleBrick10
    havok meshes\dungeons\chargen\idcrumblewall01.nif#116@IDCrumbleBrick06b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#127@IDCrumbleBrick07b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#138@IDCrumbleBrick08b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#149@IDCrumbleBrick01
    havok meshes\dungeons\chargen\idcrumblewall01.nif#158@IDCrumbleBrick02
    havok meshes\dungeons\chargen\idcrumblewall01.nif#169@IDCrumbleBrick03
    havok meshes\dungeons\chargen\idcrumblewall01.nif#177@IDCrumbleBrick04
    havok meshes\dungeons\chargen\prisonsecretwallswitch01.nif#16@Switch
    havok meshes\dungeons\chargen\prisonsecretwall01.nif#114@bed
    havok meshes\dungeons\chargen\prisonsecretwall01.nif#126@wall
    phantom: meshes\dungeons\misc\triggers\trigzone02.nif
    havok meshes\dungeons\chargen\prisoncelltorch01.nif#0@PrisonCellTorch01
    havok meshes\dungeons\chargen\ropebucket01.nif#75@Bucket
    havok meshes\armor\leather\shield.nif#0@Shield
    havok meshes\dungeons\chargen\cgprisoncellgate01.nif#24@gate01
    havok meshes\dungeons\chargen\cgprisoncellgate01.nif#44@gate02
    havok meshes\dungeons\chargen\idgate01.nif#24@IDGate01b
    havok meshes\dungeons\chargen\idgate01.nif#36@IDGate01c
    havok meshes\architecture\castleinterior\towersmall\castletowerdoor01anim.nif#17@CastleTowerDoor01Anim NonAccum
    havok meshes\dungeons\caves\cdoor03.nif#31@CDoor03 NonAccum
    havok meshes\dungeons\caves\cdoor03.nif#37@Door
    havok meshes\dungeons\caves\cdoor03.nif#49@Door@#0 <- 48?

## FIXME #2

handleToMesh keeps growing!!!  git blame says:

    33fe80723c (Jason Hooks     2012-06-17 20:56:10 -0400)

```cpp
void PhysicsSystem::addObject (const Ptr& ptr, const std::string& mesh, bool placeable)
    handleToMesh[node->getName()] = mesh;
```

## FIXME #3

    // TODO: probably possible to optimise the use of the "group" parameter, e.g. per cell


# [04/03/2020] Finding missing TrapLog

COC "ImperialDungeon05" and look for `Dungeons\Caves\Traps\CTrapLog01.NIF`.  Found it - it turns out that `CollisoinType_World` had to be added in th flags otherwise the collision shapes don't collide with the floor and sink through.

```cpp
if (!raycasting)
{
    assert (mCollisionObjectMap.find(name) == mCollisionObjectMap.end());
    mDynamicsWorld->addRigidBody(
            //body,CollisionType_World,CollisionType_Actor|CollisionType_HeightMap);
            body,CollisionType_World,CollisionType_World|CollisionType_Actor|CollisionType_HeightMap);
    if (numBodies == 0)
        mCollisionObjectMap[name] = body; // register only the parent
}
```

**The activator is not working, however.**  Activation results in some weird rotation of the logs.

**Also, there is this strange piece of code:**

```cpp
// FIXME
if (lowerMesh.find("traplog") == std::string::npos)
    return createAndAdjustRigidBody(mesh, name, scale, position, rotation, scaledBoxTranslation, boxRotation,   raycasting, placeable);
```

That might be due to the inability to determine whether the rigid bodies are ragdoll or not? **NOTE: 08/03/20** most likely due to ragdoll being broken, other than the trap logs.

# [05/03/2020] Making progress with NiModel

Naming convension needs to be revisited.  A head model may be morphed per NPC's FaceGen coefficients.  However it is alos skinned, meaning it will have an external skeleton.  **NOTE:** not sure if the external skeleton can be anything other than skeleton.nif for FaceGen head models.

Made progress with morphed models but looks like a redesign is required.  There were some assumptions that may not be correct:

  * Assumed all models that needs to attach to a bone has "Prn" NiStringExtraData - however ears and eyes don't.
  * Assumed it would be ok to use the vertices from the NIF files when the corresponding TRI files do not exist.  However some helmets (e.g. Armor\Blades\M\Helmet.NIF and Armor\LegionHorsebackGuard\Helmet.NIF ) clip the head model when the vertices are morphed this way.  Maybe it is better not to morph if the TRI file does not exist?

Also the codebase has become a spaghetti mess and is rather difficult to follow.

## More code restructuring - model and mesh naming

Initially we may not be certain if the model is skinned - only once the NiObjects created in loadResource we can decide whether the skeleton is needed.  But then it becomes difficult to maintain the model and mesh naming convention where the skeleton name is prepended for skinned models.

One possible solution is to always build a "test" model to see if it is skinned. If it turns out that the model is not skinned, we can go ahead and load it and instantiate it.  If it is skinned then a new model with a different name may be required (but maybe only with equipment that can be shared with multiple types of skeletons?).

For skinned body parts for creatures we don't need to worry about the uniqueness of the model/mesh names.  But then perhaps we are making things more complicated with special handling for creatures, etc.

# [06/03/2020] Continuing...

## FIXME #4

  * TRI file exeption commented out
  * Case folding for skeleton and object names are causing no end of troubles.  For now only fold skeleton names.
  * The use of skeletonRoot() in NiSkeletonLoader is not working

## Head parts progress

It turns out that even helmets (not skinned) look better when morphed.  This will make the code a little simpler.

For some reason the parts that attach to `Bip01 Head` require postion and rotation adjustment.

```cpp
if (targetBone == "Bip01 Head")
{
    orientation = bone->getOrientation() * Ogre::Quaternion(Ogre::Degree(90), Ogre::Vector3::UNIT_Y);
    position = Ogre::Vector3(0.45f/*up*/, -0.55f/*forward*/, 0.f/*right*/);
}

```

Some NIF files do not supply the target bone (e.g. eyes, ears).  They just have to be hard coded.

# [07/03/2020] Continuing...

Some ears do have the right rotation (e.g. earskhajiit.nif) and some don't (e.g. eyeslefthuman.nif). So above rotation hack with "Bip01 Head" needs to be further modified.

```cpp
if (targetBone == "Bip01 Head" && baseRotation == Ogre::Quaternion::IDENTITY)
```

## FIXME #5

  * **FIXED** crash accessing nullptr (prob. NiModel) during animation - I think this was caused by animation trying to move skeletons but some body parts didn't have skeleton root - we use external skeletons so we don't need this code block that copies bone position/rotaions
  * **FIXED** no eyes Cludette Perrick (The Gilded Carafe) - her NPC record does not have mEyes so we need to use the race defaults instead **TODO** need to remember the random selection so that we don't see a new texture each time.
  * **FIXED: 08/03/20** one of the metal gates in the IC sewers doesn't move the collision shape (also the display cases)
  * [ESM4::Npc] = {mFormId=0x0004ef6f mFlags=0x00040000 mEditorId="CheydinhalGuardCityPostNight03" ...}
  * **FIXED 08/03/20** error during rendering: ItemIdentityException: Bone named '' not found. in Skeleton::getBone at C:\Users\cc9c\Dev\src\ogre\OgreMain\src\OgreSkeleton.cpp (line 515) - no ears for Argonians so added a check

## Design notes on body part handling

TES4 allows 16 body parts, FO3/FONV allows 20 and TES5 allows 32 body parts.  The "ForeignNPC" code should be able to deal with all - but to do so it cannot have special handling for a particular body part (or at least, not very many).

Note that the race body parts share the "slots" used by the armor/cloth body parts.  These will need to be translated depending on the game.

Now mObjectParts in ForeignNpcAnimation is a map keyed by `ESM4::Armor::ArmorFlags`.  Note that the keys are not consequitive.  Body parts and weapons will need some translations to get the right keys.

**NOTE:** TES4/TES5/FO3/FONV will each have different key values for the same slot, where they do have the same slot.  For example "Tail" slot between TES4 and TES5 are different.  However, the "Head" and "Hair" values are the same for all games.

**TODO:** The inventorystore currently only supports TES4.  Its slot handling is not very well suited for TES4, etc, and will need some changes to make things more efficient.

# [08/03/2020] Testing resource management

Looks like `getResourceByName()` does not retrieve existing resources.  `mResources.find(name)` returns `mResources.end()` even though I can see the resource in mResources using the debugger.

```cpp
ResourcePtr ResourceManager::getResourceByName(const String& name, const String& groupName /* = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME */)
{
    OGRE_LOCK_AUTO_MUTEX;

    // resource should be in global pool
    bool isGlobal = ResourceGroupManager::getSingleton().isResourceGroupInGlobalPool(groupName);

    if(isGlobal)
    {
        ResourceMap::iterator it = mResources.find(name);
        if( it != mResources.end())
        {
            return it->second;
        }
    }
```

mResources is meant to be an Ogre defined vector type, StringVector which in turn is defined as:

```cpp
template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> >
struct vector
{
    typedef typename std::vector<T, A> type;
    typedef typename std::vector<T, A>::iterator iterator;
    typedef typename std::vector<T, A>::const_iterator const_iterator;
};
```

That leads to xhash in MSVC - does this mean it might be a compiler bug?

```cpp
_NODISCARD iterator find(const key_type& _Keyval)
    {	// find an element in mutable hash table that matches _Keyval
    return (lower_bound(_Keyval));
    }
```

```cpp
size_t first = str_hash(Ogre::String("BeggarICMarketsSimplicia_" + meshName));
size_t second = str_hash(Ogre::String(mNpc->mEditorId + "_" + meshName));
```

    first   0x5f7b25ae61145ef8  unsigned __int64
    second  0x5fb1324631bf5133  unsigned __int64

Hmmm... this is rather embarassing - it turns out we had a false positive - I simply had mis-spelt the hard coded name for testing.

# [08/03/2020] Physics issues

## Doors

  * **WONTFIX:** 0x000947B2 gate does not rotate on its edge (well it does, but not right at the edge - it could be just the way the NIF is done)
  * **FIXED:** 0x0002A5C0 collision shape does not move, `dungeons\sewers\sewertunneldoor01.nif` - in `PhysicsSystem::rotateSubObject` only the parent object was checked for being static object when its child (children?) may not be.
  * **FIXED:** 0003725e Architecture\ImperialCity\Interior\ICDoorInt01.NIF rotates on the center axis - this particular one turns out to be a static shape, so we can stop the physic shape rotating in rotateObject(), but how to stop the rendering to rotate as well? - resolved by adding a check in processDoors().  Places to test include:
    - COC "KvatchChapelofAkatosh" - go down to the hall and see the wooden doors move
    - COC "ImperialDungeon03" - various gates and doors
    - COW "AnvilWorld" -46 -8 - check the stone wall gate
    - COW "ICMarketDistrict" 8 16 - check the display case then go to the sewers and check the gates and doors
    - COC "WeynonPrioryHouse" - nothing here
  * worldimp::processDoors add collision test

The bone names between the physics system and Ogre are communicated using the NiNode/NiAVObject names.  BtRigidBodyCI:mTargetNames hold the strings, keyed by the indices of the target nodes.  For non-static rigid bodies these target names are transferred to `OEngine::Physic::RigidBody::mTargetName`.

Note that a model may have a number of rigid bodies (like entities) and there is a concept of parent/child to deal with the raycasting test (see the notes on 04/03/20).

Now since the **Ogre::Bone names match the RigidBody target name**, the physics system can mimic the movements of the rendering system.

## Ragdolls

  * COC "ImperialDungeon05" and look for `Dungeons\Caves\Traps\CTrapLog01.NIF` to test.
  * COC "ICMarketDistrictAFightingChance" for the CathedralCryptLight02.NIF and TargetHeavy01.NIF (but easier to get there from outside)
  * COC "WellspringCave" to see the hanging roots (Dungeons\Misc\RootHavok06.NIF)

The vines at Wellspring Cave look ok except:
  * the collision shapes are not linked (i.e. constraints)
  * the entities do not move with the collision shapes
  * the scale is not right at all

Ragdoll trap logs call stack

    OEngine::Physic::PhysicEngine::stepSimulation()
         ...
        btDiscreteDynamicsWorld::stepSimulation
              ...
            btDiscreteDynamicsWorld::applyGravity
              ...
            btDiscreteDynamicsWorld::synchronizeMotionStates
                  ...
                btDiscreteDynamicsWorld::synchronizeSingleMotionState

### mBhkRigidBodyMap

`BtOgre::RigidBodyState` is setup and passed to `btRigidBody` during the call `PhysicEngine::createAndAdjustRagdollBody()`.  Note that it is not created in normal createAndAdjustRigidBody().  The key difference with createAndAdjustRagdollBody() is that it passes `const std::map<std::int32_t, Ogre::SceneNode*>& nodeMap` from `PhysicsSystem::addObject()` which in turn gets it from `ObjectAnimation` (the map is filled during ObjectAnimation's ctor).

The info for the map ultimately comes from `NiModel::mBuildData::mBhkRigidBodyMap` which is filled by the constructor of bhkNiCollisionObject.  It knows the connection between the rigid body and the target node (which will eventually become an Ogre::Entity).

It should be noted that `btRigidBody` keep pointers to collision shapes so we need to find a way to ensure the lifetime of the collision shapes.  These are currently maintained in `BtRigidBodyCI::mBtCollisionShapeMap`.

**FIXME:** BtRigidBodyCI is an Ogre::Resource.  These resources can be unloaded by the resource manager, which will result in crashes due to the collision shape pointers being deleted...   There must be a way to link BtRigidBodyCI to the associated Ogre::Entity or keeping them in RigidBody (like motion state).

###  mBhkConstraints

A `bhkRigidBody` has a list of constraints for that rigid body.

A ragdoll, in simple terms, the `btRigidBody` tells `btMotionState` of its movements and `btMotionState` then tells the associated `Ogre::SceneNode` to make corresponding movements.  When the `SceneNode` moves the attached `Ogre::Entity` moves as well.

                                                   1
      Ogre::Entity               btCollisionShape ----o btCollisionObject
           |1                                                ^
           |                                1                |       2
        (attach)              btMotionState -----------o btRigidBody ----o btTypedConstraint
           |                        ^                        ^
           o         1              |                        |
     Ogre::SceneNode ----o BtOgre::RigidBodyState     Physic::RigidBody
           |n
           |
        (child)
           |
        mInsert


### Lifetime

Like `Ogre::Entity`, a `btRigidBody` in a cell should be destroyed once they are no longer needed.  The constraints should be deleted at the same time.  `Physic::RigidBody` can delete `btMotionState` and `btCollisionShape` in its destructor.

Alternatively, it may be possible for `Physic::RigidBody` to keep a smart pointer to NiModel and use the collision shapes owned and stored there (by keeping a smart pointer we can ensure that NiModel won't go away).  That may save the need to create new `btCollisionShape` for each `btRigidBody`.

**TODO:** make it work similar to meshes?

### Node animation comparison

For node animation, The PhysicsSystem uses the SceneNode name as the key to find the RigidBody from PhysicEngine.  The RigidBody can then be moved, rotated, etc, based on the changes on the SceneNode.  The PhysicsSystem also uses the NIF name ("mesh") for scaling, etc, for older style (TES3) objects - this is possible because with the OpenMW implementation of TES3 there is only one RigidBody (and one Ogre::Entity) per NIF.

TES4 RigidBody can have multiple btRigdBody within one NIF model.  But to get the existing system to work the RigidBody needs to return the "handle" (i.e. Ogre::SceneNode name) of the base RigidBody only.  Hence all its children have the same `mName` so that rayTest(), etc, can work as before.

Multiple RigidBodies within one NIF model is managed by `BtRigidBodyCI` which uses the map of target node to collision shapes in the NiModel to provide the data for creating the base RigidBody and its children.

                                                        1
       Ptr . . . . . . . . . . . PhysicsSystem o--------- PhysicEngine
        o                          ::handleToMesh[]         ::mCollisionObjectMap[]
        |                                o   o                    o         o
        |  Ogre::Node           key      |   |                    |         |
        |    ^  ::mName -----------------+   |                    | value   | key
        |    |                               |value               |         |
     Ogre::SceneNode          NiModel        |            Physic::RigidBody |
                               ::mModelName -+                 ::mName -----+
                               ::map<target node,                (Ogre::SceneNode name)
                                     collision shape>          ::mTargetName
                                                                 (target node, parent)
                                                               ::mChildren


During `NiModel::buildModel()`, `NiMultiTargetTransformController` fills `NiModel::mBuildData::mMovingBoneNameMap`  (for FO3, `NiControllerSequence` does that instead). `BtOgreInst` then uses that to fill `mSkeletonAnimEntities` - unfortunately relying on the `Ogre::Entity`'s `Ogre::Mesh` names to match the `NiNode` names.  Clearly this won't work with specialised meshes with skeleton or NPC's name prepended (but then they won't have any node animations, either).

Whether `mSkeletonAnimEntities` has anything determines whether node animation wil be used (e.g. by doors).

# [09/03/2020] Fixing bugs

## Animated Havok objects

The prison cell gate (COC "ImperialDungeon01", `Dungeons\Chargen\CGprisonCellGate01.NIF`) should not be a ragdoll implementation.  It's probably because of this line in the `ObjectAnimation` ctor:

```cpp
if (mObjectRoot->mForeignObj->havokEnabled())
```

That flag is set by `NiIntergerExtraData` using the `BSX` flags in the NIF file (e.g. `Dungeons\Chargen\IDGate01.NIF`, `FormId` 0x0003665B).  `IDGate01` has `BSX` flag 0x0B which for TES4 includes "enable animation", "enable collision" and "enable havok".

We may need to change the code to exclude the models with animation enabled?  But that disables ragdoll from others such as `Dungeons\Misc\RootHavok06.NIF`.  Maybe it will be necessary to capture the presence of constraints during the construction of the NiModel.  **FIXME:** Even so objects such as `Clutter\MinotaurHead.NIF` and `Dungeons\Caves\Traps\CTrapLog01.NIF` will have both animation and havok enabled, so some kind of control mechanism will need to be devised.

CTrapLog01 animation, looking from the left of the pile from the top of the hill:

                 Log05 =========
              Log04 Log03 =========
            Log  Log01 Log02 =========

`NiTransformInterpolator` (block 8) rotates Log02 once manually triggered.  `NiBlendTransformInterpolator` (block 6) has a flag with value `MANAGER_CONTROLLED` which is probably how the vanilla engine implements this, through an activator.

This object has a script. From the Construction Set:

    scriptName CTrapLogs01SCRIPT                                      {{{)

    ; On activation havok will turn on and logs will roll if placed on an incline
    ; Logs will continue to do damage for 6 seconds after activation

    short triggered
    float timer
    short next
    ref mySelf
    ref myParent

    float fTrapDamage
    float fLevelledDamage
    float fTrapPushBack
    float fTrapMinVelocity
    float fTrapDeathPushBack
    short bTrapContinuous

    begin onActivate

        if triggered == 0
    		set fTrapDamage to 30
    		set fTrapPushBack to 100
    		set fLevelledDamage to 1.5
    		set fTrapDeathPushBack to 80
    		set fTrapMinVelocity to 100
    		set bTrapContinuous to 0
    		playgroup unequip 1
    		set triggered to 1
    		set timer to 6
    		setDestroyed 1
    	endif

    end

    begin gameMode

    	;after 1 sec delay, activate parent (for daisy-chaining)
    	if triggered == 1 && next == 0 && timer < 5.5
    		set next to 1
    		set myParent to getParentRef
    		set mySelf to getSelf
    		myParent.activate mySelf 1
    	endif

    	if triggered == 1 && timer <= 0
    		set fTrapDamage to 5
    		set fTrapPushBack to 20
    		set triggered to 2
    	endif

    	if timer > 0
    		set timer to timer - getSecondsPassed
    	endif

    end

    begin onReset

    	reset3DState
    	set triggered to 0
    	setDestroyed 0

    end                                                               }}})

In comparison MinotaurHead activates immediately (i.e. falls down from the wall) then when the animation completes Havok commences.

How dow we distinguish objects that should begin havok upon the completion of the animation (e.g. trap log, minotaur head) and those that don't? (e.g. prison cell gate)

In summary, we disable Havok at the start if:

  1. Has no constraints; and
  2. Has animations (node animations only?)

There are no activators at Jensine's "Good as New" Merchandise. So it is still unclear how the `MinotaurHead` auto-plays the animation.  Maybe I am confused and in the vanilla game it does not fall at all?

## How to communicate the controls?

There are triggers, traps, sripts, etc, that require communications to the Entity and/or Rigidbody.  Also, there could be requests going out for playing sound effects, etc.

### Ragdoll control

Controlling ragdoll should be possible via `RigidBody::getMotionState()`.  Once cast into `BtOgre::RigidBodyState` we can control whether to move Ogre::SceneNode.  So the question will be how to get to RigidBody.  One way might be via `PhysicsSystem::handletoMesh`.

So an object with Havok enabled as well as animation the default can be to disable ragdoll.

Wait - doing above will simply stop the rendering updates.  Also we still need raycasting and collision.  We need another solution.

Apparently it might be possible to do this with:


```cpp
setLinearFactor(btVector3(0, 0, 0));
setAngularFactor(btVector3(0, 0, 0));
```

or if we can access the members directly:

```cpp
btRigdBody::m_linearFactor.setValue(0, 0, 0);
btRigdBody::m_angularFactor.setValue(0, 0, 0);
```

### Animation control

# [10/03/2020] Bug Fixes

## Storm Atronach missing entities

  * video posted 12/02/19 ok
  * 004a1d72985115fed43acd644f5da8ce2d90d302 15/02/20 ok
  * ccaf2c520f93ea2726b40a73fb36f975b6445840 17/02/20 ok
  * a98765fe96143a4bac7df424e4ccec183be32925 02/03/20 ok
  * d0bd93a6cd0f5185be367f4fe45b9b0f35923fad 04/03/20 broken

## EGM missing for Daedric Helmet

resourceName "meshes\\armor\\daedric\\m\\helmet.egm" missing exeption

Test by:

    COC "OblivionMQKvatchCitadel"
    COC "KvatchChapelOfAkatosh"
    <F12> to take screenshots

## Rotated RigidBody in Citadel door

Only sometimes!?

    (COC "OblivionMqKvatchCitadelHall01" or COW "MS13CheydinhalOblivionWorld" 1 -1)
    Oblivion\Architecture\Citadel\Interior\CitadelHall\CitadelHallDoor01Anim.NIF (000182E8)

## Missing bone for animation

Call stack for creating Ogre::Controller

>	openmw.exe!NiBtOgre::NiControllerSequence::build() Line 419	C++
>	openmw.exe!NiBtOgre::NiModel::buildAnimation() Line 359	C++
>	openmw.exe!MWRender::ForeignNpcAnimation::addForeignAnimSource() Line 1474	C++

>	openmw.exe!NiBtOgre::NiMultiTargetTransformController::build() Line 518	C++
>	openmw.exe!NiBtOgre::NiControllerSequence::build() Line 299	C++
>	openmw.exe!NiBtOgre::NiControllerManager::build() Line 410	C++
>	openmw.exe!NiBtOgre::NiNode::build() Line 641	C++

FO3 Characters\_Male\Skeleton.nif

Bip01 L Forearm has 2 children:

  * `Bip01 L ForeTwist`
  * `Bip01 L Hand`

Forum notes from 18/02/19:

> I had created this to ask for help in technical forums (e.g. Ogre) as I was getting nowhere and getting desperate. But once I made the video I figured out the issue. I don't have a solution yet but at least I know why it happens. Basically some of the skinned meshes specify weighting against a bone that is not specified in the animation. The code does not create a controller for bones not mentioned in the animation file, so it probably goes to random places (or maybe the binding pose)

So, it must be the first call stack above that I need to investigate.  It might be this section of the code:

```cpp
else if (ctlrTypeName == "NiTransformController")
{
    if (mModel.blockType(interpolatorRef) != "NiTransformInterpolator" &&
        mModel.blockType(interpolatorRef) != "NiBSplineCompTransformInterpolator")
        throw std::runtime_error("unsupported interpolator: "+mModel.blockType(interpolatorRef));

    // NOTE: Some interpolators do not have any data!  Ignore these controlled blocks.
    NiInterpolator *interpolator;
    if (mModel.blockType(interpolatorRef) == "NiTransformInterpolator")
    {
        interpolator = mModel.getRef<NiTransformInterpolator>(interpolatorRef);
        if (0)//static_cast<NiTransformInterpolator*>(interpolator)->mDataIndex < 0) // -1
            continue;
    }
```

Well, that particular `continue;` never happens, but given the comments regarding interpolators without any data let's see further down the code.

Looks like we end up creating the controllers but later do nothing if there is no data.  See below (removed some stuff for clarity):

```cpp
void NiBtOgre::TransformController::Value::setValue (Ogre::Real time)
{
    const NiTransformInterpolator*
        transInterp = dynamic_cast<const NiTransformInterpolator*>(mInterpolator);

    if (transInterp)
    {
        Ogre::Quaternion nonaccumq;
        if(mTransformData && mTransformData->mQuaternionKeys.keys.size() > 0)
        {

```

Rather than doing nothing, we might be able to move the bone based on its parent and its local transform.

To confirm that we have the issues that were observed before, check with NifSkope - using `Characters\_Male\Skeleton.nif` and anim `Laugh.kf` loaded, we can see NiTransformInterpolators with the block indices 451 and 491 (updated after adding anim).  They are for the Controlled Blocks `Bip01 L ForeTwist` and `Bip01 R ForeTwist` as suspected.

After some experimentation it dawned on me that doing nothing means the bone keeps its relative position and orientation against its parent already.  So the issue must be something else.

## Missing symmetric texture coefficients

Some don't have any symmetric texture coefficients, e.g.:

    [ESM4::Npc] = {mFormId=0x0004ef6f mFlags=0x00040000 mEditorId="CheydinhalGuardCityPostNight03" ...}

## Strange warnings from OpenAL

    AL lib: (EE) `anonymous-namespace'::ALCwasapiPlayback_mixerProc: WaitForSingleObjectEx error: 0x102

# [11/03/2020] Citadel Hall door

Citadel hall door - both have the same `FormId` 0x000182e8

    left (18) 2092, 1280, 768
    ((std::_Tree_node<std::pair<int const ,std::pair<Ogre::Matrix4,btCollisionShape *> >,void *>*)0x000002b10cce3280)->_Myval.second.first.m[0x00000000],view(MapHelper) 0x000002b10cce32a8 {5.36441803e-07, 0.000000000, -0.999999881, 210.856628}
    rotation {w=1.00000000 x=0.000000000 y=0.000000000 ...}
    z = -1.72853493e-06

Two different world positions, same transform, but different rotations

    left (18) 1024, 1276, 768
    ((std::_Tree_node<std::pair<int const ,std::pair<Ogre::Matrix4,btCollisionShape *> >,void *>*)0x000001bf595c70c0)->_Myval.second.first.m[0x00000000],view(MapHelper) 0x000001bf595c70e8 {5.36441803e-07, 0.000000000, -0.999999881, 210.856628}
    rotation {w=1.10467010e-06 x=0.000000000 y=0.000000000 ...}
    z = 1.00000000

Using `adjustRigidBody()` for user index != 4 does not work, just moves the collsion shapes in the wrong place.  However, that allowed me to observe what is happening when the doors move.  It looks like for one of the doors the movement is in the opposite direction!

Using the target's local rotation (i.e. `rot`) as the binding orientation makes the citadel doors to work properly at `OblivionMqKvatchCitadelHall01` (`Oblivion\Architecture\Citadel\Interior\CitadelHall\CitadelHallDoor01Anim.NIF`) but breaks other rotating doors.

I think we need to look at somewhere else for the bug - possibly `processDoors()`.  Somehow we need to take into account of the world rotation.  Or maybe `PhysicsSystem::moveSubObject()`.

**FIXED:** it turned out to be an issue in `PhysicsSystem::moveSubObject()` indeed.  The local movement of the `Ogre::Bone` was not being properly converted to the movement of the collision shape because it was not taking into accout of the binding orientation of the collision shape.  This took a whole day.

**TODO:** There is still the issue of doors not remembering its open/closed state when leaving a cell then returning.

**TODO:** Also, if you look away quickly before the collision shape had not completed its movement, it can get stuck. (i.e. rendering and physics gets out of sync)  Need to ensure that the movement is completed somehow.

Door activation is rather complicated (simplified shown below to get an idea):

                            Interpreter  Foreign    Action                       Ogre::Animation
        Engine     World       Context     Door      Door    Animation    Ogre::Entity  State
          |          |           |          |         |        |              |          |
          |          |           |          |  ctor   |        |              |          |
          |          |         activateDoor |--+      |        |              |          |
          |          |<---------------------|  |      |        |              |          |
          |      mDoorStates[]   |          |<-+      |        |              |          |
          |          |           |          |         |        |              |          |
          :          :           :          :         :        :              :          :
          :          :           :          :         :        :              :          :
        ->| activate |           |          |         |        |              |          |
          |--------->| activate  |          |         |        |              |          |
          |          |---------->| activate |         |        |              |          |
          |          |           |--------->|         |        |              |          |
          |          |           |          | new     |        |              |          |
          |          |           |          |-------->|        |              |          |
          |          | executeActivation    |         |        |              |          |
          |          |---------->|          |         |        |              |          |
          |          |           | activate |         |        |              |          |
          |          |           |------------------->|        |              |          |
          |          |           |       activateDoor |        |              |          |
          |          |<-------------------------------|        |              |          |
          |          | hasAnimation("Open") |         |        |              |          |
          |          |---------------------------------------->|              |          |
          |          |           |          |         true     |              |          |
          |          |<--------------------------------------->|              |          |
          |          | activateAnimatedDoor |         |        |              |          |
          |          |---------------------------------------->|              |          |
          |          |           |          |         |        |              |          |
          |          |           |  mSkeletonAnimEntities      |              |          |
          |          |           |          |<-----------------|              |          |
          |          |           |          | Ogre::Entity     |              |          |
          |          |           |          |----------------->|              |          |
          |          |           |          |         |        | getAnimationState       |
          |          |           |          |         |        |------------->|          |
          |          |           |          |         |        |AnimationState|          |
          |          |           |          |         |        |<-------------|          |
          |          |           |          |         |        | setEnabled   |          |
          |          |           |          |         |        |------------------------>|
          |          |           |          |         |        |              |          |


The actual movement of collision shapes, again simplified:

        World               Animation   PhysicsSystem    PhysicEngine   RigidBody
          |                     |             |               |            |
          | update              |             |               |            |
          |  doPhysics          |             |               |            |
          |   processDoors      |             |               |            |
          |-------+             |             |               |            |
          |   mDoorStates[]     |             |               |            |
          |       |             |             |               |            |
          |       | hasAnimation("Open")      |               |            |
          |       |------------>|             |               |            |
          |       |        true |             |               |            |
          |       |<------------|             |               |            |
          |       | addTime     |             |               |            |
          |       |------------>|             |               |            |
          |       |             |             |               |            |
          |       |  rotateSubObject          |               |            |
          |       |-------------------------->| getRigidBody  |            |
          |       |             |             |-------------->|            |
          |       |             |             |    RigidBody* |            |
          |       |             |             |<--------------|            |
          |       |             |             | setRotation   |            |
          |       |             |             |--------------------------->|
          |       |  moveSubObject            |               |            |
          |       |-------------------------->| setOrigin     |            |
          |<------+             |             |--------------------------->|
          |                     |             |               |            |


# [12/03/2020] Materials

Some models require external texture to be supplied while others (e.g. head models) require the material to be crafted and supplied.

Actual selection of the material for a sub-mesh is done by `NiTriBasedGeom::getMaterial()`.  Each sub-mesh has its own material, but for head parts and body parts there's only one mesh and texture. So we can create a member to indicate that `NiTriBasedGeom` has an external texture/material and `getMaterial()` can use them if they exist.

## Complications with clothes

Some clothes (and maybe armor as well?) that show exposed skin.  The textures for these sub-meshes will need to be changed with those specified in the RACE records.

Another issue is that we need a unique name for the material if we used a different external texture, since the same model could be used for a number of different races.

On top of that those external textures, such as for a human Upper Body, could be morphed based on the `RACE` and `NPC_` coefficients.

## More bugs

Just noticed that Baurus stopped wearing his armor from around 06/03/20. **FIXED:** Blades armor have zero value - had to compare Armor Rating before comparing value.  **NOTE:** For now weapon ratings (e.g. damage) are ignored.

# [15/03/2020] Bugs, bugs, bugs

## NPC face detail texture missing

    mNpc = 0x000001d69794ace0 {mFormId=0x0001a117 mFlags=0x00040400 mEditorId="SEBelmyneDreleth" ...}
    mFormId = 0x0001a117

    mEditorId = "SESfara"
    mFormId = 0x0001a116

    mEditorId = "SE01GaiusPrentus"
    mFormId = 0x000133be

## No collision shapes for NPC and Creature skeletons

    void PhysicsSystem::addActor (const Ptr& ptr, const std::string& mesh)
    void PhysicEngine::addCharacter(const std::string &name, const std::string &mesh,

At the moment nothing is creating `OEngine::Physic::ForeignActor`.

Defer working on this until we have better performance.

# [16/03/2020] Spider Daedra

## Bone positions

Comparing the two, the rotations look ok.

### Bip01 L UpperArm

NifSkope

    MultiTargetTransformController::updateTime: Bip01 L UpperArm, time 0.0410088
    rotation before 0.688776,0.426225,0.518234,-0.272996
    rotation after 0.688401,0.426182,0.518556,-0.27351
    MultiTargetTransformController::updateTime: Bip01 L UpperArm, time 3.03465
    rotation before 0.717999,0.364717,0.539053,-0.245285
    rotation after 0.718049,0.363883,0.539909,-0.244403

OpenMW

    time 0.04
    rotation before 0.688624,0.426435,0.518775,-0.273537
    rotation after 0.688397,0.426191,0.518558,-0.273502
    time 3.03299
    rotation before 0.717472,0.365636,0.539447,-0.246051
    rotation after 0.718025,0.363927,0.53989,-0.244446

### Bip01 L Forearm

NifSkope

    time 3.032998561859131
    0.765064,-1.31466e-08,-1.56515e-08,-0.643555
    0.765085,-1.33251e-08,-1.69428e-08,-0.64353

OpenMW

    time 3.03699
    0.764884,-1.32995e-08,-1.66789e-08,-0.644169
    0.764893,-1.33795e-08,-1.72582e-08,-0.644157

Added some objects to the bones to visualise where things were going wrong and surprise, surprise - the bones are in the right place after all.  It looks like the skin weighting issue.

Looking at the code in `NiTriBasedGeom::buildSubMesh` the bone offset transform for skinned meshes are being ignored.  Tried using the implementation in TES3 but for some reason the renders are corrupted.

Use `Gdiff c5840fe5f7d76ae0a049913bfe9724353a875ae9` for comparison.

# [17/03/2020] Skins

Looked into adding bones to simulate the "offset", but that would potentially result in far too many bones being added.  For now, go back to investigating if the vertices of the sub-meshes can be offset instead.

# [18/03/2020] Skins cont.

## Modifying skin vertices

Examinining `Clothes\LowerClass\05\M\Pants.NIF`:

There are two sub-meshes, the leg skin (01) and the pants (15), both children of `Scene Root`.  Confusingly, they are both named 'LowerBody'.  The corresponding transforms:

    index                    | 01                             | 15
    -------------------------|--------------------------------|---------------------------------
    material property        | skin                           | pants
    parent index             | 0                              | 0
    parent transform         | Identity                       | Identity
    local transform          | Identity                       | translation only (0.039, -0.937, 44.528)
    skin transform           | Identity                       | translation only (-0.039, -.937, -44.528)
    bones                    | 10, 11, 12, 13, 14             | 10, 12, 26, 13, 14, 27, 28
    bone 10 tm in NiSkinData | rotation and translation       | rotation and translation
       translation           | 33.087, 6.049, 7.273           | -10.755, -1.758, 6.552
    bone 10 local transform  | rotation and translation       | (same)
       translation           | -6.699, -0.664, 34.001         | (same)
    bone 10 world tm *       | -0.00001,-0.000002,0.253017    | 0.0393686,-0.937018,44.7806
    bone 10 tm in NiSkinData | (almost the same as parent tm  | (almost the same as parent tm * local tm)
                             |  * local tm)                   |
    as above but using skel  | 0, 0.000016, 0.0000038         | 0.039, -0.937, 44.528
    bone 10                  | (better than using model bone) | (better than using model bone)

The challenge is to figure out how the per-bone offest transformations will change the affected vertices and normals.

Bone at index 10 is `Bip01 L Calf`.  Its offset transform for each of the two sub-meshes are different!  This means the idea of adding bones will mean even more bones than originally anticipated (i.e. even more impractical).

So, we can get the new "effective position" for the bone using the per-bone Skin Transform in `NiSkinData` - but how do we now modify the vertices?

## Adding bones

Tried adding extra bones - but it is very difficult to do it.  By the time the skin NiModel is created the skeleton is already loaded - to try to modify it the whole process has to start again.  It is also impractical to scan the possible additional bones required since there can be so many, e.g. shirts, pants.  Maybe if we restrict it to some known problematic creatures?  I would be rather reluctant to hard-code that.

# [19/03/2020] Skins cont.

## Modifying Ogre

Had a quick look at modifying Ogre to do extra transform at the point of Software Vertex Blend - but that code is optimised and it won't be easy to modify that.

## Modifying bone transform

Trying yet another idea - this time to add the addtional transform to the affected bones themselves.  This means anything else that requires the bone's original (i.e. correct) transform will need to take that into account.

The trouble with modifying bone translations and orientations is that they have parent/child relationships.  i.e. modifying one bone may affect many other bones.

# [20/03/2020] FaceGen emotions and lip synch

Rough outline of the code (pseudocode):

```cpp
    // need an animation for each emotion, and make the length configurable?
    animation = mesh->createAnimation(animationId, totalAnimLength);
    Ogre::VertexAnimationTrack* track = animation->createVertexTrack(subMeshIndex+1, Ogre::VAT_POSE);

    // with only 2 in the loop we can unroll
    for (unsigned int i = 0; i < 2; ++i) // we only have "Base" and the pose, e.g. "Happy"
    {
        Ogre::Pose* pose = mesh->createPose(subMeshIndex + 1, poseName);

        for (std::size_t v = 0; v < vertices.size(); ++v) // vertices in headhuman.nif, etc
            pose->addVertex(v, vertices[v]);

        // with only 2 in the loop we can unroll
        for (std::size_t k = 0; k < 2; ++k) // only 2 keyframes for us? (start and end)
        {
            // see the comments on animation length above
            Ogre::VertexPoseKeyFrame* keyframe = track->createVertexPoseKeyFrame(morphKeys->at(k).time);
            // influence value may require some experiments - maybe for lip sync go up to 1 but for others less?
            keyframe->addPoseReference(poseIndex + i, morphKeys->at(k).value);
        }
    }
```

# [23/03/2020] Vertex Pose animation

For some reason mouth, teeth and tongue has to have the x and z parts of the vertex delta swapped.  Probably something to do with the head rotation issue.

# [24/03/2020] Pathgrid and AI Package

The console command is TPG.  In TES4 there are blue and red variants.  It seems like the blue ones have higher priority.  There's probably some flag setting for it.

According to [an online article](https://www.tamriel-rebuilt.org/content/tutorial-pathgridding-tutorial) red ones mean "autogenerated" in TES3 while the blue ones are "custom".  For TES4, blue ones indicate "best path".

Looking at the flags, though, they range from 0x01 to 0x09.  The most frequent one is 0x05 (0b0101). Frequency distribution at ImperialDungeon01:

  flag | frequency
  -----|----------
   1   |  4
   2   | 50
   3   | 42
   4   | 37
   5   | 99
   6   | 24
   7   | 19
   8   |  7
   9   |  2


**TODO:** But from the CS I can only see one blue node?

Pathgrids are in "Cell Temporary Child" group and loaded from `CellStore::loadTes4Record()`.  **NOTE:** they are not loaded from `ESMStore::loadTes4Record()` because the cells are preloaded and only the persistent records are (partially) loaded from `ESMStore`.

## Side note on performance and dummy cell

Loading the dummy cell in `Scene::changeWorldCellGrid()` results in a huge performance hit.  But without that `ForeignDoor::activate()` won't work - I think all the doors are in the dummy cell.  We will need to figure out how to selectively insert doors based on their location.

I think calling `insertCell()` in `Scene::loadForeignCell()` results in everything in the dummy cell to be inserted into the scene.  We will need a new method.

But first, why does the dummy cell have that many references, anyway? (at least for Tamriel, 0x0000003c)

For some insight into the sequence of the loading, see `persistent-child-preload.log` which was created with some extra loggin on commit 3c411e8a1276e173484455617d13b1760d84f27b.

# [25/03/2020] Animation groups

`MWRender::Animation::play()` uses the concept of "animation group".  `MWRender::Animation::runAnimation()` is called from `CharacterController::update()` and ctor.  It runs animations in mStates and any controllers in mObjectRoot.

`mStates` contains `Ogre::SharedPtr<AnimSource>` and start time, etc.  It is populated by `play()` and keyed by the animation `groupname`.  It is selected from `AnimSourceList` based on the textKeys matching the `groupname`.  The `groupname` is a parameter in play() - despite what the name suggests, it is really just the animation name, e.g. "Idle". (in TES3 `AIWander` they are "idle2", "idle3", etc)

Most likely we will have to create TES4 versions of these methods since the way animations are implemented are different.

Note that in TES4 NiBSBoneLODController has NodeGroups that might be analogous to the "animation groups" in TES3.  However it is not immediately clear how they are meant to be used.

## Quick note on object lifecycle

  * Most use `Ogre::SharedPtr` which provides implicit destruction.
  * The `vertexData` created using `new` for `Ogre::SubMesh` is owned by `Ogre::SubMesh` and its dtor will delete it.
  * The shapes created by "bhk" methods are owned by `BtOgre::RigidBody` but PhysicEngine manages the deletion of the shapes.
  * There are some uses of `unique_ptr` and `boost::scoped_array` but they should be ok already.

# [26/03/2020] Animation cont.

Noticed that TES4 skeleton has 6 node groups while TES5 has 8.

```cpp
Ogre::Node *Animation::mAccumRoot;
Ogre::Node *Animation::mNonAccumRoot;
NifOgre::NodeTargetValue<Ogre::Real> *Animation::mNonAccumCtrl;
Ogre::Vector3 Animation::mAccumulate;
```

  * `mAccumRoot` is used for actually moving the skeleton. (probably Bip01)
  * `mNonAccumRoot` (probably Bip01 NonAccum)
  * `mNonAccumCtrl` is the controller for `mNonAccumRoot` and probably used for calculating the skeleton's position.  This is set by `Animation::resetActiveGroups()`.
  * `mAccumulate` is set by `CharacterController`, probably a movement request.

Subset of TES4 skeleton (Shivering Isle) hierarchy, kinda inverted:

                      0 Scene Root
                           |
                        3 Bip01         (UPB: BoneRoot)
                           |
                    8 Bip01 NonAccum
                           |
                    14 Bip01 Pelvis
                    /      |      \
                   /       |       \
                  /  18 Bip01 Spine \
                 /         |         \
        330 Bip01 R Thigh  |    299 Bip01 L Thigh
                |          |          |
                     27 Bip01 Spine1


# [26/03/2020] Back to Pathgrid

In TES3 Pathgrid records are loaded  in `ESMStore::load()` then the connected graph created in `CellStore::load()`.

In TES4 we can't take the same approach since we skip "Cell Temporary Child" group while in `ESMStore::loadTes4Record()`.

To draw the points and links, will need to add a method similar to `Debugging::enableCellPathgrid()`.  We need to either modify it or create a different method since `LAND_SIZE`, etc, will be different for TES4.  It also uses ESMStore to find the pathgrids which won't be the case for TES4.

# [27/03/2020] Pathgrid still

The PGRR record turned out to be similar to TES3, i.e. they are indices for the "end node" for number of links specified for each pathgrid point.

`ICMarketDistrictTheBestDefenseBasement` doesn't have a PGRR.  Maybe some links need to be auto-generated?  We may need a dummy physics shape so that a line-of sight test can be done.

    CELL FormId 00049E2A
    PGRD FormId 000304B7

**FIXME:** Noticed that some pathgrid points are floating in the air - again, a dummy physics shape can be used to "snap" to ground.

We also need a way to find paths to adjacent cells as well as far away destinations.  And we still don't know which nodes are the blue "priority" ones. **FIXED:** turns out that odd values in z poition indicates "priority".

# [29/03/2020 - 30/03/2020] LOD

From [a short description on TES5 LOD](https://en.uesp.net/wiki/Tes5Mod:LOD_Settings_File_Format):

    struct {
      signed short left;
      signed short top;
      signed int stride_pow2;
      signed int lowestsize_lod;
      signed int highestsize_lod;
    } lodsetting;

## `.lod` and `.cmp` files

xxd `icmarketdistrict_7_16.lod` which is from TES4:

    00000000: 0100 0000 7c0b 0000 0300 0000 00d0 fd46  ....|..........F
    00000010: 004b 8447 85af 6045 00fa ee46 002a 8747  .K.G..`E...F.*.G
    00000020: 85bf 6045 0060 ec46 804c 8747 85df 6045  ..`E.`.F.L.G..`E
    00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000050: 0000 0000 a4f0 b542 a4f0 e542 a4f0 c142  .......B...B...B

So, if I use long instead of short we get what appears to be some point vectors?

    0x0001 (32bit int)  // no of REFR? (**NOTE: 30/03/20** these are # of sections)
    0x0b7c (32bit int)  // if this is a REFR baseObj, then tree\TreeEnglishOakYoungSU.spt
    0x0003 (32bit int)  // qty = 3? (**NOTE: 30/03/20** these are # of obj in this section)

    32488, 67734, 3594.97 // there is an entry of the tree in CELL #7, 16
    30589, 69204, 3595.97 // there is an entry of the tree in CELL #7, 16
    30256, 69273, 3597.97 // there is an entry of the tree in CELL #7, 16
    0, 0, 0               // rotation
    0, 0, 0               // rotation
    0, 0, 0               // rotation
    90.97, 114.97, 96.97  // scale for each

And `icmarketdistrict_8_16.lod` has below.

    0x0001 (32bit int)    // 1 REFR (**NOTE: 30/03/20** 1 section)
    0x0b7c (32bit int)    // base Object ID
    0x0001 (32bit int)    // qty

    32985, 67787, 3597.97 // there is an entry of the tree in CELL #8, 16
    0, 0, 0               // rotation
    96.97                 // scale

There are indeed 4 trees (2 near BeggarICMarketsSimplicia and 2 near the entry into the sewers).  The `.cmp` file probably indicates the distance to these REFR?  icmarketdistrict.cmp has:

    00000000: 0700 0000                                ....

However anvilworld.cmp has:

    00000000: f7ff d2ff f9ff d2ff f7ff d3ff f8ff d3ff  ................
    00000010: f9ff d3ff f8ff cfff f8ff d0ff f9ff d0ff  ................
    00000020: f7ff d1ff f8ff d1ff f9ff d1ff 0700 0000  ................

So these look like `std::int16_t` CELL co-ordinates.  But these look back to front?  -45, -8, for example, is AnvilExteriorA.  But then 0, 7 does not make sense.  There is no CELL in AnvilWorld with such co-ordinates.  In Tamriel, 0, 7 is VindaselExterior which is too far from Anvil.

                -9  -46   -7  -46   -9  -45   -8  -45
                -7  -45   -8  -49   -8  -48   -7  -48
                -9  -47   -8  -47   -7  -47    7    0

Let's look at another one from Bravil.  We have 15, -8 and 0, 7.  The CELL 15, -8 is just outside one of the walls in Bravil and it doesn't contain the tall cathedral, either.

    00000000: f8ff 0f00 0700 0000                      ........

`bravilworld_15_-8.lod` refers to a couple of trees and a static 0x000018FF CastleWall01 (`Architecture\Castle\CastleWall01.NIF`)

**TODO:** So, what are we meant to do when we encounter these trees or static objects?  What's in the `.lod` files are clear enough, but what do the cell co-oridnates in the `.cmp` files mean?

## LOD NIF files

Maybe some clue from the file names?  Is there a LAND or CELL with `FormId` 0x00113463? (Not according to OpenCS)  The NIF files are just NiTriStrips with NiTriStripsData without any materials info.  However there are corresponding textures, so maybe they are meant to be manually put together?

    meshes\landscape\lod\113463.00.00.32.nif
    meshes\landscape\lod\113463.00.-32.32.nif
    meshes\landscape\lod\113463.-32.00.32.nif
    meshes\landscape\lod\113463.-32.-32.32.nif

So, the texture 60.00.00.32.dds matches what OpenCS shows on cells 0,0 (bottom left), 0,31 (top left), 31,31 (top right), and 31,0 (bottom right).  Similarly, -31,0 (bottom left), -31,31 (top left), 0,31 (top right), and 0,0 (bottom right) matches 60.-32.00.32.dds.  So the file names must be (except that some have 00 left and -32 right?):

    <world id in decimal>.<grid x left>.<grid x right>.<y grid height>

These are the ones in `meshes\landscape\lod` directory (Oblivion.esm), note that not all worlds have LOD mesh(s):

  prefix | FormId     | World EditorId | World FullName
  -------|------------|----------------|---------------
  60     | 0x0000003c | Tamriel        |
  113463 | 0x0001bb37 | MS14World      | The Painted World
  118972 | 0x0001d0bc | OblivionMQKvatch | Plane of Oblivion
  154411 | 0x00025b2b | MS37World      | Frostfire Glade
  181496 | 0x0002c4f8 | MS13CheydinhalOblivionWorld | Realm of Oblivion
  181732 | 0x0002c5e4 | OblivionRD004  | Wastes of Oblivion
  248431 | 0x0003ca6f | DAPeryiteRealm | Realm of Peryite
  255242 | 0x0003e50a | OblivionRD001  | Wastes of Oblivion
  259409 | 0x0003f551 | OblivionRD002  | Wastes of Oblivion
  305567 | 0x0004a99f | OblivionRD003  | Wastes of Oblivion
  326381 | 0x0004faed | OblivionRD005  | Wastes of Oblivion
  336426 | 0x0005222a | OblivionRD006  | Wastes of Oblivion
  346632 | 0x00054a08 | MQ10BrumaOblivionGate | Plane of Oblivion
  545529 | 0x000852f9 | PalePassWorld  | Pale Pass
  629781 | 0x00099c15 | OblivionRD007  | Wastes of Oblivion
  97393  | 0x00017c71 | CamoranParadise | Camoran's Paradise

It's interesting that decimal is used here while hex is used for FaceGen - must have been a programmer preference or something. There are other entries in meshes\architecture directory:

    bravil\bravilhouselod.nif
    bravil\bravilhouselod_far.nif
    bruma\brumahouselod.nif
    bruma\brumahouselod_far.nif
    cheydinhal\cheydinhalhouselod.nif
    cheydinhal\cheydinhalhouselod_far.nif
    chorrol\chorrollodhouse01.nif            // why different naming convention?
    chorrol\chorrollodhouselod01_far.nif
    skingrad\skhouselower01lod.nif           // why yet another different naming convention?
    skingrad\skhouselower01lod_far.nif

Now the files in distantlod directory make sense a little.  They might be an indicator to use an LOD mesh, depending on which cell the character is in.

## Viewing Distance defaults

    [Viewing distance]
    fog end factor = 1.0
    fog start factor = 0.5
    limit small object distance = false
    max viewing distance = 5600
    small object distance = 3500
    small object size = 250
    viewing distance = 4600

## Oblivion Gates

The Oblivion gates are visible from distance (at least it feels that way) so let's check the records.  There seems to be many different types, one of which is door with `FormId` 0x00051925.  The first REFR with the `mBaseObj` that matches is:

    FormId   0x00091ca2
    Flags    0x00000400 (persistent reference) // note that it doesn't have disable initially
    DestDoor 0x00000000 // no destination FormId, must be controlled by a script on the base object
    BaseObj  0x00051925 Oblivion\Gate\OblivionArchGate01.NIF

# [31/03/2020] LOD cont.

Looking at the `.cmp` file again.  `tamriel.cmp` has 153 co-ordinates plus 0,7.  But there are 9347 tamriel `.lod` files.

Maybe these are reference points for the generation of the LOD mesh and textures? **EDIT: 05/04/20** The `.cmp` files have grids where visibly distant statics are located and the `.lod` files have the base object `FormId` and position/orientation/scale of the visibly distant statics and trees.

# [31/03/2020 - 02/04/2020] Visible when distant

## Initial attempt

We probably need to load these records, along with persistent records, for each world space.  But do we do that at the beginning or when we enter a world for the first time?

Either way, we need a special case of CellStore that holds these records (and change only when the worldspace changes).

        ESMStore         Store<ForeignCell> ForeignCell  ESM4::Cell
           |                     |             |            |
           | loadTes4Group()     |             |            |
           |--+                  |             |            |
           |  | loadTes4Record() |             |            |
           |  |--+               |             |            |
           |  |  | CELL          |             |            |
           |  |  | preload()     |             |            |
           |  |  |-------------->| new         |            |
           |  |<-+               |------------>|            |
           |  |                  | preload()   |            |
           |<-+                  |------------>| new        |
           |                     |             |----------->|
           |                     |             | preload()  |
           |                     |             |----------->|
           |                     |             |            |
           |                     |[if Grp_WorldChild]       |
           |                     | setDummyCell()           |
           |                     |------------>|            |
           |                     |             |            |


**TODO:** `getForeignWorld()` should be changed to `getWorldCell()` **DONE**

        Scene       MWWorld::World   MWWorld::Cells     ESMStore  CellStore
          |                |              |               |          |
          | changeWorldCellGrid()         |               |          |
          |--+             |              |               |          |
          |  |             |              |               |          |
          |  |             | getWorldCell()               |          |
          |  |------------>|------------->|               |          |
          |  |             |              | find()        |          |
          |  |             |              |-------------->|          |
          |  |             |              | ForeignWorld* |          |
          |  |             |              |<--------------|          |
          |  |             |              | find()        |          |
          |  |             |              |-------------->|          |
          |  |             |              | ForeignCell*  |          |
          |  |             |              |<--------------|          |
          |  |             |              | ctor          |          |
          |  |             |              |------------------------->|
          |  |             |              |<-------------------------|
          |  |             |              | load()        |          |
          |  |             |              |------------------------->| loadForeignRefs()
          |  |             |              |               |          |--+
          |  |             |              |               |          |  | loadTes4Group()
          |  |             |              |               |          |  |--+
          |  |             |              |               |          |  |  | loadTes4Record()
          |  |             |              |               |          |  |<-+
          |  |             |              |               |          |  |
          |  |             |              |               |          |<-+
          |  |             | CellStore*   |<-------------------------|
          |  |<------------|<-------------|               |          |
          |  |             |              |               |          |
          |  | loadForeignCell()          |               |          |
          |  |--+          |              |               |          |
          |  |  | insertCell()            |               |          |
          |  |  |--+       |              |               |          |
          |  |  |  |       |              |               |          |


The loading of the REFR, ACHR and ACRE occurs in `CellStore::loadTes4Record()` and the creation of the rendering and physics shapes are initiated from `Scene::insertCell()`.

`MWWorld::Cells` stores `ForeignCell`s and it's probably the best place to keep a dummy cell for visibly distant REFRs.

There are a couple of options on where to load the records - either initiate the call from `ESMStore` (when first scanning the ESM/ESPs or from Cells (when a new world is accessed for the first time).  I suspect that the former is going to be simpler, since it will have all the base and mods being scanned.  With the latter approach, WRLD context needs to be saved so that we can go back and scan all the CELLs that belong in the world, also all the mods that modifies the CELLS, REFRs, etc.  The only trouble with the former approach is the lack of access to `MWWorld::Cells`.  We may need to add a method to `WorldImp`.

## Redesign needed

Having one cell to hold all the visibly distant REFR won't work.  In Tamriel there are way too many trees.  The performance becomes worse than a slide-show.  There must be some alogorithm in vanilla to decide which ones to load, similar to cells - however it must be more than the number of cells being loaded?  Otherwise why bother grouping them as "visibly distant"?

Just outside Vilverin approx 1.2M triangles with exterior grid size of 3 - single digit FPS sometimes going down to 0.

**TODO:** Not very happy with having to add methods in MBase::World.  Need to look for alternatives.
**TODO:** Not happy with ForeignWorld storing dummy cell `FormId` but visibly distant `CellStore` (inconsistent).  We just need to ensure that it is created when the world is first accessed.  However, if we were to load *all* the REFRs for the WRLD, which may have many CELLs, we had to load them in ESMStore and at that point nothing would be accessing any worlds.

**FIXME:** Sometimes Morrowind cells get loaded?  I think this might be due to OpenMW using `getExterior(x, y)` which can confuse things.  We may need to keep the current world somewhere (player?) and change only when explicigly changing worlds.

**TODO:** WRLD has a flag "no LOD water"

## Revisit `.lod` and `.cmp` files

Examining the out put of `xxd distantlod\oblivionmqkvatch.cmp`:

    00000000: 0300 ffff 0400 ffff 0300 0000 0000 0100  ................
    00000010: 0100 feff 0700 0000                      ........

Each of the co-ordinates in the `.cmp` file has statics in visibly distant cell child group:

     Grid | CELL FormId | REFR FormId | BaseObj FormId | BaseObj EditorId
    ------|-------------|-------------|----------------|------------------------------
    -1, 3 | 00021079    | 00034264    | 000314D2       | CitadelTowerSmall02
          |             | 000221FA    | 0003487B       | CitadelTowerBridgeLong01
    -1, 4 | 00021078    | 0002209E    | 000314CF       | CitadelTowerSmall01
     0, 3 | 00021072    | 00034263    | 000314CF       | CitadelTowerSmall01
          |             | 000221F9    | 0000A010       | CitadelTowerBridgeExtraLong01
          |             | 0002109D    | 0002D3E9       | CitadelTowerCenterPiece
     1, 0 | 0002106D    | 0002209F    | 000314D2       | CitadelTowerSmall02
    -2, 1 | 00021084    | 000221B3    | 000314CF       | CitadelTowerSmall01

OblivionMQKvatch has 5 `.lod` files, which correspond to above (I wonder if they all match like that?).

    oblivionmqkvatch_0_3.lod
    oblivionmqkvatch_1_0.lod
    oblivionmqkvatch_-1_3.lod
    oblivionmqkvatch_-1_4.lod
    oblivionmqkvatch_-2_1.lod

Examining `distantlod\oblivionmqkvatch_0_3.lod`:

    000314CF qty 1, pos 45720000, 464b6000, 45905fc3, rot 00000000, 80000000, 3f48efba, scale 42c9f0a4
    0002D3E9 qty 1, pos ...
    0000A010 qty 1, pos ...

So, these might be look-ups to quickly locate the visibly distant statics and their grid locations.  **Or, maybe they provide enough details so that the ESM/ESP files don't have to be scanned at all.**

Still, the question is when to load them, i.e. all the time when in the OblivionMQKvatch world or only when in certain cells?

Well, all that work to create the VisibleDistCell has been for nothing!  Maybe it can be salvaged (swapped out when the "real" one gets loaded?).

Each of the objects have a `_far` variant in the same directory:

    meshes\oblivion\architecture\citadel\exterior\maintowers\towercenterpiece_far.nif
    meshes\oblivion\architecture\citadel\exterior\subtowers\towersmall01_far.nif
    meshes\oblivion\architecture\citadel\exterior\subtowers\towersmall02_far.nif
    meshes\oblivion\architecture\citadel\exterior\walkways\towerbridgelong01_far.nif
    meshes\oblivion\architecture\citadel\exterior\walkways\towerbridgeextralong01_far.nif

## Tamriel `.lod` (from 05/04/20)

Grid 0,0 is not in `tamriel.cmp` and only has trees

    distantlod\tamriel_0_0.lod
    000232D8 \TreeWhitePineForest01.spt
    000237EE \TreeWillowOakForest01SU.spt
    0000089B \TreeSugarMapleForestSU.spt
    000232D9 \TreeSilverBirchForest01SU.spt
    00000B7D \TreeWhitePineForest.spt
    000009FE \TreeSilverBirchForestSU.spt

Grid 0,7 is in `tamriel.cmp`- but still only has trees.  But maybe a poor choice of grid since it is the "back marker".  Also the numbering maybe Y, X?

    distantlod\tamriel_0_7.lod
    00017F9E \TreeGreyPoplarForestSU.spt
    00000BC6 \TreeWillowOakFreeSU.spt
    00017F98 \TreeYewForest.spt

Grid -18, 1 is in `Tamriel.cmp`, but still no static.

    distantlod\tamriel_1_-18.lod
    00000BC6 \TreeWillowOakFreeSU.spt

Try again and bingo!  **So it appears that the `.cmp` files have grids that have visible distant statics.** Also the filename structure is `<EditorId>_<grid x>_<grid y>.lod`.

    distantlod\tamriel_-18_1.lod
    000232DB \ShrubVineMapleSU.spt
    00000BC9 \TreeWillowOakYoungSU.spt
    00009EFE Architecture\Skingrad\SkHouseLower01LOD.NIF SkHouseLower01LOD
    00000B7C \TreeEnglishOakYoungSU.spt
    00028773 Architecture\Skingrad\SkingradCastleWall01.NIF SkingradCastleWall01
    00035C32 Architecture\Castle\Skingrad\SkCastleWallGate01.NIF SkCastleWallGate01
    000232D6 \TreeEnglishOakForest01SU.spt
    000019DA \TreeSugarMapleFreeSU.spt
    000286CF Architecture\Skingrad\SkinGradCastleTower01.NIF SkinGradCastleTower01

## `Oblivion.ini`

We will need a lightweight class (in comparison to Ptr) to represent LOD trees.  The vanilla implementation renders *a lot* of trees.  Maybe a 2D tree using billboard effect?

    [General]
    uGridDistantTreeRange=15
    uGridDistantCount=25
    uGridsToLoad=5
    uGridDistantTreeRangeCity=4
    uGridDistantCountCity=4

    [LOD]
    fLodDistance=500.0000
    bUseFaceGenLOD=0
    iLODTextureTiling=2
    iLODTextureSizePow2=8
    fLODNormalTextureBlend=0.5000
    bDisplayLODLand=1
    bDisplayLODBuildings=1
    bDisplayLODTrees=1
    bLODPopTrees=0
    bLODPopActors=0
    bLODPopItems=0
    bLODPopObjects=0
    fLODFadeOutMultActors=5.0000
    fLODFadeOutMultItems=2.0000
    fLODFadeOutMultObjects=5.0000
    fLODMultLandscape=1.0000
    fLODMultTrees=1.3000
    fLODMultActors=7.0000
    fLODMultItems=7.0000
    fLODMultObjects=7.0000
    iFadeNodeMinNearDistance=400
    fLODFadeOutPercent=0.9000
    fLODBoundRadiusMult=3.0000
    fTalkingDistance=2000.0000

    fTreeLODMax=2.0000
    fTreeLODMin=0.0200
    fTreeLODDefault=1.2000
    fObjectLODMax=15.0000
    fObjectLODMin=1.0000
    fObjectLODDefault=5.0000
    fItemLODMax=15.0000
    fItemLODMin=1.0000
    fItemLODDefault=2.0000
    fActorLODMax=15.0000
    fActorLODMin=2.0000
    fActorLODDefault=5.0000
    bLODUseCombinedLandNormalMaps=1
    bForceHideLODLand=0
    fLODQuadMinLoadDistance=65536.0000
    fLODFadeOutActorMultInterior=1.0000
    fLODFadeOutItemMultInterior=1.0000
    fLODFadeOutObjectMultInterior=1.0000
    fLODFadeOutActorMultCity=1.0000
    fLODFadeOutItemMultCity=1.0000
    fLODFadeOutObjectMultCity=1.0000
    fLODFadeOutActorMultComplex=1.0000
    fLODFadeOutItemMultComplex=1.0000
    fLODFadeOutObjectMultComplex=1.0000
    fLODLandVerticalBias=0.0000

## LOD strategy outline

  * Load the ESM/ESP files but don't load any references.
  * Scan the `meshes\landscape\lod` directory and build a map of low-poly land meshes for the worlds that has them.  They seem to be (mostly) in 32 x 32 cells in size.  There are some odd ones in Tamriel - they might be larger ones.
  * Scan the `distantlod` directory and build a map of visibly distant objects (statics and trees, not sure if there is anything else).  The `.cmp` file has the list of the cell grid positions for the world.  The `.lod` files have the details of the objects, enough to make a REFR, for the cells.  There should be a `_far` variant of these objects.
  * The number of cells loaded for visible distant child groups are larger than the cells with everything loaded. When the REFR from the visibly distant child groups are loaded, they should replace the low-poly versions.
  * When a player enters a world cell grid(x, y), cells around that grid needs to be loaded (but not using `Scene::insertCell()`).  A larger group for visibly distant and a smaller group for everything.
  * **TODO:** Not so sure how to treat the REFR in the dummy cell, especially the doors. i.e. how to decide when to render it?

The low-poly land meshes only have `NiTriStrips` and `NiTriStripsData` blocks.  In order to use the existing codebase, a dummy `NiNode` will need to be inserted at the root.

# [04/04/2020] LOD cont.

## Parent World

Worlds such as ICMarketDistrict seems to require the parent world's LAND.  It also needs the parent world's visibly distant REFR such as the White-Gold Tower (possibly the low-poly version).

**TODO:** `Cells::getWorldCell()` needs to change as it is auto-loading any new `CellStore` and also calling `initWorld()`.  This results in unnecessarily loading parent world's dummy cell when just the land and visibly distant statics may be required.  See the interaction diagram circa [31/03/2020 - 02/04/2020].

## When to parse and load the `.lod` and `.cmp` files

Basically 2 options here:

  * parse for all worlds when the game loads
  * parse for each world

The first implementation will parse and create the lookup maps for all at the beginning but load the visibly distant REFR separately for each world.

## Dummy Cell and partial insert

OpenMW doesn't have a concept of having references that are not rendered and without physics.  In order to be able to switch from visibly distant objects to "real" objects, we'll need some way of implementing this.

## `tamriel.cmp` and the grid positions

There are 153 grid positions in `tamriel.cmp`, excluding (0,7) at the end.  But there are 9347 `.lod` files.  This is different to `oblivionmqkvatch.cmp` where the number of grid positions and the number of `.lod` files were the same.

**EDIT: 05/04/20** The `.cmp` file only has grids where visibly distant statics are located.

## Observations on loading times

For some strange reason Shivering Isles `.lod` files (and maybe others?) take much longer to load than from `Oblivion - Meshes.bsa`.  It might have something to do with the archive.  **TODO:** try with loose files

The file loading for all the `.lod` files does take quite a while.

# [05/04/2020] LOD meshes

`MWRender::Objects::insertModel()` has the ability to deal with static geometry.  However it still relies on each object being a `Ptr`.

In order to add an `Ogre::Entity` or an `Ogre::StaticGeometry` we need access to an `Ogre::SceneNode`.  The root node is held by `MWRender::Objects`.

        MWWorld::    MWRender::          MWClass::       MWRender::  MWRender::       Static
        Scene        RenderingManager    ForeignBook     Objects     ObjectAnimation  Geometry
          |                |                |               |             |              |
          |                | setRootNode()  |               |             |              |
          |                |------------------------------->|             |              |
          |                |                |               |             |              |
          :                :                :               :             :              :
          :                :                :               :             :              :
          | InsertFunctor  |                |               |             |              |
          |--+             |                |               |             |              |
          |  | addObject() |                |               |             |              |
          |  |------------>|                |               |             |              |
          |  |             | insertObjectRendering()        |             |              |
          |  |             |--------------->|               |             |              |
          |  |             |                | insertModel() |             |              |
          |  |             |                |-------------->|             |              |
          |  |             |                |               | new         |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               | canBatch()  |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               | fillBatch() |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               |             | addEntity()  |
          |  |             |                |               |             |------------->|
          |<-+             |                |               |             |              |
          |                |                |               |             |              |


`ObjectAnimation::canBatch()` looks for the lack of particle effects, lights, animation, etc.

The places where we add LOD objects are shown below.  But `MWWorld::Scene` does not have access to a `SceneNode`.  It will need to go via the `Rendering Manager` - which means we'll probably have to add a method (or two).

  method                            | LOD
  ----------------------------------|------------------------
  `Scene::changeToWorldCell()`      | landscape low-poly mesh
  `Scene::updateWorldCellsAtGrid()` | visibly distant


        MWWorld::    MWRender::          MWClass::       MWRender::  MWRender::       Static
        Scene        RenderingManager    ForeignBook     Objects     ObjectAnimation  Geometry
          |                |                |               |             |              |
          |                |                |               |             |              |
          | addLandscape() |                |               |             |              |
          |--------------->|                |               |             |              |
          |                | insertLandscapeModel()         |             |              |
          |                |------------------------------->|             |              |
          |                |                |               | addEntity() |              |
          |                |                |               |--------------------------->|
          |                |                |               |             |              |


# [06/04/2020] LOD meshes with only `NiTriStrips` and `NiTriStripsData`

There are a couple of impementation possibilities:

  * Option 1: Insert dummy `NiNode`, etc.  This will require quite a lot of work - there are no default constructors for `NiNode`, `NiAVObject`, `NiObjectNET`, `NiObject`, `NiTexturingProperty`, `NiSourceTexture`, etc.
  * Option 2: Modify the mesh building code and add a specil create method in `NiModelManager`.  This might be even more work and most likely to be more complicated.

## When do we render the mesh

    |                              |                              |
    | (-32,32)                     | (0,32)                       | (32,32)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |                              |       ^                      |
    |                              |       |                      |
    |               x            +-------+ |       x              |
    |                            | |     | |                      |
    |                            | | @1  |                        |
    |                            | |     |                        |
    |                            +-------+                        |
    |                              |                              |
    | (-32,0)                      | (0,0)                        | (32,0)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                   (-14,-6)   |                              |
    |                  +           |                    +-------+ |
    |                              |                    |       | |
    |                              |                    |   @2  | |
    |               x              |               x    |       | |
    |                              |                    +-------+ |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    | (-32,-32)                    | (0,-32)                      | (32,-32)
    +------------------------------+------------------------------+--------

There are 36 files for Tamriel.  The pair of numbers represent the bottom left corner grid of the block.  i.e. `<formid in dec>.<x bottom left><y bottom left><width/height of the square block>.nif`

    (-96, 64) (-64, 64) (-32, 64) (00, 64) (32, 64) (64, 64)
    (-96, 32) (-64, 32) (-32, 32) (00, 32) (32, 32) (64, 32)
    (-96, 00) (-64, 00) (-32, 00) (00, 00) (32, 00) (64, 00)
    (-96,-32) (-64,-32) (-32,-32) (00,-32) (32,-32) (64,-32)
    (-96,-64) (-64,-64) (-32,-64) (00,-64) (32,-64) (64,-64)
    (-96,-96) (-64,-96) (-32,-96) (00,-96) (32,-96) (64,-96)

In the game file, the bottom left cell is (-64,-40) and the top right cell is (59,69).  These don't have any CELL data.  The bottom left cell with any data is (-59,-28) and top right (69,47) - even these are LOD regions. (see the region map for 0x0000003C in OpenCS)  So the low-poly mesh extends far beyond the boundary of the cells the player character can go.

Looking at the diagram, the character `@1` will see all 4 blocks (-32,0), (0,0), (-32,-32) and (0,-32).  As the character travels up past the mid-points (marked by 'x'), the blocks (-32,-32) and (0,-32) will no longer be rendered and new blocks (-32,32) and (0,32) will be rendered instead.

Alternatively, if we find the overhead of having the LOD meshes is a problem, we can wait till the character gets closer to the edge.  However, in a pathological case, e.g. at (0,0), there will be 4 blocks being rendered.  So we may as well get used to rendering 4 at a time at all times.

## Algorithm

If the mid-point of the LOD landscape block is less than or equal to the size of the block distance to the player character's cell, then render the block.

i.e.

Subtract `block size / 2` from the current (x,y) - in the diagram above roughly (2,10) - (16,16) = (-14,-6)
The capture area then is:

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    x right       |  -14 +  32 =  18   |  18/32 =  0 +  18/32
    y bottom      |   -6 + -32 = -38   | -38/32 = -1 +  -6/32
    y top         |   -6 +  32 =  26   |  26/32 =  0 +  26/32

So 4 combinations (-1,-1), (-1,0), (0,0), (0,-1) in blocks, or multiply by 32 to get cell grid numbers.

```cpp
xLeft  = int((x - 16 - 32) / 32) * 32; // = int((x - 48) / 32) * 32
xRight = int((x - 16 + 32) / 32) * 32; // = int((x + 16) / 32) * 32
```

### Hysteresis

For loading cells, visibly distant objects and LOD landscape, hysteresis should be introduced to stop constant loading/unloading at specific points in the map.  i.e. loading and unloading occurs at different points

In order to avoid keeping an unreasonable number of blocks around (again, in pathological cases), we can make the unloading happen *before* loading. i.e. (2,10) - (14,14) = (-12,-4)  As the player character goes up the map, the player will reach ((2,15).  At that point y bottom for unloading will be (15 -14 -32)/32 = 0 -31/32.

Testing for (0,0), unloading:

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    x right       |  -14 +  32 =  18   |  18/32 =  0 +  18/32
    y bottom      |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    y top         |  -14 +  32 =  18   |  18/32 =  0 +  18/32

Which results in the same set of blocks for loading.  i.e. unloading before loading may not work?

    |                              |                              |
    | (-32,32)                     | (0,32)                       | (32,32)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |           +--------------------------------------+          |
    |           |////////////////+-------+/////////////|          |
    |           |///x////////////| |     |/////////x///|          |
    |           |//////+---------| | @1  |-----+///////|          |
    |           |//////|         | |     |     |///////|          |
    |           |//////|      ^  +-------+     |///////|          |
    |           |//////|      |    |           |///////|          |
    |           |//////|      |    |           |///////|          |
    | (-32,0)   |//////|           | (0,0)     |///////|          | (32,0)
    +-----------|//////|-----------+-----------|///////|----------+--------
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////+-----------------------+///////|          |
    |           |///x//////////////////////////////x///|          |
    |           |//////////////////////////////////////|          |
    |           +--------------------------------------+          |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    | (-32,-32)                    | (0,-32)                      | (32,-32)
    +------------------------------+------------------------------+--------

Here the character is travelling up.  If we implemented unload before load, then the blocks (-32,-32) and (0,-32) would be unloaded at this point but the blocks (-32,32) and (0,32) are not yet loaded.  So it seems like it will work?

Testing for (2,15), unloading:

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -12 + -32 = -44   | -44/32 = -1 + -12/32
    x right       |  -12 +  32 =  20   |  20/32 =  0 +  20/32
    y bottom      |    1 + -32 = -31   | -31/32 =  0 + -31/32
    y top         |    1 +  32 =  33   |  33/32 =  1 +   1/32

Not quite right, we lose the bottom two blocks but gain two from the top?  Maybe use this to unload from the list of currently loaded blocks?  This way while the character is inside the coloured section only 1 - 2 blocks are loaded. **NOTE: that the diagram assumes the loading point was also changed, say (x,y) - (18,18)**

## Bugs 1

**FIXME:** `NiTexturingPropery` has below test code which is hiding a problem in `ForeignNpcAnimation::createMorphedObject()` where the proper texture was not being passed.

```
// FIXME: testing
if (material.texName[iter->first].find("EarsHuman") != std::string::npos)
    material.texName[iter->first] = "textures\\characters\\imperial\\earshuman.dds";
```

## Bugs 2

Need to look into `TES4BSAFile::getFile()` where it is extremely slow in reading one of the archives (Shivering Isles - Meshes)

# [07/04/2020 - 08/04/2020] Where to store LOD data

`MWWorld::Cells` might be a possibility.  Or `MWWorld::Scene`.  But `MWWorld::CellStore` is not, since much of the LOD data is not focused on a single cell.

Currently `Scene` only keeps active cells and uses `World` to retrieve  the required cells from `Cells`.  That makes sense, but the LOD data are not really cells and storing them in `Cells` doesn't seem to quite fit.  Much of the data are really simplified REFR and they are normally loaded into CellStore from ESMStore (except in this case they are loaded from either BSA or loose files).

So maybe keep the LOD data in `ESMStore`?  Or a separate one altogether?  If in `ESMStore` when to trigger the loading?  Anyway, the data is not in an ESM so this feels wrong, too.

How about storing them in `ForeignWorld`?  We can still trigger the loading somehow in `ESMStore`, for example when the first group world child block is encountered.

## Dummy cell

Tamriel has 0x7B9 = 1977 REFR in its dummy cell.  There would also be ACRE and ACHR in the dummy cell. Currently all these are inserted into the scene, resulting in a major FPS drop.  **NOTE:** another test suggest 1509 including ACHR/ACRE so further tests are needed - but the point is still valid, there are *a lot*.

Can't quite remember why the cell persistent children are read for door cells in ESMStore.  That was done back in 2016.  I think it is because if we leave that until we load a world or a cell, then there is a possibility that we haven't yet loaded a destination door to find out in which cell it is located. (i.e. because the cell in which a door is located is implied in the group structure, not explicitly stated anywhere)

## `MWWorld::Ptr` and `MWWorld::CellRef`

We many need to introduce some changes here in order to deal with LOD data.  Currently we pretend to be a TES3 `ESM::CellRef` by copying similar data across.  Using ESM::Door as an example:

              mRef
        Ptr o------------------------------------------------ LiveCellRefBase*
          o                                                        ^
          | mCell             mDoors                    mList      |
          +------ CellStore* o------ CellRefList<Door> o----- LiveCellRef<Door>


A `Ptr` has an implicit understanding of to which cell it belongs.  Can we still use `Ptr` for the objects in the dummy cell?  The objects in the dummy cell can have positions in different actual cells (at least for exterior dummy cells).

Also, `CellStore::forEachImp()` converts everything in its `CellRefList` stores into `Ptr` before inserting them into the scene.  **We need a way to selectively disable the rendering/animation/physics.  In case of doors, we would like to add them to the scene based on their positions, similarly with visibly distant statics and trees.**

                          mRef                   mCellRef
        LiveCellRefBase o------------- CellRef o---------- ESM::CellRef
              ^     o o                    o o
              |     | | mClass             | | mFormId
              |     | +------ Class*       | +------------ ESM4::FormId  (REFR/ACHR/ACRE)
              |     |  mData               |   mDestDoorId
              |     +-------- RefData      +-------------- ESM4::FormId  (DOOR)
              |                o o o
        LiveCellRef<Door>      | | |
                               | | +-- (current position/rotation/etc)
                               | +---- Ogre::SceneNode*
                               +------ CustomData*
                                           ^
                                           |
                                      DoorCustomData


**FIXME:** not happy having mDestDoorId in CellRef, need to move it to somewhere else
**TODO:** not sure of the original intent / design to use `std::list` in `CellRefList` - might have to investigate (might be because iterators don't become invalid as new items get inserted/erased?)

## Initial design

  * Consider inheriting from `CellStore` to create `ForeignCellStore` or something similar.
  * Load *all* REFR/ACHR/ACRE in Cell Persistent Child group from `ESMStore`.  Store them in a `CellStore` as usual but keep a map of their grid locations (at least for external dummy cell).
  * Load the visibly distant REFR from BSA and store them in a `CellStore`, similar to the dummy one.
  * These special `CellStore`s should be kept in their respective `ForeignWorld`, at least for external ones.
  * Modify (or create a similar one) `Scene::insertCell()` so that objects can be inserted selectively, based on location, class, etc.

**TODO:** Fix the interaction diagram from 31/09/20

## `CellStore` user cases

Keeping a map of grid positions turns out to be difficult for dummy cell, since all the data are held in `std::list`.  Had a quick look at various accesses to `CellRefList` but can't really see too many insertions/deletions except at loading time and even then it's mostly `push_back()`.

So maybe there might be some performance improvements if `std::list` was replaced with `std::vector`.

## Rethinking the dummy cells and grid map

Maybe keeping indices isn't the optial solution, anyway?  Perhaps keep a "Persistent" section on each `CellStore`?  But doing so will result in 3 of each type of object - e.g. persistent static, temporary static and visually distant static.

Or just brute-force by searching with x/y range each time?

# [09/04/2020] LOD meshes clipping with terrain

I think this issue may be resolved by having a manual alpha map and using alpha rejection in the LOD mesh materail. There are a lot of questions about how to actually implement it, however.  For example, what exactly is an alpha map?  Is it a texture itself?  If so does it have to be the same size as the other texture? (in this case 1024x1024) How does one create an area where alpha values are transparent?

With regards to the size of the texture, it appears that alpha rejection is done per pixel basis.  Which also means that when a cell becomes "active" or "inactive" the corresponding pixels of the alpha map needs to be updated.

The `StaticGeometry` will need to be updated with the new material and built again each time terrain is updated.




[//]: # (/* spell spelllang=en_au syntax=cpp */)
[//]: # (/* vim: set ft=markdown tw=0 lbr bri fen fdm=marker fdl=0: */)
