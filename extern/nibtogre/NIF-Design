<!--
/*

  Copyright (C) 2018-2022 cc9cii

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  cc9cii cc9c@iinet.net.au

*/
-->

# [17/12/18] NIF Design

Ideally minimise unnecessary loops or processing duplications.

## Cache objects

But at what level?  The choices seem to be:

  * NIF after parsing - each of the object instances based on the same NIF needs to be built
  * already built object instance - everything is the same except position/rotation/etc
    (how to clone?)

## Building object instances

### Object Scope and Lifetime

    NIF Object      | Ogre Object            | Ogre Instance
    ----------------+------------------------+-------------------------
    NIF             | NiModel                | BtOgreInst (has pos/rot/scale/etc from ESM/ESP)
    NiNode          | Ogre::Mesh             | Ogre::Entity
    NiGeometry      |   submesh              |   sub-entity
                    |     material           |
                    |   animation            |
                    |   pose (vertex anim)   |
    ----------------+------------------------+-------------------------
    SkeletonRoot    | Ogre::Skeleton         | Ogre::SkeletonInstance
    Bone            |  bone                  |


One design consideration is when does the Ogre objects (e.g. `Mesh`) get built?

Currently the build is triggered when the associated `Entity` is built (via a loader callback mechanism).  This may not be efficient if the same mesh are re-used often (e.g. `skeleton.nif`, but have not tested if true - __EDIT: 22/02/19__ Not true since an often used mesh will be retrieved from the `MeshManager`'s cache.  Also see below paragraph.).

Note that I may be misunderstanding some stuff here.  For example, the built meshes are managed by the `MeshManager` so they won't be built again. Similarly the skeletons are managed by the `SkeletonManager`.

An alternative might be to create the Ogre objects as each of the NIF files are read.  But doing this can lead to a large number of Ogre objects being loaded (Q: do Ogre resource managers ever unload? A: yes)

Some `NiTimeControllers` may work with different Ogre objects.  For example:

  * `NiGeomMorpherController` is setup while creating a sub-mesh (vertex animation) `SceneManager::_applySceneAnimations` will then call the `apply()` method of each of the animations

  * `NiUVController` seems to work at each of the sub-entity level by modifying the associated
    material (texture scroll)

# [23/12/2018] Some unrelated notes

  1. Ogre resource searching is poor for NIF - multiple archives are searched for each and every resource in BSA (or loose files).  See `OgreResourceGroupManager.cpp`.

     Also, find out if the contents of the BSA can be registered(?) with `ArchiveManager` or `ResourceManager`.  It seems `grp->ResourceIndexCaseSensitive`, etc, are empty.

  2. Each of the sounds throw exception trying to find a `.wav` format, then finds `.mp3` format.  Do some intelligent detection while scanning resources?

  3. Subtitle message box height is too low and hence the bottom of the texts are not showing.

# [25/12/2018]

Decided to revert the `bhkNiTriStripsShape` packing optimisation.  `bhkNiTriStripsShape` shouldn't be occurring often with the newer NIF versions, anyway (hopefully).  Well, it turns out that there are a few - might be worth doing some profiling later.

[//]: # (                                                             {{{
    bhkNiTriStripsShape examples:
    ./meshes/architecture/arena/arenacolumn02.nif
    ./meshes/architecture/bridges/looseboard01.nif
    ./meshes/architecture/bridges/looseboardbroken.nif
    ./meshes/architecture/cheydinhal/woodplank01.nif
    ./meshes/clutter/bonemarrow.nif
    ./meshes/clutter/books/wantedposter01.nif
    ./meshes/clutter/books/wantedposter02.nif
    ./meshes/clutter/gnarlbark.nif
    ./meshes/clutter/houndstooth.nif
    ./meshes/clutter/hungertongue.nif
    ./meshes/clutter/ingredcinnabarpolyporecap01.nif
    ./meshes/clutter/ingredcinnabarpolyporecap02.nif
    ./meshes/clutter/middleclass/middlechestbrokenbottom02.nif
    ./meshes/clutter/middleclass/middlechestbrokenbottom03.nif
    ./meshes/clutter/scalonfin.nif
    ./meshes/clutter/se02handkerchief.nif
    ./meshes/clutter/sesmokedbaliwogleg.nif
    ./meshes/clutter/shamblesskull.nif
    ./meshes/clutter/USIPHoundsToothKey.NIF
    ./meshes/clutter/voidessence.nif
    ./meshes/dungeons/ayleidruins/exterior/cameronsparadise/cpscreen01.nif
    ./meshes/dungeons/ayleidruins/interior/arwelkydiholder01.nif
    ./meshes/dungeons/caves/cave03/cnhallhalf01a.nif
    ./meshes/dungeons/caves/clutter01/ancientscroll01.nif
    ./meshes/dungeons/caves/clutter01/animalrib01.nif
    ./meshes/dungeons/caves/clutter01/arch03.nif
    ./meshes/dungeons/caves/clutter01/arch04.nif
    ./meshes/dungeons/caves/clutter01/archfull01.nif
    ./meshes/dungeons/caves/clutter01/arrmwallexitwide01.nif
    ./meshes/dungeons/caves/clutter01/arrowrock01.nif
    ./meshes/dungeons/caves/clutter01/arwhalldeadend02.nif
    ./meshes/dungeons/caves/clutter01/arwhallendcrumblewall01.nif
    ./meshes/dungeons/caves/clutter01/ayleidplatform01.nif
    ./meshes/dungeons/caves/clutter01/batincage01.nif
    ./meshes/dungeons/caves/clutter01/beartrapclosed03.nif
    ./meshes/dungeons/caves/clutter01/brainvat01.nif
    ./meshes/dungeons/caves/clutter01/burnttranscript01.nif
    ./meshes/dungeons/caves/clutter01/ceismap01.nif
    ./meshes/dungeons/caves/clutter01/ceismap02.nif
    ./meshes/dungeons/caves/clutter01/ceismap03.nif
    ./meshes/dungeons/caves/clutter01/ceismap04.nif
    ./meshes/dungeons/caves/clutter01/ceismap05.nif
    ./meshes/dungeons/caves/clutter01/ceismap06.nif
    ./meshes/dungeons/caves/clutter01/celestialring01.nif
    ./meshes/dungeons/caves/clutter01/centurionsphere01.nif
    ./meshes/dungeons/caves/clutter01/circularartifact01.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup01.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup02.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup03.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup04.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup05.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup06.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup07.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup08.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup09.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup10.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup11.nif
    ./meshes/dungeons/caves/clutter01/crystalgroup12.nif
    ./meshes/dungeons/caves/clutter01/displayglass01.nif
    ./meshes/dungeons/caves/clutter01/displayglasswide01.nif
    ./meshes/dungeons/caves/clutter01/dragon01.nif
    ./meshes/dungeons/caves/clutter01/dragonegg01.nif
    ./meshes/dungeons/caves/clutter01/dragonskull01.nif
    ./meshes/dungeons/caves/clutter01/dwemercog01.nif
    ./meshes/dungeons/caves/clutter01/dwemercylinder01.nif
    ./meshes/dungeons/caves/clutter01/dwemerpiston01.nif
    ./meshes/dungeons/caves/clutter01/dwemerspiderleg01.nif
    ./meshes/dungeons/caves/clutter01/emptycage01.nif
    ./meshes/dungeons/caves/clutter01/fireflycage01.nif
    ./meshes/dungeons/caves/clutter01/forgering01.nif
    ./meshes/dungeons/caves/clutter01/forgering02.nif
    ./meshes/dungeons/caves/clutter01/geode01.nif
    ./meshes/dungeons/caves/clutter01/geodestatic01.nif
    ./meshes/dungeons/caves/clutter01/gong01.nif
    ./meshes/dungeons/caves/clutter01/gongbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/gongbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/guildgarden01.nif
    ./meshes/dungeons/caves/clutter01/hollowstump01.nif
    ./meshes/dungeons/caves/clutter01/hornofzyyr01.nif
    ./meshes/dungeons/caves/clutter01/landdreughhead01.nif
    ./meshes/dungeons/caves/clutter01/malevolentzinj01.nif
    ./meshes/dungeons/caves/clutter01/malevolentzinjstatic01.nif
    ./meshes/dungeons/caves/clutter01/meteorite01.nif
    ./meshes/dungeons/caves/clutter01/minotaurstatue01.nif
    ./meshes/dungeons/caves/clutter01/minotaurstatue02.nif
    ./meshes/dungeons/caves/clutter01/musicbox01.nif
    ./meshes/dungeons/caves/clutter01/post01.nif
    ./meshes/dungeons/caves/clutter01/post02.nif
    ./meshes/dungeons/caves/clutter01/post03.nif
    ./meshes/dungeons/caves/clutter01/post04.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase02.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase03.nif
    ./meshes/dungeons/caves/clutter01/postbrokenbase04.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/postbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/pyre01.nif
    ./meshes/dungeons/caves/clutter01/rock01.nif
    ./meshes/dungeons/caves/clutter01/runesofcyrodiil01.nif
    ./meshes/dungeons/caves/clutter01/rythorspendant02.nif
    ./meshes/dungeons/caves/clutter01/rythorspendant03.nif
    ./meshes/dungeons/caves/clutter01/sarcophagus01.nif
    ./meshes/dungeons/caves/clutter01/scaffolding01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumn04.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokenbottom04.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/sectorcolumnbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/shaft01.nif
    ./meshes/dungeons/caves/clutter01/shard01.nif
    ./meshes/dungeons/caves/clutter01/shipwreck02.nif
    ./meshes/dungeons/caves/clutter01/spire01.nif
    ./meshes/dungeons/caves/clutter01/spire02.nif
    ./meshes/dungeons/caves/clutter01/spire03.nif
    ./meshes/dungeons/caves/clutter01/spiredoor01.nif
    ./meshes/dungeons/caves/clutter01/spiredoor02.nif
    ./meshes/dungeons/caves/clutter01/spiredoor03.nif
    ./meshes/dungeons/caves/clutter01/spiredoor04.nif
    ./meshes/dungeons/caves/clutter01/spiredoor05.nif
    ./meshes/dungeons/caves/clutter01/tallcensor01.nif
    ./meshes/dungeons/caves/clutter01/tallcensorbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/tallcensorbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/tallmushroom01.nif
    ./meshes/dungeons/caves/clutter01/talon01.nif
    ./meshes/dungeons/caves/clutter01/teavscorpse01.nif
    ./meshes/dungeons/caves/clutter01/teavssword01.nif
    ./meshes/dungeons/caves/clutter01/tent02.nif
    ./meshes/dungeons/caves/clutter01/test01.nif
    ./meshes/dungeons/caves/clutter01/test02.nif
    ./meshes/dungeons/caves/clutter01/trilobite02.nif
    ./meshes/dungeons/caves/clutter01/twist01.nif
    ./meshes/dungeons/caves/clutter01/twist03.nif
    ./meshes/dungeons/caves/clutter01/twist04.nif
    ./meshes/dungeons/caves/clutter01/twist05.nif
    ./meshes/dungeons/caves/clutter01/twist06.nif
    ./meshes/dungeons/caves/clutter01/twist07.nif
    ./meshes/dungeons/caves/clutter01/twist08.nif
    ./meshes/dungeons/caves/clutter01/twist09.nif
    ./meshes/dungeons/caves/clutter01/twist10.nif
    ./meshes/dungeons/caves/clutter01/twist11.nif
    ./meshes/dungeons/caves/clutter01/twist12.nif
    ./meshes/dungeons/caves/clutter01/twist13.nif
    ./meshes/dungeons/caves/clutter01/twist14.nif
    ./meshes/dungeons/caves/clutter01/twist15.nif
    ./meshes/dungeons/caves/clutter01/twist16.nif
    ./meshes/dungeons/caves/clutter01/twist17.nif
    ./meshes/dungeons/caves/clutter01/twist18.nif
    ./meshes/dungeons/caves/clutter01/twist19.nif
    ./meshes/dungeons/caves/clutter01/twist20.nif
    ./meshes/dungeons/caves/clutter01/twistpiece01.nif
    ./meshes/dungeons/caves/clutter01/twistpiece02.nif
    ./meshes/dungeons/caves/clutter01/twistpiece03.nif
    ./meshes/dungeons/caves/clutter01/twistpiece04.nif
    ./meshes/dungeons/caves/clutter01/upcolumn01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase02.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase03.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokenbase04.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop01.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop02.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop03.nif
    ./meshes/dungeons/caves/clutter01/upcolumnbrokentop04.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom01.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom02.nif
    ./meshes/dungeons/caves/clutter01/wallmushroom03.nif
    ./meshes/dungeons/caves/clutter01/warlockartifact01.nif
    ./meshes/dungeons/caves/clutter01/warlockchest01.nif
    ./meshes/dungeons/caves/clutter01/warlockcoffer01.nif
    ./meshes/dungeons/caves/clutter01/warlockcoffer02.nif
    ./meshes/dungeons/caves/clutter01/warlockskeleton01.nif
    ./meshes/dungeons/caves/clutter01/warlockspellshrine01.nif
    ./meshes/dungeons/caves/clutter01/warlocktile01.nif
    ./meshes/dungeons/caves/clutter01/warlocktile02.nif
    ./meshes/dungeons/caves/clutter01/warlocktile03.nif
    ./meshes/dungeons/caves/clutter01/warlocktile04.nif
    ./meshes/dungeons/caves/clutter01/warlocktile05.nif
    ./meshes/dungeons/caves/clutter01/warlocktile06.nif
    ./meshes/dungeons/caves/clutter01/warlocktile07.nif
    ./meshes/dungeons/caves/clutter01/warlocktile08.nif
    ./meshes/dungeons/caves/clutter01/warlocktile09.nif
    ./meshes/dungeons/caves/clutter01/warlocktile10.nif
    ./meshes/dungeons/caves/clutter01/warlocktile11.nif
    ./meshes/dungeons/misc/ricketyfence01.nif
    ./meshes/dungeons/Root/Interior/Misc/gnarlspawner.nif
    ./meshes/dungeons/Root/Interior/Misc/spiketrap.nif
    ./meshes/furniture/middleclass/bearskinrug01.nif
    ./meshes/furniture/middleclass/middlewolfrug01.nif
    ./meshes/furniture/middleclass/ms51rewardpainting.nif
    ./meshes/Museum/HoundsToothKey.NIF
    ./meshes/oblivion/clutter/traps/hallwaytrackbladetrap02.nif
    ./meshes/oblivion/clutter/traps/hallwaytrackbladetrap02b.nif
    ./meshes/plants/Dementia/blisterpodcap.nif
    ./meshes/plants/Dementia/DDigestiveSlime.NIF
    ./meshes/plants/Dementia/dpodpit.nif
    ./meshes/plants/Mania/alocasiafruit.nif
    ./meshes/plants/Mania/kelpgasbladder.nif
    ./meshes/plants/Mania/wormheadcap.nif                             }}})

# [25/12/2018]

## Rough sequence of events:

  * Load cell
  * Insert objects as per ESM/ESP references
  * Read NIF model from BSA or loose files (cache the NIF?  probably best to cache the `NiModel`)
  * Build the Ogre "templates" such as Mesh, Skeleton, Vertex Animation, etc, and store them in
    their respective resource managers
  * Create Ogre Entities (actually, trying to create an `Ogre::Entity` triggers the first time
    'loading' of the resources such as meshes)
  * Also create Bullet objects
  * Associate entity controllers (for some animation types)

## Some more detail:

### NiNode
`NiNode` is a `Mesh` if any of the children is an `NiGeometry`, which is a sub-mesh.  A sub-mesh may have its own animation (time controllers from `NiGeometry`)

Ogre `MeshManager` needs a unique identifier (name?) for the `Mesh`.  For now the NIF model name plus the `NiNode` name is used but it may be possible to use a hash value + block number instead.

__TODO:__ Since the meshes are loaded on-demand, and sub-meshes are created from a mesh, each of the `NiGeomerty` children are registered to a loader.  An alternative is to re-scan the children at build time.  Not sure which is more efficient.

The mesh loader should be part of `NiModel` so that the cached one also has the loader.

Any associated object, such as materials, animations and skeletons should also be loaded.

### NiGeometry
`NiGeometry` may have, in addition to an `NiGeometryData`:

     NiAVObject::NiProperties       : e.g. NiMaterialProperty, NiTexturingProperty, etc
                                    : each of these may have an NiTimeController
                                      e.g. NiMaterialColorController, NiFlipController
     NiObjectNET::NiTimeController  : applies at sub-mesh/sub-entity level
                                      e.g. NiUVController, NiGeomMorpherController
     NiSkinInstance                 : this will trigger a skeleton to be built
     Materials                      : (Skyrim)
     BS Properties                  : (Skyrim)

# [27/12/2018]

## NiProperty

`NiTriShape` seems to allow only two properties?

    Property Name           NIF              Ogre
    ----------------------+----------------+---------------------
    NiMaterialProperty      Ambient
                            Diffuse
                            Specular
                            Emissive
                            Glossiness
                            Alpha
                            Emit Multi
    ----------------------+----------------+---------------------
    NiTexturingProperty     Base      (0)
                            Dark      (1)
                            Detail    (2)
                            Gloss     (3)
                            Glow      (4)
                            Bump Map  (5)
                            Normal    (6)
                            Decal
                            Shader
    ----------------------+----------------+---------------------
    NiAlphaProperty         Transparency?
    NiVertexColorProperty
    NiZBufferProperty
    NiSpecularProperty      Shiny
    NiWireframeProperty     Wireframe
    NiStencilProperty       Draw both sides

    BSLightingShaderProperty
    BSEffectShaderProperty
    BSWaterShaderProperty
    Property

## Some notes on Shiny:

    transparent_sorting                Ogre::Pass::setTransparentSortingForced
    num_nipmaps                        Ogre::TextureUnitState::setNumMipmaps
    anim_texture2                      Ogre::TextureUnitState::setAnimatedTextureName
    diffuseMap, detailMap,             Ogre::TextureUnitState::setTextureName
    darkMap, emissiveMap
    lod_values                         Ogre::MaterialScriptContext (protected member of
                                             Ogre::MaterialSerializer)
    diffuse, specula,                  Ogre::AtrributeParserList (protected member of
                                             Ogre::MaterialSerializer)

    MaterialInstance::setProperty
      PropertySetGet::setProperty
        mProperties

    diffuse 1.0 1.0 1.0 1.0
    specular 0 0 0 0 1
    ambient 1.0 1.0 1.0
    emissive 0.0 0.0 0.0
    vertmode 0
    normalMap
    specMap
    use_emissive_map false
    use_detail_map false
    use_diffuse_map false
    use_dark_map false
    emissiveMapUVSet 0
    detailMapUVSet 0
    diffuseMapUVSet 0
    darkMapUVSet 0
    use_parallax false

    scene_blend default
    depth_write default
    depth_check default
    alpha_rejection default
    polygon_mode default
    env_map false
    env_map_color 1 1 1

    alphaTestMode 0
    alphaTestValue 0

## BtOgreInst

`BtOgreInst` should maintain the `Entities` and `SceneNodes` (probably also `RigidBodies`) It should "have" an `NiModel`, at least a pointer/reference to it.

When a `BtOgreInst` is built, it will in turn build its `NiModel` first.  The `NiModel` building process should result in finding out which entities are to be built (e.g. name of the `Mesh`)

## NiNode

`NiNode` may have an associated collision object(s).  These collision shapes and constraints are built in Bullet.

# [28/12/2018]

## Controllers:

   NiNode               NiVisController            idleobjects/genericbook.nif
                        NiTransformController      fire/firetorchlargesmoke.nif
                        NiKeyframeController

   NiGeometry           NiUVController
                        NiGeomMorpherController

   NiTexturingProperty  NiFlipController

   NiMaterialProperty   NiAlphaController
                        NiMaterialColorController

   ??                   ParticleSystem

# [29/12/2018]

## Animation

### Vertex Animation

  * `GeomMorpher` (`Morph` implemented by `Ogre::Pose`)
    - `Animation` added to a `Mesh`
    - `AnimationTrack` added to the Animation (its handle is `subMeshIndex+1`)
    - Each `Morph` is a `Pose` (all of the poses have the target of `subMeshIndex+1`)
    - Each `Morph` key is a `VertexPoseKeyFrame` (pose index points to a `Pose`)
      (from NIF 10.0.1.0 the keys are under `NiControllerSequence::mControlledBlocks`)
    - Note the current Ogre limitations on interpolator (lacks quadratic)

### Material Animation

  * All below affect an `Ogre::MovableObject` (but should be a `SubEntity`?)
   - UV
   - Alpha
   - Flip
   - MaterialColor

### Node Animation

  * visibility
     - affects the visibility of an `Ogre::Entity` (i.e. `NiNode`)
  * Transform/Keyframe
     - animates an `Ogre::Node`
  * `skeleton.nif` + `*.kf`
  * skinned
     - e.g. armour, clothes
     - how to attach to an existing skeleton?  by bone names?
     - note Skeleton Root can be different for each NiSkinInstance and they are not necessarily Scene Root

## Finding minimum size skeleton

  1. While constructing the objects (i.e. reading the NIF file), make a note of `NiNode` parent `NiNode`.
  2. Also make a note of leaf `NiNode`; `NiSkinInstance::mBones`, `NiTransformController::mTargetRef`, and maybe even `NiNodes` names starting with "`AttachLight`".
  3. Once all the blocks are read in, reverse search from each of the leaf nodes to the root node (prb. use the one in the footer?).  While doing this each of the `NiNode` should keep a list of child `NiNode` that will be bones.
  4.  Finally create a skeleton using the `SkeletonManager` and a `ManualResourceLoader`.  The name of the `Skeleton` should be the name of the `NiModel`.

## How to add (attach?) other NIF/kf files to a NIF?

e.g. weapons, armour to skeleton
e.g. fire to "`FlameNode`"

# [29/12/2018]

    mwscript/cellextensions.cpp       : opCOW

    mwclass/foreigndoor.cpp           : activate
    mwworld/actionteleportforeign.cpp : ActionTeleportForeign::teleport

    mwworld/worldimp.cpp              : changeToForeignWorldCell
    mwworld/scene.cpp                 : changeToForeignWorldCell     <---- sometimes not working

# [30/12/2018] removed some debugging printouts

    material.cpp          : unhandled texture controller
    ogrenifloader         : No bone named...
                          : Unsupported controller...
    foreignnpcanimation   : Inventory...
    scene.cpp             : dummy
    bulletnifloader       : (various)
    esm4/race.cpp         : skipping...


# [01/01/2018] A new start...

Well, a bit of rethink about object life cycle management now that the new rendering seems to work ok.  This was triggered by Bullet's need to have the collision shapes around during the lifetime of RigidBodies.

Embracing Ogre's resource management philosophy of on-demand resource loading, the NiModel's structure needs to change:


    SceneNode o-- Entity o-- Mesh o-- SubMesh o-- Material o-- Texture
                    o
                    |
              SkeletonInstance
                    ^
                    |
                 Skeleton (?)


If Ogre decides to create an `Entity`, it will be based on a `Mesh` retrieved from a `MeshManager`.  The `Mesh` in turn may use `MaterialManager` or `SkeletonManager`.

An ESM/ESP model (i.e. a NIF) may result in a Skeleton and a number of `Meshes` (and other things) to be built.  In OpenMW the ownership structure is roughly:


                                      Animation o-- ObjectScene o-- Entity, Light, Particles...
                                          ^
                                          |
    RenderingManager o-- Objects o-- ObjectAnimation
             o              o
             |              +------- SceneNode
             |
             +---------- Actors


And in a little more detail (but still simplified):


         MWRender::Animation o------------ MWWorld::Ptr
               o     o            mPtr
               |     |
               |     +------------------+
               |                        |
               | mObjectRoot            | mInsert
               |                        |
               |                   Ogre::SceneNode*
         NifOgre::ObjectScene*          o
               o                        |
               | mEntities              | Ogre::ObjectMap
               |                        |
               +------------------ Ogre::Entity*
                                        o
                                        | mMesh
                                        |
                                   Ogre::Mesh*


A `MeshManager` may call a `Mesh` loader which will need to refer to a NIF model (either loaded from a file or retrieved from a cache).  Currently the NIF model "owns" the loaders.  This may need to be flipped around, i.e. the loaders should be able to trigger the NIF models to be loaded/retrieved.

One way of achieving this could be to derive from an `Ogre::ResourceManager`. e.g.:


       ResourceManager   Singleton<NiModelManager>
                ^             ^
                |             |
                 \           /          Resource o------- ManualResourceLoader
                  \         /              ^                     ^
                   \       /               |                     |
                 NiModelManager            |                     |
                 ::createImpl()  . . .  NiModel           ManualNiModelLoader
                                        ::loadImpl()      ::loadResource()
                                        ::unloadImpl()    (NOTE: not implemented)


A manually loaded resource will retain a pointer to its loader (e.g. see `Ogre::Mesh`).  That means, for the resource to be reloaded (by its manager) the loader needs to remain valid.

With the current design where the loaders are "owned" by `NiModel`, `NiModel` needs to hang around until the resources (`Mesh`, `Skeleton`, etc) are no longer needed (e.g. unloading a cell).

One simple way could be to maintain a map of `NiModel` smart pointers in `ObjectScene` for deletion.  A slightly better way is to have a cache to avoid multiple loading of the same NIF files.  Or we could implement an `NiModelManager` as per above.  An `NiModel` can then be loaded on-demand.

(__EDIT: 22/02/19__ looks like keeping the mesh loader with the `NiModel` in `ObjectScene` won't work since the same mesh for a different instance could be used)

__NOTE:__ current implementation does not use a `ManualResourceLoader` which probably means `NiModel` cannot be reloaded automatically (actually, it can)

__IDEA:__ Keep all the loaders in `ObjectScene`?  Or in `BtOgreInst` then have `ObjectScene` destroy `BtOgreInst` in the destructor?

`OEngine::Physic::PhysicEngine::mCollisionObjectMap` keeps `Physic::RigidBody*` for later destruction.  (and `mAnimatedShapes`, etc.)


    MWWorld::Scene::unloadCell
      PhysicsSystem::removeObject      (for ptr.getRefData().getBaseNode() and its children)
        OEngine::Physic::PhysicEngine::removeCharacter
        OEngine::Physic::PhysicEngine::removeRigidBody
          mDynamicsWorld->removeRigidBody
        OEngine::Physic::PhysicEngine::deleteRigidBody
          mAnimatedShapes.erase(body);
          delete body;


`btShapes` are deleted in `BulletShape` dtor and `BulletShape` is probably stored in `BulletShapeManager`.

# [02/01/2019] Physics continuing

  1. Get `NiModel` & get a list of target Entities; need as inputs `Ogre::SceneNode`, position, rotation and scale.  This means that the `Mesh`/`Entity` needs to have been created _before_ physics.
  2. For each target Entity create the resource using the resource manager.
  3. Using the resource create the `btRigidBody` corresponding the `Entity`.
  4. Additional setup (e.g. constraints) needs to be done for ragdolls. (how to detect?)

# [02/01/2019] Physics continuing still

With `btCollisionShape` required for constructing `btRigidBody`, it turns out that a new one needs to be generated each time.  ([or at least a deep copy made?]( https://stackoverflow.com/questions/12255546/c-deep-copying-a-base-class-pointer))

# [06/01/2019] Issues found while running around

## exception

    COW "AnvilWorld" -46 -8

    exception     Ptr World::getPtrViaHandle (const std::string& handle)  Anvil Fighters Guild
    searches mActiveCells in CellStore

## wrong position and/or rotation

The shirt in display case is half clipping through the bottom (`ICMarketDistrictRedDiamondJewelry`)

# [06/01/2019] Get to some old code & comments

    Gdiff b44b4bad325296ca8ab7d519e33ca533f679abf8

# [08/01/2019] Some notes on odd build sequences

## NiTriBasedGeom (NiTriShapes/NiTriStrips)

__EDIT: 29/02/20__ `MeshLoader` is being re-designed

  * in the constructor register self in `BuildData` (but first check if parent NiNode is named "`EditorMarker`")
  * during the registration a `MeshLoader` is created and associated with the parent `NiNode`
     (note that it is no longer done when a NiNode is building its children)
  * when the `NiModel` is 'instantiated' the `Mesh` and `SubMesh` are loaded when the `Entity` is created (using the `Mesh` pointer, but can be done with the `Mesh` name)
  * any vertex animations in a `SubMesh` are setup with the `Entity`
  * note that there may be more than one `Mesh` per `NiModel`
  * in future implementation the `MeshLoader` may need to be moved out of `BuildData`

## bhkEntity (bhkRigidBody/bhkRigidBodyT)

  * in the constructor of `NiCollisionObject` register the collision object body (__TODO:__ should check if collision is enabled in BSX)
  * a `BtRigidBodyCI` object is created with the same name as the `NiModel`; it then looks for any registerd `bhkEntity` to build the `btShapes`, etc.
  * note that there may be more than one `RigidBody` per `NiModel` (these may need to be deleted manually)

# [18/02/2019] Animation re-write

The animation glitches, especially with the hand positions, may be due to the use of separate controllers for each of the bones.  It may be that each of the bones are showing rotations and/or positions at different points in time.

__NOTE:__ experiments indicate that all the bones are updated at the same time... :-(

Nifskope uses `NiMultiTargetTransformController`, replacing the `NiTransformController` (which is _not_ its parent class, interestingly) at the "Accum Root" bone specified in `NiControllerSequence`.

Each of the target bones in the _Controlled Blocks_ are then added to `mExtraTargetRefs` and `mNumExtraTargets` updated (this method is prob. not necessary).  Note that if multiple anims are added to the skeleton then only the additional bones are added to `mExtraTargetRefs`.

# [18/02/2019] skeleton for children

Looks like the bones listed in the skinned meshes indicate the smaller size of the skeleton for children.  That means the body parts need to be added and the binding position re-set.

__TODO:__ this might not be true at all, need to experiment

# [28/02/2019] instantiation refactoring

The existing OpenMW code is built around `ObjectScene` and `SkelBase` (`Ogre::Entity` at root).  It would be way too much work right now to move away from that.

Q: how best to hold the animation info?


        ObjectScenePtr
              o
              |
              +-------- BtOgreInst
                         o o o o
                         | | | |
                         | | | +------- SkelBase
                         | | +--------- NiModelPtr
                         | +----------- Animation info (textkeys, controllers)
                         +------------- std::vector<Ogre::Entity*>


# [06/03/2019] Havok

If Havok enabled, assign a child SceneNode for each `btRgidBody`.

Q: how to allow the SceneNode to move across cell boundary?  is it an issue?

# [08/03/2019] Havok

In order to make Havok physics work, there is a need to mix rendering instances (e.g.  `Ogre::SceneNode`) and physics instances (i.e. `btRigidBody`).

The way OpenMW is currently written, they diverge at `::addObject()` (see: `mwworld/scene.cpp`) Fortunately, both call path end up with the same class, i.e.:

```cpp
ptr.getClass().insertObjectRendering(ptr, model, renderingmanager);
ptr.getClass().insertObject (ptr, model, physics);
```

So we can "cheat" by using the class as an access path to get to the rendering instances data which is currently stored in `ObjectAnimation`.  Havok enabled classes include most:

    LIGH (CathedralCryptLight02.NIF)
    STAT (TargetHeavy01.NIF)
    CREA (Skeleton.nif)
    NPC_ (Skeleton.nif)
    BOOK (Octavo02.NIF)
    APPA (ApparatusRetortMaster.NIF)
    etc, etc

# [09/09/2019] FaceGen texture again

  * EGT A binary file format containing texture statistics data for each pixel for each mode.

  * SCM The mean colour map is a 24-bit RGB colour image. Each mode is stored as a signed RGB8 map, along with a floating point scaling factor. Vertex UV co-ordinates do not change.

    DXGI_FORMAT_BC3_UNORM
    8 bits per pixel
    Transparent Selection

Four-component block-compression format. For information about block-compression formats, see [Texture Block Compression in Direct3D 11](https://docs.microsoft.com/en-us/windows/win32/api/dxgiformat/ne-dxgiformat-dxgi_format).

## UrielSeptim

Tried to figure out how the vanilla engine is keeping the age value by changing UrielSeptim's age using the TES Construction Set and saving it as an ESP.  It appears that the age value itself is not stored but the `FGGS` and `FGTS` records change.  There must be a way to derive the age value from them.

### Oblivion - Textures - Compressed.bsa

    textures\faces\oblivion.esm\00023f2e_0.dds
     px x  px  mip level
    256 x 256     1
    128 x 128     2
     64 x  64     3
     32 x  32     4
     16 x  16     5
      8 x   8     6
      4 x   4     7
      4 x   4     8
      4 x   4     9

### Oblivion - Textures - Compressed.bsa

    textures\faces\oblivion.esm\00023f2e_1.dds
     px x  px  mip level
     32 x  32     1
     16 x  16     2
      8 x   8     3
      4 x   4     4
      4 x   4     5
      4 x   4     6

### Oblivion - Meshes.bsa

    meshes\characters\imperial\headhuman.egm
    meshes\characters\imperial\headhuman.egt
    meshes\characters\imperial\headhuman.nif
    meshes\characters\imperial\headhuman.tri
    meshes\characters\imperial\headhuman_50.egm
    meshes\characters\imperial\headhuman_50.egt
    meshes\characters\imperial\headhuman_50.nif
    meshes\characters\imperial\headhuman_50.tri

### Oblivion - Misc.bsa

    facegen\si.ctl (not sure how to use the control data)

`headhuman.egt` has 256 rows and 256 columns. There are 50 symmetric morph modes and 0 asymmetric ones.  The texture basis version is 0x51 = 81.

# [14/09/2019 - 13/10/2019 - 28/12/2019]

Posted a [question on the OpenMW form](https://forum.openmw.org/viewtopic.php?f=3&t=3017&start=325) for some help regarding the application of age related texture to `headhuman.dds`

ponyrider0 replied with this suggestion:

```cpp
(base texture) * (age map / 64) = (composited face texture)

(age map) = (composited face texture / base texture) * 64
```

# [11/02/2020] finally getting back to work

```cpp
mNpc->mFormId   = 0x0001C458
mNpc->mEditorId = "BeggarICMarketSimplicia"

mNpc->mFormId   = 0x00023F2E
mNpc->mEditorId = "UrielSeptim"
```

## EGM
A binary format containing the principal component modes as one standard deviation vertex deltas.
See [fileformats](https://facegen.com/dl/sdk/doc/manual/fileformats.html).

    char[8]               Magic number for this filetype: 'FREGM002'
    unsigned long         Number of vertices (V) (Should equal V+K in TRI file)
    unsigned long         Number of symmetric morph modes (S)
    unsigned long         Number of asymmetric morph modes (A)
    unsigned long         Geometry Basis Version
    char[40]              Reserved
    (float+(short*3)*V)*S Symmetric morph mode data for each vertex and all modes.
                          For each mode in S,
                          Start with a floating point scale value x
                          For each vertex in V,
                          The morph values are stored as 3 signed short m. The actual morph values should be m * x.
    (float+(short*3)*V)*A As above for the asymmetric morph modes.

`openmw/apps/openmw/mwrender/foreignnpcanimation.cpp`

```cpp
const std::vector<Ogre::Vector3>& vertices = tri.getVertices(); // V + K

const std::vector<float>& sCoeff = mNpc->mSymShapeModeCoefficients;
const std::vector<float>& aCoeff = mNpc->mAsymShapeModeCoefficients;
const std::vector<float>& sRaceCoeff = mRace->mSymShapeModeCoefficients;
const std::vector<float>& aRaceCoeff = mRace->mAsymShapeModeCoefficients;

Ogre::Vector3 sym;
Ogre::Vector3 asym;
std::vector<Ogre::Vector3> fgVertices;
fgVertices.resize(tri.getNumVertices());
for (size_t i = 0; i < fgVertices.size(); ++i)
{
    sym = Ogre::Vector3::ZERO;
    for (size_t j = 0; j < 50; ++j) // for TES4 always 50 sym modes
    {
        sym += (sRaceCoeff[j] + sCoeff[j])  * egm.mSymMorphModes[50*i + j];
        //            ^             ^                 ^
        //            |             |                 |
        //          float         float           Ogre::Vector3
        //          race          npc_            EGM for the mesh
        //          (guess)                       (scaled for mode j)
    }

    asym = Ogre::Vector3::ZERO;
    for (size_t k = 0; k < 30; ++k) // for TES4 always 30 asym modes
    {
        asym += (aRaceCoeff[k] + aCoeff[k]) * egm.mAsymMorphModes[30*i + k];
    }

    fgVertices[i] = vertices[i] + sym + asym;
    //                  ^           ^     ^
    //                  |            \   /
    //                 TRI       race, npc_ & EGM (at i)
}
```

## EGT

Base texture example: `Textures\Characters\imperial\headhuman.dds`


# [13/02/2020] Trying to remember how the code works

`NiModel` is created using `NiModelManager`. e.g.:

```cpp
NiModelPtr npcModel = NiBtOgre::NiModelManager::getSingleton().getOrLoadByName(model, group);
```

Often it is created in the constructor of `BtOgreInst`.

`NiObjects` are constructed in `NiModel::loadImpl()` and stored in `NiModel::mObjects`.  The NIF file should already be opened via `NiStream` created in the constructor of `NiModel`.

The constructor of the each of `NiObjects` read the NIF file stream and populate various data structures in advance for the actual instantiation of the object at a later point in time.

# [16/02/2020] Refactor code generating the body parts

See `openmw/apps/openmw/mwrender/foreignnpcanimation.cpp`:

For TES4, ESM/ESP specify the game based on the resources in the BSA (or loose) files.  The graphics and physics models for a given scene needs to be constructed and passed onto the respective engines for rendering, collisions, etc.

When a character is placed into a scene we do a few extra things compared to a static (or Havok based) objects.

  * A character has a set of animations some of which may get played depending on the character's current movements.
  * A character with animations will have a skeleton.
  * A character is usually made from several parts - head, hair, hands, clothes/armour, weapons, etc.
  * A character's race and it's own data (`npc_` record) will determine which mesh and texture to use.  For weapons/armour/etc, the character's currently equipped inventory will be visible.
  * Many of the parts will be "skinned".
  * For some body parts FaceGen will be used to create unique, but realistic appearances.

i.e. the specified skeleton, inventory, body parts, etc need to be sourced from NIF and other resources to be ready for instantiation by the rendering engine.

It should be noted that the resource "templates" (for the want of a better description) may be used by many different characters or objects.  They need to be managed by resource managers some kind (even if it is a simple static map).

Obviously, care needs to be taken in creating these resource "templates" so that executing the same piece of calculations is avoided or minimised.  In some cases it may be worth ordering the data structures so that cache misses are minimised.

# [17/02/2020] Refactor FaceGen related code

    stat morph vertices in TRI
    0x4fb + 0x1cd = 461
    npc_::hairlength

Each of `npc_::mHair` are present in `hair` records.  I guess to be safe the race default should be checked if it is not found.

# [17/02/2020] `FindFFmpeg.cmake` seems to be broken

Thought that was fixed?  Had to manually delete the component include directories from MSVC properties.  This happened after checking out an old branch to test something.

# [18/02/2020] Hair and Eyes

Most of the hair found in the BSA files are used in the game, except maybe below:

    Characters\Hair\Emperor.nif/egm
    Characters\Hair\NordFemaleBunches.nif/egm/tri
    Characters\Hair\OrcFemaleBunches.nif/egm/tri

Some of the hairs in the BSA files do not have a corresponding TRI file.  For these, it may be necessary to get the vertices from the NIF files.

    Characters\Hair\Blindfold.NIF
    Characters\Hair\Emperor.nif
    Characters\Hair\KhajiitEarrings.NIF
    Characters\Hair\Style07.NIF

So the method of getting the files should be:

  * get mHair and mEyes from `NPC_`
  * find the mesh and texture file names from HAIR and EYES
    - if not found, get the default hair (male/female `FormId`) and eyes (left/right mesh) from the corresponding RACE
    [07/03/20] RACE doesn't have default eyes, just some choices - possibly need to select a random one.
  * for EYES the mesh name is only in the RACE records (but not the texture nor the EYE `FormId`)
    [07/03/20] this no longers makes sense - what was I thinking?
  * the corresponding EGM and TRI files should be in the same directory as the mesh (EGT not used?)
  * for some HAIR the corresponding TRI files are not present in the BSA - maybe try to get the vertices from the mesh

# [22/02/2020] Hair textures

Noticed that some hair textures have 4 different files in a set:

    grey.dds
    grey_hh.dds
    grey_hl.dds
    grey_n.dds

Also noticed that the decompiled [shaders](https://github.com/Alenett/TES-Shaders) that the following textures are used:

    sampler2D AnisoMap   : register(s3);
    sampler2D DiffuseMap : register(s0);
    sampler2D HeightMap  : register(s2);
    sampler2D LayerMap   : register(s5);
    sampler2D NormalMap  : register(s1);

Diffuse (`*.dds`) and normal (`*_n.dds`) are easy enough but which ones are Aniso/Height/Layer?

Some [clues](https://www.nexusmods.com/skyrim/mods/30745?tab=posts) on the different texture maps:

    >  Edit : Here's more information on the types of textures used in skyrim :
    >
    >  in a "menu"-folder: User-interface element, alpha is element-mask
    >  in a "landscapelod"- or "terrain"-folder: World-space normal-map for terrain, no alpha
    >  "_n"-suffix: Tangent-space normal-map, alpha is specularity
    >  "_msn"-suffix: Model-space normal-map, no alpha
    >  "_g"-, "_glow"- or "_emit"-suffix: Glow-map, alpha is a mask
    >  "_hh"-suffix: Gloss-map for hair, no alpha
    >  "_hl"-suffix: Detail-map for hair, alpha is opacity
    >  "_m"-suffix: Reflectivity-map for light-sources, no alpha
    >  "_em"- or "_envmap"-suffix: Reflectivity-map for environment-maps, no alpha
    >  "_e"-suffix: Environment-map (some are planar, some are cube-maps), no alpha
    >  "_b"- or "_bl"-suffix: Backlight-map, no alpha
    >  "_s"-suffix: Specularity-map for skins, no alpha
    >  "_sk"-suffix: Tone-map for skins, no alpha
    >  "_p"-suffix: Parallax-map, no alpha
    >  "_d"-suffix: Diffuse-map, alpha is opacity
    >  "_h"-suffix: Haze-map, alpha is unknown
    >  All others are color-map, alpha is opacity or parallax

Initial guesses are:

    AnisoMap:  alpha channel of `_n.dds`
    HeightMap: `_hh.dds`  (hair heightmap?)
    LayerMap:  `_hl.dds`  (hair layermap?)

`PSHairTint` is probably `Npc::mHairColour`

# [22/02/2020] Which Shaders?

Wasn't sure if the [shaders from Alenett](https://github.com/Alenett/TES-Shaders) was the same as the official ones (e.g. shaderpackage013.sdp).  Tried to decompile them using [TimeSlip's tool](http://timeslip.chorrol.com/current/ShaderEdit.7z) but even running from Windows XP mode on a Windows 7 PC the program crashes (maybe missing .NET version 2.0).

But this post from [juhana](https://forums.uesp.net/viewtopic.php?f=10&t=6955) gave a hint on how to read the file.  Using [xvi32](http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm) the number of shaders is 0x028D or 653.

    cc9c@LAPTOP-Q4SRRS0H:~/dev/src/TES-Shaders/OblivionShaders
    $ ls Disassembly/ | wc -l
    653

Looks like we're not missing anything, although I'm still not sure if different shader packages have slightly different implentations based on the detected GPU capabilities.

# [27/02/2020] Back to `Ogre::Resources`

## Past Week on Shaders

Spent the past week on reading up various aspects of Oblivion shaders.  Long story short - for now I will have to create a new material, say hair.mat (to fit in with `Shiny` naming scheme) and implement the shaders.  Once I am in a position to move to Ogre 2.1 then I will need to revisit the code since HLMS will come into pay.

## Manual loading of Resources

Can't quite figure out the right paradigm for auto-loading the resources.  So for now I will go ahead and load the morphed resources manually.

## Which Resources to manage?

We already have `Ogre::TextureManager`, `Ogre::MeshManager` and `NiModelManager`.  Not keen to introduce any more.

But what about the use of `Ogre::MaterialManager`?  It normally expects to load the materials from the material scripts but we will need to use manual loading instead.

`Ogre::ManualResourceLoader` can be implemented in different ways.  Ogre itself has a few examples.  The `MeshManager` way is probably the right fit here.

### Let the Resource inherit from `Ogre::ManualresourceLoader`

                     Resource   ManualResourceLoader
                          ^        ^
                           \      /
                            \    /
                             Font

### Let the ResourceManager inherit from `Ogre::ManualResourceLoader`

    ResourceManager  Singleton<MeshManager>  ManualResourceLoader
               ^               ^                ^
               |               |                |
               +----------     |     -----------+
                          \    |    /
                           \   |   /
                          MeshManager

## NiModelManager

Normally specifying the NIF file to NiModelManager will be enough.  The mesh, sub-mesh and material details specified in the NIF file are then used to create the Ogre resources and the respective managers are called during the build of the NIF model.  But we now need to supply additional info to create the morphed resources (the morphed vertices for the mesh/sub-mesh and the morphed texture for the material).

The typical way to get a `NiModel` is to call `NiModelManager::getOrLoadByName()`.  However we don't want to create morphed resources each time so we should overload `getByName()` then afterwards use `create()` and `load()`.

# [28/02/2020] Consider creating NiMaterialManager

The materials used in NIF models are not loaded from material scripts and are most likely (always?) manually loaded.  `NiMaterialManager` can inherit from `Ogre::MaterialManager` and `Ogre::ManualResourceLoader`.

One possibility is to pass on the `FormId` of the resource in a string so that the manual resource loader can get the required details for the resource.  But this means the resource loader will need to know about the implementation of the asset store (tight coupling).  Perhaps the class can be further specialised to provide implementations to pure virtual functions?  e.g. `findFromStore()`

# [28/02/2020] What FaceGen resource management do we need?

In summary we need the base model (NIF file), base texture, Npc record (for FGGS, etc) and Race record (again, FGGS, etc).

__TODO:__ It is unclear if the properties in the NIF should be used in creating the material.

  Record              | Data
  --------------------|-----
  Npc                 | FGGS, FGTS, FGGA, mRace, mHair, mEyes
  Race                | FGGS, FGTS, FGGA, mHeadParts (models and textures except for eyes), mBodyParts (body texture), mData (flags)
  Hair                | mModel (model), mIcon (texture), mData (flags)
  Eyes                | mIcon (texture), mData (flags)
  Clothing (only hood)| mModelMale/mModelFemale (model), mIconMale/mIconFemale (texture), mClothingFlags
  Armor (only helmet) | mModelMale/mModelFemale (model), mIconMale/mIconFemale (texture), mArmorFlags

## Helmets and Hoods

Not sure how we identify hood & helmet - possibly by checking mArmorFlags/mClothingFlags.  The following armor/clothing in Oblivion.esm have __only__ the `ESM4::Race::TES4_Hair` slot indicated in mArmorFlags/mClothingFlags (NOTE: only the bottom 16 bits are relavant) - looks like all of them?

[//]: # (                                                             {{{
    SEAmberMagicHelmet2
    SEAmberMagicHelmet1
    SEAmberHelmet2
    SEAmberHelmet1
    SEDarkSeducerOfficerHelmet1
    SEDarkSeducerOfficerHelmet2
    SEDarkSeducerOfficerHelmet3
    SEDarkSeducerOfficerHelmet4
    SEDarkSeducerOfficerHelmet5
    SEDarkSeducerOfficerHelmet6
    SEGoldenSaintOfficerHelmet1
    SEGoldenSaintOfficerHelmet2
    SEGoldenSaintOfficerHelmet3
    SEGoldenSaintOfficerHelmet4
    SEGoldenSaintOfficerHelmet5
    SEGoldenSaintOfficerHelmet6
    SETEST07ADarkSeducerEliteHelmet
    SETESTDarkSeducerOfficerHelmet
    SETESTGoldenSaintOfficerHelmet
    SEGoldenSaintHelmetReward6Daedric
    SEGoldenSaintHelmetReward5Ebony
    SEGoldenSaintHelmetReward4Orcish
    SEGoldenSaintHelmetReward3Dwarven
    SEGoldenSaintHelmetReward2Steel
    SEGoldenSaintHelmetReward1Iron
    SEDarkSeducerHelmetReward6Glass
    SEDarkSeducerHelmetReward5Elven
    SEDarkSeducerHelmetReward4Mithril
    SEDarkSeducerHelmetReward3Chain
    SEDarkSeducerHelmetReward2Leather
    SEDarkSeducerHelmetReward1Fur
    SE07ThadonsCrown30
    SE07ThadonsCrown25
    SE07ThadonsCrown20
    SE07ThadonsCrown15
    SE07ThadonsCrown10
    SE07ThadonsCrown05
    SE07ThadonsCrown01
    SETESTSaintHelmet
    SETESTHelmet
    SE07ADarkSeducerEliteHelmet
    SEDarkSeducerOfficerHelmet
    SEGoldenSaintOfficerHelmet
    SEEnchOrcishHelmetNighteye
    SEEnchSteelHelmetResistMagicka
    SEEnchMithrilHelmetNighteye
    SEEnchChainmailHelmetDetectLife
    SEEnchLeatherHelmetResistMagic
    SEEnchFurHelmetFortMagicka
    SEGoldenSaintHelmet6Daedric
    SEGoldenSaintHelmet5Ebony
    SEGoldenSaintHelmet4Orcish
    SEGoldenSaintHelmet3Dwarven
    SEGoldenSaintHelmet2Steel
    SEDarkSeducerHelmet6Glass
    SEDarkSeducerHelmet5Elven
    SEDarkSeducerHelmet4Mithril
    SEDarkSeducerHelmet3Chain
    SEDarkSeducerHelmet2Leather
    SEDarkSeducerHelmet1Fur
    SEGoldenSaintHelmet1Iron
    SEAmberMagicHelmet6
    SEAmberMagicHelmet5
    SEAmberMagicHelmet4
    SEAmberMagicHelmet3
    SEAmberHelmet6
    SEAmberHelmet5
    SEAmberHelmet4
    SEAmberHelmet3
    SE12GnarlWidget
    SE12OrderWidget
    DAUmbraHelmet15
    DAUmbraHelmet9
    PitHelmet
    TG11ElvenHelmet
    replicaElvenHelmet
    UniqueOrcishHelmFerocity
    BladesHelmetAncient
    MS27LindaiAyleidCrown05
    MS27NenalataAyleidCrown25
    MS27NenalataAyleidCrown20
    MS27NenalataAyleidCrown15
    MS27NenalataAyleidCrown10
    MS27NenalataAyleidCrown05
    MS27LindaiAyleidCrown25
    MS27LindaiAyleidCrown20
    MS27LindaiAyleidCrown15
    MS27LindaiAyleidCrown10
    ArenaBladesHelmet
    ArenaEbonyHelmet
    ArenaOrcishHelmet
    ArenaSteelHelmet
    ArenaIronHelmet
    ArenaGlassHelmet
    ArenaElvenHelmet
    ArenaMithrilHelmet
    ArenaLeatherHelmet
    ArenaFurHelmet
    ImperialDragonHelmetLight
    ImperialDragonHelmetHeavy
    LegionHelmet
    DarkFinGleam
    BloodwormHelm25
    BloodwormHelm20
    BloodwormHelm15
    BloodwormHelm10
    BloodwormHelm05
    DarkCaeliaHelmet
    CGIronHelmet
    ImperialPalaceHelmet
    CGLeatherHelmetBandit
    FGC07AmelionHelmet
    MS27LindaiAyleidCrownBroken
    FGD09BearclawHelm
    MS27NenalataAyleidCrown01
    MS27LindaiAyleidCrown01
    ArenaChainmailHelmet
    EnchEbonyHelmetWaterbreathing
    EnchEbonyHelmetResistMagicka
    EnchEbonyHelmetDetectLife
    EnchOrcishHelmetWaterbreathing
    EnchOrcishHelmetNighteye
    EnchOrcishHelmetFortMagicka
    EnchOrcishHelmetDetectLife
    EnchSteelHelmetWaterbreathing
    EnchSteelHelmetResistMagicka
    EnchSteelHelmetFortMagicka
    EnchSteelHelmetDetectLife
    EnchIronHelmetWaterbreathing
    EnchIronHelmetResistMagicka
    EnchIronHelmetDetectLife
    EnchIronHelmetFortMagicka
    EnchGlassHelmetResistMagicka
    EnchGlassHelmetDetectLife
    EnchElvenHelmetResistMagicka
    EnchElvenHelmetDetectLife
    EnchMithrilHelmetResistMagicka
    EnchMithrilHelmetNighteye
    EnchMithrilHelmetFortMagicka
    EnchMithrilHelmetDetectLife
    EnchChainmailHelmetResistMagicka
    EnchChainmailHelmetNighteye
    EnchChainmailHelmetFortMagicka
    EnchChainmailHelmetDetectLife
    EnchLeatherHelmetResistMagic
    EnchLeatherHelmetFortMagicka
    EnchLeatherHelmetDetectLife
    EnchFurHelmetResistMagicka
    EnchFurHelmetFortMagicka
    EnchFurHelmetDetectLife
    EnchEbonyHelmetMage
    EnchMithrilHelmetMind
    BlackwoodHelmet
    BladesHelmetCG
    MG10ElvenHelmet
    EmperorHelmet
    BloodwormHelm01
    EbonyHelmet
    OrcishHelmet
    GlassHelmet
    DBLeatherHelmet
    MithrilHelmet
    TownguardHelmet
    LegionHelmetOld
    FurHelmet
    BladesHelmet
    LeatherHelmet
    ChainmailHelmet
    IronHelmet
    ElvenHelmet
    SteelHelmet
    SEZealotHood
    SEHereticHood
    UniqueClothingHoodDiplomat
    UniqueClothingHoodGatherer
    UniqueClothingHoodSeer
    UniqueClothingHoodDruid
    UpperRobe03hood
    UpperRobe02hood
    LowerRobe05hood
    LowerRobe04hood
    LowerRobe03hood
    MGRobeHood
    DBBlackHandHood
    BlackHood
    MageHood
    ArchMageHood
    KingofWormsHood
    NecromancerHood
    LowerRobe02hood
    MythicDawnRobeHood
    TGGrayFoxCowl                                                     }}})

## Resource naming convension

  Resource Type    | Naming Convension
  -----------------|------------------
  Mesh             | base model + skeleton name + # + NiNode index + @ + NiNode name (see note 1 below)
  Mesh (proposed)  | skeleton name + _ + base model + # + NiNode index + @ + NiNode name
  Texture          | base texture (specified in the NIF for the sub-mesh)
  Material         | base model + @ + NiTriBasedGeom name (each sub-mesh has its own material, see note 2 below)
  NiModel          | base model
  Morphed Mesh     | NPC name + _ + base model + @ + NiNode name
  Morphed texture  | NPC name + _ + base texture
  Morphed Material | NPC name + _ + base model + @ + NiTriBasedGeom name
  Morphed NiModel  | NPC name + _ + base model

Note that, unlike other objects, FaceGen morph NIF models have __exactly one__ NiNode with a `NiTriBasedGeom`.  i.e. one mesh  This means that the resources (mesh/materail/model) can't be reused.

__NOTE 1:__ In TES5 `Architecture\Solitude\SolitudeBase.nif` has several NiNode instances with the same name.  Hence _both_ NiNode index and NiNode name are needed in the mesh name.  Just the index is enough but for now it is easier for debugging if the NiNode name is also present.

__NOTE 2:__ Material name may not match the actual NIF or NiTriBasedGeom (the same material from another model will be used if found).

## Putting it all together for `NiModel`

```cpp
NiBtOgre::NiModelManager& modelManager = NiBtOgre::NiModelManager::getSingleton();

// nif and texture are resource path + filename + ext
// the logic to locate nif & texture are hard coded
std::string name = mNpc->mEditorId + "_" + nif;

// the logic to locate the FaceGen files are hard coded
NiModelPtr morphedModel = modelManager.getByName(name);
if (morphedModel.isNull())
    morphedModel = modelManager.createMorphedModel(nif, "General", mNpc, mRace, texture);
```

The diagram from 01/01/2018 needs to be updated:

       ResourceManager   Singleton<NiModelManager>   ManualResourceLoader
                ^                    ^                    ^
                |                    |                    |
                +---------------+    |    +---------------+
                                |    |    |
                                |    |    |           Resource
                                |    |    |           ::load()
                                |    |    |              ^
                               NiModelManager            |
                               ::createImpl()  .....  NiModel
                               ::loadResource()       ::loadImpl()
                                                      ::unloadImpl()
                                                      ::prepareImpl()
                                                      ::unprepareImpl()


`NiModel::prepareImpl()` creates the NIF data stream and reads the header.  `NiModel::unprepareImpl()` undos `prepareImpl()`.  These are only called by `Ogre::Resource::load()` if NiModel is not manually loaded.

__TODO:__ check if we have to call `prepareImpl()` for manual loading as well?

__NOTE:__ consider changing `prepareImpl()` s.t. the NIF file is pre-buffered similar to `Ogre::Mesh::prepareImpl()`.  Below method implements the pre-buffering:

```cpp
Ogre::MemoryDataStream::MemoryDataStream(const String& name,
                                         const DataStreamPtr& sourceStream,
                                         bool freeOnClose = true,
                                         bool readOnly = false )
```

`NiModel::loadImpl()` parses the NIF data stream to create the objects.

Simplified interaction diagram for NiModel retrieving and manual loading sequences:
__NOTE:__ NiModel is loaded immediately upon creation (like manual loading Ogre::Mesh).

        application    NiModelManager    ResourceManager   ManualResourceLoader   Resource
            |                 |                   |                 |                 |
            | getByName()     |                   |                 |                 |
            |---------------->|                   |                 |                 |
            |                 |getResourceByName()|                 |                 |
            |                 |------------------>|                 |                 |
            |                 |         Resource* |                 |                 |
            |      NiModelPtr |<------------------|                 |                 |
            |<----------------|                   |                 |                 |
            :                 :                   :                 :                 :
            :                 :                   :                 :                 :
            | createMorphedModel()                |                 |                 |
            |---------------->|                   |                 |                 |
            |                 |--+                |                 |                 |
            |                 |  | createManual() |                 |                 |
            |                 |<-+                |                 |                 |
            |                 |--+                |                 |                 |
            |                 |  | create()       |                 |                 |
            |                 |<-+                |                 |                 |
            |                 | createResource()  |                 |                 |
            |                 |------------------>|                 |                 |
            |                 |      createImpl() |                 |                 |
            |                 |<------------------|                 |                 |
            |                 | load()            |                 |                 |
            |                 |------------------------------------------------------>|
            |                 |                   |                 |  loadResource() |
            |                 |                   |  loadResource() |<----------------|
            |                 |<------------------------------------|                 |
            |                 |--+                |                 |                 |
            |                 |  | ...            |                 |                 |
            |      NiModelPtr |<-+                |                 |                 |
            |<----------------|                   |                 |                 |
            |                 |                   |                 |                 |


# [29/02/2020] Redesign mesh loading

Currently `Ogre::Mesh` is created and loaded _only_ when an `Ogre::Entity` is instantiated.  That means, at least with the current design, NiModel is not fully built after `load()`.  It also means that any `Ogre::Material` used by the meshes are not created/loaded, either.

So, if we are to retain our current design, any morphed vertices or textures need to be prepared for loading the meshes and/or material at a later point in time.

For the morphed vertices, we can directly modify the vertices read in from the NIF file.  The vertices are read and stored from the constructor (in `NiGeometryData::mVertices` as `std::vector<Ogre::Vector3>`).

__TODO:__ Current design uses the vertices from the TRI file, if available, rather than the one from the NIF.  These are slightly different (see `Characters\Imperial\HeadHumah.TRI`).  Alternatively, both sets of vertices could be stored at the cost of some memory so that the solution can be fine tuned later.

__FIXME:__ Should the normals, tangents and bitangents in NiGeometryData be re-calculated once the vertices are morphed?

Current design:

        BtOgreInst   Ogre::MeshManager    NiModel             NiNode        NiTriBasedGeom
           |               |                |                   |                 |
           |               |                |                   |                 |--+
           |               |                |                   |registerSubMesh()|  | ctor
           |               |                |       insert      |<----------------|  |
           |               |                |  mMeshBuildList[] |                 |<-+
           |               |                |<------------------|                 |
           :               :                :                   :                 :
           :               :                :                   :                 :
           | instantiate() |                |                   |                 |
           |------------------------------->|                   |                 |
           |               |                |--+                |                 |
           |               |                |  |                |                 |
           |               |                |<-+                |                 |
           |               |                |                   |                 |
           |               | createManual() |--+                |                 |
           |               |<---------------|  |                |                 |
           |               |                |<-+ loop           |                 |
           |               |                |  mMeshBuildList[] |                 |
           |               |                |                   |                 |


Proposed change:

        BtOgreInst   Ogre::MeshManager    NiModel             NiNode        NiTriBasedGeom
           |               |                |                   |                 |
           |               |                |                   |                 |--+
           |               |                |                   |registerSubMesh()|  | ctor
           |               |                |       insert      |<----------------|  |
           |               |                |  mMeshBuildList[] |                 |<-+
           |               |                |<------------------|                 |
           |               |                |--+                |                 |
           |               |                |  | ...            |                 |
           |               |                |<-+                |                 |
           |               |                |                   |                 |
           |               | createManual() |--+                |                 |
           |               |<---------------|  |                |                 |
           |               |                |<-+ loop           |                 |
           |               |                |  mMeshBuildList[] |                 |
           :               :                :                   :                 :
           :               :                :                   :                 :
           | instantiate() |                |                   |                 |
           |------------------------------->|                   |                 |
           |               |                |                   |                 |


Rather than creating a new resource manager based on `Ogre::MeshManager`, we can try creating NiMeshLoader as a singleton.

NiModel is either created from the NIF file, via `NiModel::loadImpl()`, or manually via `NiModelManager::createMorphedModel()` and `NiModelManager::loadResource()`.  In former case, the NIF file name can be deduced from the mesh name by takeing away the skeleton name (if any) and the NiNode name.  In latter case, re-loading the NiModel appears a little more difficult.

__IDEA:__ It might be possible to get Ogre to do most of the work - maybe just remember the resource name and get NiModelPtr from NiModelManager singleton?  Or just save a `NiModel*` and use it during `loadResource()`.

Simplified create and load interactions of NiMeshLoader:

        application      MeshManager   ResourceManager NiMeshLoader  ManualResourceLoader  Resource
            |                |                  |           |                |                |
            | createXXXXXX() |                  |           |                |                |
            |---------------------------------------------->|                |                |
            |                |               createManual() |                |                |
            |                |<-----------------------------|                |                |
            |                | createResource() |           |                |                |
            |                |----------------->|           |                |                |
            |                |     createImpl() |           |                |                |
            |                |<-----------------|           |                |                |
            |                | new Mesh         |           |                |                |
            |                |----------------->|           |                |                |
            |                |           Mesh*  |           |                |                |
            |                |<-----------------|           |                |                |
            |                | MeshPtr          |           |                |                |
            |                |----------------------------->|                |                |
            |                |                  |           |--+ store       |                |
            |                |                  |           |  | param       |                |
            |                |                  |   MeshPtr |<-+             |                |
            |<----------------------------------------------|                |                |
            :                :                  :           :                :                :
            :                :                  :           :                :                :
            |--------------->|                  |           |                |                |
            |                | load()           |           |                |                |
            |                |--------------------------------------------------------------->|
            |                |                  |           |                | loadResource() |
            |                |                  |           | loadResource() |<---------------|
            |                |                  |           |<---------------|                |
            |                |                  |           |--+             |                |
            |                |                  |           |  | ...         |                |
            |                |                  |           |<-+             |                |
            |                |                  |           |                |                |


## ToDo

  * Mesh and Material creation parts from NiModel should be moved to the loading stage.  i.e. at least create the meshes during NiModel load stage - currently the meshes are created during instantiation

  * Need to fix `SkeletonLoader` and `BtRigidBodyCIManager`.

# [01/03/2020] Material

## FaceGenMap in shaders

Looking at the decompiled [shaders](https://github.com/Alenett/TES-Shaders) again and noticed that all of the ones with FaceGenMap have 2 of them.  Most of them are numbered 0 and 1, e.g. FaceGenMap0, FaceGenMap1.  One of them must be the NPC specific detail map in `textures\faces\oblivion.esm`.  But what is the other one?  It must be either the second, smaller detail map in the same directory (`DXGI_FORMAT_BC3_UNORM`, 32x32 only) or the age-based detail texture for headhuman.dds (`DXGI_FORMAT_BC1_UNORM`, 256x256).

Either way, still need to figure out how to determine the NPC's age just by examininig their FGGS and/or FGTS.  See previous notes from 09/09/2019.

The normal map for `headhuman.dds` must be age-based as well? (i.e. replace, not merge with `headhuman_n.dds`)

__TODO:__ experiement and compare the in-game visuals

## NPC Age

Figured out how to get the NPC age value.

# [02/03/2020] Commit the changes since 17/02/2020

  * equipment slot handling as per OpenMW's implementation
  * moved FaceGen code to extern/fglib
  * FaceGen NPC age
  * redesigned resource management for `NiModel` and `NiMesh` (still to fix `Skeleton` and `BtRigidBodyCI`)

## SkeletonLoader

Make `SkeletonLoader` work the same way as NiMeshLoader.  Not too happy about creating so many singletons, however.  Is there another way to ensure the skeleton manual loader to hang around?

There are 3 different use cases for skeletons.

  1. An NiModel may need to build a skeleton to animate the entities/meshes in the Model.
  2. An NiModel may be "skinned", i.e. depends on an external skeleton (see below).  __NOTE:__ there may be several different skeletons, so there needs to several different NiModels even with the same base NIF.
  3. An NiModel may be a skeleton itself.  In TES4, BSX flag will indicate if a NIF is a skeleton.

## `MWRender::Animation::setObjectRoot()`

`ESM4::Npc::mModel` for TES4 or `ESM4::Race::mModelMale`/`ESM4::Race::mModelFemale` for TES5 are the skeletal models for an NPC.

# [03/03/2020] Skeletons

Manual creation for a skeleton `NiModel`:

        application    NiModelManager       NiModel        NiNode    NiSkeletonLoader  Ogre::Skeleton
          |               |                   |              |               |                |
          | getByName()   |                   |              |               |                |
          |-------------->|                   |              |               |                |
          |    NiModelPtr |                   |              |               |                |
          |<--------------|                   |              |               |                |
          |               |                   |              |               |                |
          |createSkeletonModel()              |              |               |                |
          |-------------->|                   |              |               |                |
          |               |                   |              |               |                |
          |               | load()            |              |               |                |
          |               |------------------>|              |               |                |
          |               | loadResource()    |              |               |                |
          |               |<------------------|              |               |                |
          |               |                   |              |               |                |
          |               | createNiObjects() |              |               |                |
          |               |------------------>|              |               |                |
          |               |                   |              |               |                |
          |               |buildFullSkeleton()|              |               |                |
          |               |------------------>|              |               |                |
          |               |                   | createFullSkeleton()         |                |
          |               |                   |----------------------------->|                |
          |               |                   |    Ogre::SkeletonPtr         |                |
          |               |                   |<-----------------------------|                |
          |               |                   |              |               |                |
          |               |                   | load()       |               |                |
          |               |                   |---------------------------------------------->|
          |               |                   |              |               | loadResource() |
          |               |                   |              |               |<---------------|
          |               |                   |              | addAllBones() |                |
          |               |                   |              |<--------------|                |
          |               |                   |              | createBone()  |                |
          |               |                   |              |------------------------------->|
          |               | createDummyMesh() |              |               |                |
          |               |------------------>|              |               |                |
          |               |                   |              |               |                |


Creation for a normal `NiModel`:
__NOTE:__ `createSkeleton()` is currently triggered by build() which seems too late
__NOTE:__ `createSkeleton()`/`addBones()` uses `NiNode::mChildBoneNodes` whereas `createFullSkeleton()`/`addAllBones()` uses `NiNode::mChildren`

        application    NiModelManager    NiModel            NiNode   NiSkeletonLoader  Ogre::Skeleton
          |               |                |                  |              |                |
          |getOrLoadByName()               |                  |              |                |
          |-------------->|                |                  |              |                |
          |               | load()         |                  |              |                |
          |               |--------------->|                  |              |                |
          |               |                |--+ prepareImpl() |              |                |
          |               |                |<-+               |              |                |
          |               |                |                  |              |                |
          |               |                |--+ loadImpl()    |              |                |
          |               |                |  |               |              |                |
          |               |                | createNiObjects()|              |                |
          |               |                | buildBones()     |              |                |
          |               |                |  | findBones()   |              |                |
          |               |                |  | ------------->|--+           |                |
          |               |                |<-+              mChildBoneNodes |                |
          |               |                |                  |<-+           |                |
          :               :                :                  :              :                :
          :               :                :                  :              :                :
          | build()       |                |                  |              |                |
          |------------------------------->|                  |              |                |
          |     ^         |                | createSkeleton() |              |                |
          |     |         |                |-------------------------------->|                |
          |   remove      |                |    Ogre::SkeletonPtr            |                |
          |    call       |                |<--------------------------------|                |
          |               |                |                  |              |                |
          |               |                | load()           |              |                |
          |               |                |------------------------------------------------->|
          |               |                |                  |              | loadResource() |
          |               |                |                  |              |<---------------|
          |               |                |                  | addBones()   |                |
          |               |                |                  |<-------------|                |
          |               |                |                  | createBone() |                |
          |               |                |                  |------------------------------>|
          |               | createMesh()   |                  |              |                |
          |               |--------------->|                  |              |                |
          |               |                |                  |              |                |


__NOTE:__ After all that effort, the new method of using `createFullSkeleton()/addAllBones()` turned out to be inferior and had to revert to using `createSkeleton()/buildSkeletion()/addBones()` even for skeleton.nif, etc.

# [04/03/2020] Trying to get doors working again.

  * [15/02/19] af0e502c75c2df5ab8853ef43e38fc60558863b3 doors work
  * [17/02/20] 004a1d72985115fed43acd644f5da8ce2d90d302 doors no longer work

But so much change in a year - don't know where to start.  Looking at the call stack:

    openmw.exe!MWWorld::Scene::searchPtrViaHandle(const std::string & handle) Line 956	C++
    openmw.exe!MWWorld::World::searchPtrViaHandle(const std::string & handle) Line 734	C++
    openmw.exe!MWWorld::World::getPtrViaHandle(const std::string & handle) Line 723	C++
    openmw.exe!MWWorld::World::getFacedObject() Line 1126	C++
    openmw.exe!MWWorld::World::updateWindowManager() Line 1797	C++

Maybe we're not storing the physics handles properly?  Placed a breakpoint at `PhysicEngine::createAndAdjustRagdollBody()` to track `Dungeons\Chargen\impDunDoor02.NIF`:

```cpp
RigidBody* PhysicEngine::createAndAdjustRigidBody(const std::string &mesh, const std::string &name,
```

The comparison of ptr.mRef.mData.mBaseNode.mName with OEngine::Physic::RigidBody::mName is done here:

```cpp
Ptr World::getPtrViaHandle (const std::string& handle)
{
    Ptr res = searchPtrViaHandle (handle);
    if (res.isEmpty ())
        throw std::runtime_error ("unknown Ogre handle: " + handle);
    return res;
}
```

Ok, that means the handle in `InsertFunctor::operator()` (scene.cpp) should be the same as the on returned by `rayTest()` and subsequently getPrtViaHandle().

```cpp
try
{
    addObject(ptr, mPhysics, mRendering);   // <---- check here
    updateObjectLocalRotation(ptr, mPhysics, mRendering);
    if (ptr.getRefData().getBaseNode())
```

It should be noted that RigidBody::mName is the same for __all__ rigid bodies in a NIF.  There are some overly complicated code to handle this.

After some stepping through the debugger, it turns out that the raycast creation was not done, see below:

```cpp
if (objAnim && !objAnim->getPhysicsNodeMap().empty())  // FIXME: this is such a bad hack
{
    mEngine->createAndAdjustRagdollBody(
        mesh, node->getName(), objAnim->getPhysicsNodeMap(), ptr.getCellRef().getScale(), node->getPosition(), node->getOrientation(), 0, 0, false, placeable);
    return;
}
```

## FIXME #1

Index number looks wrong?

    havok meshes\dungeons\chargen\idcrumblewall01.nif#44@IDCrumbleBrick05
    havok meshes\dungeons\chargen\idcrumblewall01.nif#61@IDCrumbleBrick06
    havok meshes\dungeons\chargen\idcrumblewall01.nif#72@IDCrumbleBrick07
    havok meshes\dungeons\chargen\idcrumblewall01.nif#83@IDCrumbleBrick08
    havok meshes\dungeons\chargen\idcrumblewall01.nif#94@IDCrumbleBrick09
    havok meshes\dungeons\chargen\idcrumblewall01.nif#105@IDCrumbleBrick10
    havok meshes\dungeons\chargen\idcrumblewall01.nif#116@IDCrumbleBrick06b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#127@IDCrumbleBrick07b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#138@IDCrumbleBrick08b
    havok meshes\dungeons\chargen\idcrumblewall01.nif#149@IDCrumbleBrick01
    havok meshes\dungeons\chargen\idcrumblewall01.nif#158@IDCrumbleBrick02
    havok meshes\dungeons\chargen\idcrumblewall01.nif#169@IDCrumbleBrick03
    havok meshes\dungeons\chargen\idcrumblewall01.nif#177@IDCrumbleBrick04
    havok meshes\dungeons\chargen\prisonsecretwallswitch01.nif#16@Switch
    havok meshes\dungeons\chargen\prisonsecretwall01.nif#114@bed
    havok meshes\dungeons\chargen\prisonsecretwall01.nif#126@wall
    phantom: meshes\dungeons\misc\triggers\trigzone02.nif
    havok meshes\dungeons\chargen\prisoncelltorch01.nif#0@PrisonCellTorch01
    havok meshes\dungeons\chargen\ropebucket01.nif#75@Bucket
    havok meshes\armor\leather\shield.nif#0@Shield
    havok meshes\dungeons\chargen\cgprisoncellgate01.nif#24@gate01
    havok meshes\dungeons\chargen\cgprisoncellgate01.nif#44@gate02
    havok meshes\dungeons\chargen\idgate01.nif#24@IDGate01b
    havok meshes\dungeons\chargen\idgate01.nif#36@IDGate01c
    havok meshes\architecture\castleinterior\towersmall\castletowerdoor01anim.nif#17@CastleTowerDoor01Anim NonAccum
    havok meshes\dungeons\caves\cdoor03.nif#31@CDoor03 NonAccum
    havok meshes\dungeons\caves\cdoor03.nif#37@Door
    havok meshes\dungeons\caves\cdoor03.nif#49@Door@#0 <- 48?

## FIXME #2

handleToMesh keeps growing!!!  git blame says:

    33fe80723c (Jason Hooks     2012-06-17 20:56:10 -0400)

```cpp
void PhysicsSystem::addObject (const Ptr& ptr, const std::string& mesh, bool placeable)
    handleToMesh[node->getName()] = mesh;
```

## FIXME #3

    // TODO: probably possible to optimise the use of the "group" parameter, e.g. per cell


# [04/03/2020] Finding missing `TrapLogs`

COC "ImperialDungeon05" and look for `Dungeons\Caves\Traps\CTrapLogs01.NIF`.  Found it - it turns out that `CollisoinType_World` had to be added in th flags otherwise the collision shapes don't collide with the floor and sink through.

```cpp
if (!raycasting)
{
    assert (mCollisionObjectMap.find(name) == mCollisionObjectMap.end());
    mDynamicsWorld->addRigidBody(
            //body,CollisionType_World,CollisionType_Actor|CollisionType_HeightMap);
            body,CollisionType_World,CollisionType_World|CollisionType_Actor|CollisionType_HeightMap);
    if (numBodies == 0)
        mCollisionObjectMap[name] = body; // register only the parent
}
```

__The activator is not working, however.__  Activation results in some weird rotation of the logs.

__Also, there is this strange piece of code:__

```cpp
// FIXME
if (lowerMesh.find("traplog") == std::string::npos)
    return createAndAdjustRigidBody(mesh, name, scale, position, rotation, scaledBoxTranslation, boxRotation,   raycasting, placeable);
```

That might be due to the inability to determine whether the rigid bodies are ragdoll or not? __NOTE: 08/03/20__ most likely due to ragdoll being broken, other than the trap logs.

# [05/03/2020] Making progress with `NiModel`

Naming convension needs to be revisited.  A head model may be morphed per NPC's FaceGen coefficients.  However it is alos skinned, meaning it will have an external skeleton.  __NOTE:__ not sure if the external skeleton can be anything other than skeleton.nif for FaceGen head models.

Made progress with morphed models but looks like a redesign is required.  There were some assumptions that may not be correct:

  * Assumed all models that needs to attach to a bone has "Prn" NiStringExtraData - however ears and eyes don't.
  * Assumed it would be ok to use the vertices from the NIF files when the corresponding TRI files do not exist.  However some helmets (e.g. Armor\Blades\M\Helmet.NIF and Armor\LegionHorsebackGuard\Helmet.NIF ) clip the head model when the vertices are morphed this way.  Maybe it is better not to morph if the TRI file does not exist?

Also the codebase has become a spaghetti mess and is rather difficult to follow.

## More code restructuring - model and mesh naming

Initially we may not be certain if the model is skinned - only once the NiObjects created in loadResource we can decide whether the skeleton is needed.  But then it becomes difficult to maintain the model and mesh naming convention where the skeleton name is prepended for skinned models.

One possible solution is to always build a "test" model to see if it is skinned. If it turns out that the model is not skinned, we can go ahead and load it and instantiate it.  If it is skinned then a new model with a different name may be required (but maybe only with equipment that can be shared with multiple types of skeletons?).

For skinned body parts for creatures we don't need to worry about the uniqueness of the model/mesh names.  But then perhaps we are making things more complicated with special handling for creatures, etc.

# [06/03/2020] Continuing...

## FIXME #4

  * TRI file exeption commented out
  * Case folding for skeleton and object names are causing no end of troubles.  For now only fold skeleton names.
  * The use of getSkeletonRoot() in NiSkeletonLoader is not working

## Head parts progress

It turns out that even helmets (not skinned) look better when morphed.  This will make the code a little simpler.

For some reason the parts that attach to `Bip01 Head` require postion and rotation adjustment.

```cpp
if (targetBone == "Bip01 Head")
{
    orientation = bone->getOrientation() * Ogre::Quaternion(Ogre::Degree(90), Ogre::Vector3::UNIT_Y);
    position = Ogre::Vector3(0.45f/*up*/, -0.55f/*forward*/, 0.f/*right*/);
}

```

Some NIF files do not supply the target bone (e.g. eyes, ears).  They just have to be hard coded.

# [07/03/2020] Continuing...

Some ears do have the right rotation (e.g. earskhajiit.nif) and some don't (e.g. eyeslefthuman.nif). So above rotation hack with "Bip01 Head" needs to be further modified.

```cpp
if (targetBone == "Bip01 Head" && baseRotation == Ogre::Quaternion::IDENTITY)
```

## FIXME #5

  * __FIXED:__ crash accessing nullptr (prob. NiModel) during animation - I think this was caused by animation trying to move skeletons but some body parts didn't have skeleton root - we use external skeletons so we don't need this code block that copies bone position/rotaions
  * __FIXED:__ no eyes Cludette Perrick (The Gilded Carafe) - her NPC record does not have mEyes so we need to use the race defaults instead __TODO__ need to remember the random selection so that we don't see a new texture each time.
  * __FIXED: 08/03/20__ one of the metal gates in the IC sewers doesn't move the collision shape (also the display cases)
  * [ESM4::Npc] = {mFormId=0x0004ef6f mFlags=0x00040000 mEditorId="CheydinhalGuardCityPostNight03" ...}
  * __FIXED 08/03/20__ error during rendering: ItemIdentityException: Bone named '' not found. in Skeleton::getBone at C:\Users\cc9c\Dev\src\ogre\OgreMain\src\OgreSkeleton.cpp (line 515) - no ears for Argonians so added a check

## Design notes on body part handling

TES4 allows 16 body parts, FO3/FONV allows 20 and TES5 allows 32 body parts.  The "ForeignNPC" code should be able to deal with all - but to do so it cannot have special handling for a particular body part (or at least, not very many).

Note that the race body parts share the "slots" used by the armor/cloth body parts.  These will need to be translated depending on the game.

Now mObjectParts in ForeignNpcAnimation is a map keyed by `ESM4::Armor::ArmorFlags`.  Note that the keys are not consequitive.  Body parts and weapons will need some translations to get the right keys.

__NOTE:__ TES4/TES5/FO3/FONV can each have different key values for the same slot, where they do have the same slot.  For example "Tail" slot key values between TES4 and TES5 are different.  On the other hand, the "Head" and "Hair" slot key values are the same for all games.

__TODO:__ The inventorystore currently only supports TES4.  Its slot handling is not very well suited for TES4, etc, and will need some changes to make things more efficient.

# [08/03/2020] Testing resource management

Looks like `getResourceByName()` does not retrieve existing resources.  `mResources.find(name)` returns `mResources.end()` even though I can see the resource in mResources using the debugger.

```cpp
ResourcePtr ResourceManager::getResourceByName(const String& name, const String& groupName /* = ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME */)
{
    OGRE_LOCK_AUTO_MUTEX;

    // resource should be in global pool
    bool isGlobal = ResourceGroupManager::getSingleton().isResourceGroupInGlobalPool(groupName);

    if(isGlobal)
    {
        ResourceMap::iterator it = mResources.find(name);
        if( it != mResources.end())
        {
            return it->second;
        }
    }
```

mResources is meant to be an Ogre defined vector type, StringVector which in turn is defined as:

```cpp
template <typename T, typename A = STLAllocator<T, GeneralAllocPolicy> >
struct vector
{
    typedef typename std::vector<T, A> type;
    typedef typename std::vector<T, A>::iterator iterator;
    typedef typename std::vector<T, A>::const_iterator const_iterator;
};
```

That leads to xhash in MSVC - does this mean it might be a compiler bug?

```cpp
_NODISCARD iterator find(const key_type& _Keyval)
    {	// find an element in mutable hash table that matches _Keyval
    return (lower_bound(_Keyval));
    }
```

```cpp
size_t first = str_hash(Ogre::String("BeggarICMarketsSimplicia_" + meshName));
size_t second = str_hash(Ogre::String(mNpc->mEditorId + "_" + meshName));
```

    first   0x5f7b25ae61145ef8  unsigned __int64
    second  0x5fb1324631bf5133  unsigned __int64

Hmmm... this is rather embarassing - it turns out we had a false positive - I simply had mis-spelt the hard coded name for testing.

# [08/03/2020] Physics issues

## Doors

  * __WONTFIX:__ 0x000947B2 gate does not rotate on its edge (well it does, but not right at the edge - it could be just the way the NIF is done)
  * __FIXED:__ 0x0002A5C0 collision shape does not move, `dungeons\sewers\sewertunneldoor01.nif` - in `PhysicsSystem::rotateSubObject` only the parent object was checked for being static object when its child (children?) may not be.
  * __FIXED:__ 0003725e Architecture\ImperialCity\Interior\ICDoorInt01.NIF rotates on the center axis - this particular one turns out to be a static shape, so we can stop the physic shape rotating in rotateObject(), but how to stop the rendering to rotate as well? - resolved by adding a check in processDoors().  Places to test include:
    - COC "KvatchChapelofAkatosh" - go down to the hall and see the wooden doors move
    - COC "ImperialDungeon03" - various gates and doors
    - COW "AnvilWorld" -46 -8 - check the stone wall gate
    - COW "ICMarketDistrict" 8 16 - check the display case then go to the sewers and check the gates and doors
    - COC "WeynonPrioryHouse" - nothing here
  * worldimp::processDoors add collision test

The bone names between the physics system and Ogre are communicated using the NiNode/NiAVObject names.  BtRigidBodyCI:mTargetNames hold the strings, keyed by the indices of the target nodes.  For non-static rigid bodies these target names are transferred to `OEngine::Physic::RigidBody::mTargetName`.

Note that a model may have a number of rigid bodies (like entities) and there is a concept of parent/child to deal with the raycasting test (see the notes on 04/03/20).

Now since the __Ogre::Bone names match the RigidBody target name__, the physics system can mimic the movements of the rendering system.

## Ragdolls

  * COC "ImperialDungeon05" and look for `Dungeons\Caves\Traps\CTrapLogs01.NIF` to test.
  * COC "ICMarketDistrictAFightingChance" for the `CathedralCryptLight02.NIF` and `TargetHeavy01.NIF` (but easier to get there from outside)
  * COC "WellspringCave" to see the hanging roots (Dungeons\Misc\RootHavok06.NIF)

The vines at Wellspring Cave look ok except:
  * the collision shapes are not linked (i.e. constraints)
  * the entities do not move with the collision shapes
  * the scale is not right at all

Ragdoll trap logs call stack

    OEngine::Physic::PhysicEngine::stepSimulation()
         ...
        btDiscreteDynamicsWorld::stepSimulation
              ...
            btDiscreteDynamicsWorld::applyGravity
              ...
            btDiscreteDynamicsWorld::synchronizeMotionStates
                  ...
                btDiscreteDynamicsWorld::synchronizeSingleMotionState

### mBhkRigidBodyMap

`BtOgre::RigidBodyState` is setup and passed to `btRigidBody` during the call `PhysicEngine::createAndAdjustRagdollBody()`.  Note that it is not created in normal createAndAdjustRigidBody().  The key difference with createAndAdjustRagdollBody() is that it passes `const std::map<std::int32_t, Ogre::SceneNode*>& nodeMap` from `PhysicsSystem::addObject()` which in turn gets it from `ObjectAnimation` (the map is filled during ObjectAnimation's ctor).

The info for the map ultimately comes from `NiModel::mBuildData::mBhkRigidBodyMap` which is filled by the constructor of bhkNiCollisionObject.  It knows the connection between the rigid body and the target node (which will eventually become an Ogre::Entity).

It should be noted that `btRigidBody` keep pointers to collision shapes so we need to find a way to ensure the lifetime of the collision shapes.  These are currently maintained in `BtRigidBodyCI::mBtCollisionShapeMap`.

__FIXME:__ BtRigidBodyCI is an Ogre::Resource.  These resources can be unloaded by the resource manager, which will result in crashes due to the collision shape pointers being deleted...   There must be a way to link BtRigidBodyCI to the associated Ogre::Entity or keeping them in RigidBody (like motion state).

###  mBhkConstraints

A `bhkRigidBody` has a list of constraints for that rigid body.

A ragdoll, in simple terms, the `btRigidBody` tells `btMotionState` of its movements and `btMotionState` then tells the associated `Ogre::SceneNode` to make corresponding movements.  When the `SceneNode` moves the attached `Ogre::Entity` moves as well.

                                                   1
      Ogre::Entity               btCollisionShape ----o btCollisionObject
           |1                                                ^
           |                                1                |       2
        (attach)              btMotionState -----------o btRigidBody ----o btTypedConstraint
           |                        ^                        ^
           o         1              |                        |
     Ogre::SceneNode ----o BtOgre::RigidBodyState     Physic::RigidBody
           |n
           |
        (child)
           |
        mInsert


### Lifetime

Like `Ogre::Entity`, a `btRigidBody` in a cell should be destroyed once they are no longer needed.  The constraints should be deleted at the same time.  `Physic::RigidBody` can delete `btMotionState` and `btCollisionShape` in its destructor.

Alternatively, it may be possible for `Physic::RigidBody` to keep a smart pointer to NiModel and use the collision shapes owned and stored there (by keeping a smart pointer we can ensure that NiModel won't go away).  That may save the need to create new `btCollisionShape` for each `btRigidBody`.

__TODO:__ make it work similar to meshes?

### Node animation comparison

For node animation, The PhysicsSystem uses the SceneNode name as the key to find the RigidBody from PhysicEngine.  The RigidBody can then be moved, rotated, etc, based on the changes on the SceneNode.  The PhysicsSystem also uses the NIF name ("mesh") for scaling, etc, for older style (TES3) objects - this is possible because with the OpenMW implementation of TES3 there is only one RigidBody (and one Ogre::Entity) per NIF.

TES4 RigidBody can have multiple btRigdBody within one NIF model.  But to get the existing system to work the RigidBody needs to return the "handle" (i.e. Ogre::SceneNode name) of the base RigidBody only.  Hence all its children have the same `mName` so that rayTest(), etc, can work as before.

Multiple RigidBodies within one NIF model is managed by `BtRigidBodyCI` which uses the map of target node to collision shapes in the NiModel to provide the data for creating the base RigidBody and its children.

                                                        1
       Ptr . . . . . . . . . . . PhysicsSystem o--------- PhysicEngine
        o                          ::handleToMesh[]         ::mCollisionObjectMap[]
        |                                o   o                    o         o
        |  Ogre::Node           key      |   |                    |         |
        |    ^  ::mName -----------------+   |                    | value   | key
        |    |                               |value               |         |
     Ogre::SceneNode          NiModel        |            Physic::RigidBody |
                               ::mModelName -+                 ::mName -----+
                               ::map<target node,                (Ogre::SceneNode name)
                                     collision shape>          ::mTargetName
                                                                 (target node, parent)
                                                               ::mChildren


During `NiModel::buildModel()`, `NiMultiTargetTransformController` fills `NiModel::mBuildData::mMovingBoneNameMap`  (for FO3, `NiControllerSequence` does that instead). `BtOgreInst` then uses that to fill `mNodeAnimEntities` - unfortunately relying on the `Ogre::Entity`'s `Ogre::Mesh` names to match the `NiNode` names.  Clearly this won't work with specialised meshes with skeleton or NPC's name prepended (but then they won't have any node animations, either).

Whether `mNodeAnimEntities` has anything determines whether node animation wil be used (e.g. by doors).

# [09/03/2020] Fixing bugs

## Animated Havok objects

The prison cell gate (COC "ImperialDungeon01", `Dungeons\Chargen\CGprisonCellGate01.NIF`) should not be a ragdoll implementation.  It's probably because of this line in the `ObjectAnimation` ctor:

```cpp
if (mObjectRoot->mForeignObj->havokEnabled())
```

That flag is set by `NiIntergerExtraData` using the `BSX` flags in the NIF file (e.g. `Dungeons\Chargen\IDGate01.NIF`, `FormId` 0x0003665B).  `IDGate01` has `BSX` flag 0x0B which for TES4 includes "enable animation", "enable collision" and "enable havok".

We may need to change the code to exclude the models with animation enabled?  But that disables ragdoll from others such as `Dungeons\Misc\RootHavok06.NIF`.  Maybe it will be necessary to capture the presence of constraints during the construction of the NiModel.  __FIXME:__ Even so objects such as `Clutter\MinotaurHead.NIF` and `Dungeons\Caves\Traps\CTrapLogs01.NIF` will have both animation and havok enabled, so some kind of control mechanism will need to be devised.

CTrapLogs01 animation, looking from the left of the pile from the top of the hill:

                 Log05 =========
              Log04 Log03 =========
            Log  Log01 Log02 =========

`NiTransformInterpolator` (block 8) rotates Log02 once manually triggered.  `NiBlendTransformInterpolator` (block 6) has a flag with value `MANAGER_CONTROLLED` which is probably how the vanilla engine implements this, through an activator.

This object has a script. From the Construction Set:

    scriptName CTrapLogs01SCRIPT                                      {{{)

    ; On activation havok will turn on and logs will roll if placed on an incline
    ; Logs will continue to do damage for 6 seconds after activation

    short triggered
    float timer
    short next
    ref mySelf
    ref myParent

    float fTrapDamage
    float fLevelledDamage
    float fTrapPushBack
    float fTrapMinVelocity
    float fTrapDeathPushBack
    short bTrapContinuous

    begin onActivate

        if triggered == 0
    		set fTrapDamage to 30
    		set fTrapPushBack to 100
    		set fLevelledDamage to 1.5
    		set fTrapDeathPushBack to 80
    		set fTrapMinVelocity to 100
    		set bTrapContinuous to 0
    		playgroup unequip 1
    		set triggered to 1
    		set timer to 6
    		setDestroyed 1
    	endif

    end

    begin gameMode

    	;after 1 sec delay, activate parent (for daisy-chaining)
    	if triggered == 1 && next == 0 && timer < 5.5
    		set next to 1
    		set myParent to getParentRef
    		set mySelf to getSelf
    		myParent.activate mySelf 1
    	endif

    	if triggered == 1 && timer <= 0
    		set fTrapDamage to 5
    		set fTrapPushBack to 20
    		set triggered to 2
    	endif

    	if timer > 0
    		set timer to timer - getSecondsPassed
    	endif

    end

    begin onReset

    	reset3DState
    	set triggered to 0
    	setDestroyed 0

    end                                                               }}})

In comparison MinotaurHead activates immediately (i.e. falls down from the wall) then when the animation completes Havok commences.

How dow we distinguish objects that should begin havok upon the completion of the animation (e.g. trap log, minotaur head) and those that don't? (e.g. prison cell gate)

In summary, we disable Havok at the start if:

  1. Has no constraints; and
  2. Has animations (node animations only?)

There are no activators at Jensine's "Good as New" Merchandise. So it is still unclear how the `MinotaurHead` auto-plays the animation.  Maybe I am confused and in the vanilla game it does not fall at all?

## How to communicate the controls?

There are triggers, traps, sripts, etc, that require communications to the Entity and/or Rigidbody.  Also, there could be requests going out for playing sound effects, etc.

### Ragdoll control

Controlling ragdoll should be possible via `RigidBody::getMotionState()`.  Once cast into `BtOgre::RigidBodyState` we can control whether to move Ogre::SceneNode.  So the question will be how to get to RigidBody.  One way might be via `PhysicsSystem::handletoMesh`.

So an object with Havok enabled as well as animation the default can be to disable ragdoll.

Wait - doing above will simply stop the rendering updates.  Also we still need raycasting and collision.  We need another solution.

Apparently it might be possible to do this with:


```cpp
setLinearFactor(btVector3(0, 0, 0));
setAngularFactor(btVector3(0, 0, 0));
```

or if we can access the members directly:

```cpp
btRigdBody::m_linearFactor.setValue(0, 0, 0);
btRigdBody::m_angularFactor.setValue(0, 0, 0);
```

### Animation control

# [10/03/2020] Bug Fixes

## Storm Atronach missing entities

  * video posted 12/02/19 ok
  * 004a1d72985115fed43acd644f5da8ce2d90d302 15/02/20 ok
  * ccaf2c520f93ea2726b40a73fb36f975b6445840 17/02/20 ok
  * a98765fe96143a4bac7df424e4ccec183be32925 02/03/20 ok
  * d0bd93a6cd0f5185be367f4fe45b9b0f35923fad 04/03/20 broken

## EGM missing for Daedric Helmet

resourceName "meshes\\armor\\daedric\\m\\helmet.egm" missing exeption

Test by:

    COC "OblivionMQKvatchCitadel"
    COC "KvatchChapelOfAkatosh"
    <F12> to take screenshots

## Rotated RigidBody in Citadel door

Only sometimes!?

    (COC "OblivionMqKvatchCitadelHall01" or COW "MS13CheydinhalOblivionWorld" 1 -1)
    Oblivion\Architecture\Citadel\Interior\CitadelHall\CitadelHallDoor01Anim.NIF (000182E8)

## Missing bone for animation

Call stack for creating Ogre::Controller

>	openmw.exe!NiBtOgre::NiControllerSequence::build() Line 419	C++
>	openmw.exe!NiBtOgre::NiModel::buildAnimation() Line 359	C++
>	openmw.exe!MWRender::ForeignNpcAnimation::addForeignAnimSource() Line 1474	C++

>	openmw.exe!NiBtOgre::NiMultiTargetTransformController::build() Line 518	C++
>	openmw.exe!NiBtOgre::NiControllerSequence::build() Line 299	C++
>	openmw.exe!NiBtOgre::NiControllerManager::build() Line 410	C++
>	openmw.exe!NiBtOgre::NiNode::build() Line 641	C++

FO3 Characters\_Male\Skeleton.nif

Bip01 L Forearm has 2 children:

  * `Bip01 L ForeTwist`
  * `Bip01 L Hand`

Forum notes from 18/02/19:

> I had created this to ask for help in technical forums (e.g. Ogre) as I was getting nowhere and getting desperate. But once I made the video I figured out the issue. I don't have a solution yet but at least I know why it happens. Basically some of the skinned meshes specify weighting against a bone that is not specified in the animation. The code does not create a controller for bones not mentioned in the animation file, so it probably goes to random places (or maybe the binding pose)

So, it must be the first call stack above that I need to investigate.  It might be this section of the code:

```cpp
else if (ctlrTypeName == "NiTransformController")
{
    if (mModel.blockType(interpolatorRef) != "NiTransformInterpolator" &&
        mModel.blockType(interpolatorRef) != "NiBSplineCompTransformInterpolator")
        throw std::runtime_error("unsupported interpolator: "+mModel.blockType(interpolatorRef));

    // NOTE: Some interpolators do not have any data!  Ignore these controlled blocks.
    NiInterpolator *interpolator;
    if (mModel.blockType(interpolatorRef) == "NiTransformInterpolator")
    {
        interpolator = mModel.getRef<NiTransformInterpolator>(interpolatorRef);
        if (0)//static_cast<NiTransformInterpolator*>(interpolator)->mDataIndex < 0) // -1
            continue;
    }
```

Well, that particular `continue;` never happens, but given the comments regarding interpolators without any data let's see further down the code.

Looks like we end up creating the controllers but later do nothing if there is no data.  See below (removed some stuff for clarity):

```cpp
void NiBtOgre::TransformController::Value::setValue (Ogre::Real time)
{
    const NiTransformInterpolator*
        transInterp = dynamic_cast<const NiTransformInterpolator*>(mInterpolator);

    if (transInterp)
    {
        Ogre::Quaternion nonaccumq;
        if(mTransformData && mTransformData->mQuaternionKeys.keys.size() > 0)
        {

```

Rather than doing nothing, we might be able to move the bone based on its parent and its local transform.

To confirm that we have the issues that were observed before, check with NifSkope - using `Characters\_Male\Skeleton.nif` and anim `Laugh.kf` loaded, we can see NiTransformInterpolators with the block indices 451 and 491 (updated after adding anim).  They are for the Controlled Blocks `Bip01 L ForeTwist` and `Bip01 R ForeTwist` as suspected.

After some experimentation it dawned on me that doing nothing means the bone keeps its relative position and orientation against its parent already.  So the issue must be something else.

## Missing symmetric texture coefficients

Some don't have any symmetric texture coefficients, e.g.:

    [ESM4::Npc] = {mFormId=0x0004ef6f mFlags=0x00040000 mEditorId="CheydinhalGuardCityPostNight03" ...}

## Strange warnings from OpenAL

    AL lib: (EE) `anonymous-namespace'::ALCwasapiPlayback_mixerProc: WaitForSingleObjectEx error: 0x102

# [11/03/2020] Citadel Hall door

Citadel hall door - both have the same `FormId` 0x000182e8

    left (18) 2092, 1280, 768
    ((std::_Tree_node<std::pair<int const ,std::pair<Ogre::Matrix4,btCollisionShape *> >,void *>*)0x000002b10cce3280)->_Myval.second.first.m[0x00000000],view(MapHelper) 0x000002b10cce32a8 {5.36441803e-07, 0.000000000, -0.999999881, 210.856628}
    rotation {w=1.00000000 x=0.000000000 y=0.000000000 ...}
    z = -1.72853493e-06

Two different world positions, same transform, but different rotations

    left (18) 1024, 1276, 768
    ((std::_Tree_node<std::pair<int const ,std::pair<Ogre::Matrix4,btCollisionShape *> >,void *>*)0x000001bf595c70c0)->_Myval.second.first.m[0x00000000],view(MapHelper) 0x000001bf595c70e8 {5.36441803e-07, 0.000000000, -0.999999881, 210.856628}
    rotation {w=1.10467010e-06 x=0.000000000 y=0.000000000 ...}
    z = 1.00000000

Using `adjustRigidBody()` for user index != 4 does not work, just moves the collsion shapes in the wrong place.  However, that allowed me to observe what is happening when the doors move.  It looks like for one of the doors the movement is in the opposite direction!

Using the target's local rotation (i.e. `rot`) as the binding orientation makes the citadel doors to work properly at `OblivionMqKvatchCitadelHall01` (`Oblivion\Architecture\Citadel\Interior\CitadelHall\CitadelHallDoor01Anim.NIF`) but breaks other rotating doors.

I think we need to look at somewhere else for the bug - possibly `processDoors()`.  Somehow we need to take into account of the world rotation.  Or maybe `PhysicsSystem::moveSubObject()`.

__FIXED:__ it turned out to be an issue in `PhysicsSystem::moveSubObject()` indeed.  The local movement of the `Ogre::Bone` was not being properly converted to the movement of the collision shape because it was not taking into accout of the binding orientation of the collision shape.  This took a whole day.

__TODO:__ There is still the issue of doors not remembering its open/closed state when leaving a cell then returning.

__TODO:__ Also, if you look away quickly before the collision shape had not completed its movement, it can get stuck. (i.e. rendering and physics gets out of sync)  Need to ensure that the movement is completed somehow.

Door activation is rather complicated (simplified shown below to get an idea):

                            Interpreter  Foreign    Action                       Ogre::Animation
        Engine     World       Context     Door      Door    Animation    Ogre::Entity  State
          |          |           |          |         |        |              |          |
          |          |           |          |  ctor   |        |              |          |
          |          |         activateDoor |--+      |        |              |          |
          |          |<---------------------|  |      |        |              |          |
          |      mDoorStates[]   |          |<-+      |        |              |          |
          |          |           |          |         |        |              |          |
          :          :           :          :         :        :              :          :
          :          :           :          :         :        :              :          :
        ->| activate |           |          |         |        |              |          |
          |--------->| activate  |          |         |        |              |          |
          |          |---------->| activate |         |        |              |          |
          |          |           |--------->|         |        |              |          |
          |          |           |          | new     |        |              |          |
          |          |           |          |-------->|        |              |          |
          |          | executeActivation    |         |        |              |          |
          |          |---------->|          |         |        |              |          |
          |          |           | activate |         |        |              |          |
          |          |           |------------------->|        |              |          |
          |          |           |       activateDoor |        |              |          |
          |          |<-------------------------------|        |              |          |
          |          | hasAnimation("Open") |         |        |              |          |
          |          |---------------------------------------->|              |          |
          |          |           |          |         true     |              |          |
          |          |<--------------------------------------->|              |          |
          |          | activateAnimatedDoor |         |        |              |          |
          |          |---------------------------------------->|              |          |
          |          |           |          |         |        |              |          |
          |          |           |      mNodeAnimEntities      |              |          |
          |          |           |          |<-----------------|              |          |
          |          |           |          | Ogre::Entity     |              |          |
          |          |           |          |----------------->|              |          |
          |          |           |          |         |        | getAnimationState       |
          |          |           |          |         |        |------------->|          |
          |          |           |          |         |        |AnimationState|          |
          |          |           |          |         |        |<-------------|          |
          |          |           |          |         |        | setEnabled   |          |
          |          |           |          |         |        |------------------------>|
          |          |           |          |         |        |              |          |


The actual movement of collision shapes, again simplified:

        World               Animation   PhysicsSystem    PhysicEngine   RigidBody
          |                     |             |               |            |
          | update              |             |               |            |
          |  doPhysics          |             |               |            |
          |   processDoors      |             |               |            |
          |-------+             |             |               |            |
          |   mDoorStates[]     |             |               |            |
          |       |             |             |               |            |
          |       | hasAnimation("Open")      |               |            |
          |       |------------>|             |               |            |
          |       |        true |             |               |            |
          |       |<------------|             |               |            |
          |       | addTime     |             |               |            |
          |       |------------>|             |               |            |
          |       |             |             |               |            |
          |       |  rotateSubObject          |               |            |
          |       |-------------------------->| getRigidBody  |            |
          |       |             |             |-------------->|            |
          |       |             |             |    RigidBody* |            |
          |       |             |             |<--------------|            |
          |       |             |             | setRotation   |            |
          |       |             |             |--------------------------->|
          |       |  moveSubObject            |               |            |
          |       |-------------------------->| setOrigin     |            |
          |<------+             |             |--------------------------->|
          |                     |             |               |            |


# [12/03/2020] Materials

Some models require external texture to be supplied while others (e.g. head models) require the material to be crafted and supplied.

Actual selection of the material for a sub-mesh is done by `NiTriBasedGeom::getMaterial()`.  Each sub-mesh has its own material, but for head parts and body parts there's only one mesh and texture. So we can create a member to indicate that `NiTriBasedGeom` has an external texture/material and `getMaterial()` can use them if they exist.

## Complications with clothes

Some clothes (and maybe armor as well?) that show exposed skin.  The textures for these sub-meshes will need to be changed with those specified in the RACE records.

Another issue is that we need a unique name for the material if we used a different external texture, since the same model could be used for a number of different races.

On top of that those external textures, such as for a human Upper Body, could be morphed based on the `RACE` and `NPC_` coefficients.

## More bugs

Just noticed that Baurus stopped wearing his armor from around 06/03/20. __FIXED:__ Blades armor have zero value - had to compare Armor Rating before comparing value.  __NOTE:__ For now weapon ratings (e.g. damage) are ignored.

# [15/03/2020] Bugs, bugs, bugs

## NPC face detail texture missing

    mNpc = 0x000001d69794ace0 {mFormId=0x0001a117 mFlags=0x00040400 mEditorId="SEBelmyneDreleth" ...}
    mFormId = 0x0001a117

    mEditorId = "SESfara"
    mFormId = 0x0001a116

    mEditorId = "SE01GaiusPrentus"
    mFormId = 0x000133be

## No collision shapes for NPC and Creature skeletons

    void PhysicsSystem::addActor (const Ptr& ptr, const std::string& mesh)
    void PhysicEngine::addCharacter(const std::string &name, const std::string &mesh,

At the moment nothing is creating `OEngine::Physic::ForeignActor`.

Defer working on this until we have better performance.

# [16/03/2020] Spider Daedra

## Bone positions

Comparing the two, the rotations look ok.

### Bip01 L UpperArm

NifSkope

    MultiTargetTransformController::updateTime: Bip01 L UpperArm, time 0.0410088
    rotation before 0.688776,0.426225,0.518234,-0.272996
    rotation after 0.688401,0.426182,0.518556,-0.27351
    MultiTargetTransformController::updateTime: Bip01 L UpperArm, time 3.03465
    rotation before 0.717999,0.364717,0.539053,-0.245285
    rotation after 0.718049,0.363883,0.539909,-0.244403

OpenMW

    time 0.04
    rotation before 0.688624,0.426435,0.518775,-0.273537
    rotation after 0.688397,0.426191,0.518558,-0.273502
    time 3.03299
    rotation before 0.717472,0.365636,0.539447,-0.246051
    rotation after 0.718025,0.363927,0.53989,-0.244446

### Bip01 L Forearm

NifSkope

    time 3.032998561859131
    0.765064,-1.31466e-08,-1.56515e-08,-0.643555
    0.765085,-1.33251e-08,-1.69428e-08,-0.64353

OpenMW

    time 3.03699
    0.764884,-1.32995e-08,-1.66789e-08,-0.644169
    0.764893,-1.33795e-08,-1.72582e-08,-0.644157

Added some objects to the bones to visualise where things were going wrong and surprise, surprise - the bones are in the right place after all.  It looks like the skin weighting issue.

Looking at the code in `NiTriBasedGeom::buildSubMesh` the bone offset transform for skinned meshes are being ignored.  Tried using the implementation in TES3 but for some reason the renders are corrupted.

Use `Gdiff c5840fe5f7d76ae0a049913bfe9724353a875ae9` for comparison.

# [17/03/2020] Skins

Looked into adding bones to simulate the "offset", but that would potentially result in far too many bones being added.  For now, go back to investigating if the vertices of the sub-meshes can be offset instead.

# [18/03/2020] Skins cont.

## Modifying skin vertices

Examinining `Clothes\LowerClass\05\M\Pants.NIF`:

There are two sub-meshes, the leg skin (01) and the pants (15), both children of `Scene Root`.  Confusingly, they are both named 'LowerBody'.  The corresponding transforms:

    index                    | 01                             | 15
    -------------------------|--------------------------------|---------------------------------
    material property        | skin                           | pants
    parent index             | 0                              | 0
    parent transform         | Identity                       | Identity
    local transform          | Identity                       | translation only (0.039, -0.937, 44.528)
    skin transform           | Identity                       | translation only (-0.039, -.937, -44.528)
    bones                    | 10, 11, 12, 13, 14             | 10, 12, 26, 13, 14, 27, 28
    bone 10 tm in NiSkinData | rotation and translation       | rotation and translation
       translation           | 33.087, 6.049, 7.273           | -10.755, -1.758, 6.552
    bone 10 local transform  | rotation and translation       | (same)
       translation           | -6.699, -0.664, 34.001         | (same)
    bone 10 world tm *       | -0.00001,-0.000002,0.253017    | 0.0393686,-0.937018,44.7806
    bone 10 tm in NiSkinData | (almost the same as parent tm  | (almost the same as parent tm * local tm)
                             |  * local tm)                   |
    as above but using skel  | 0, 0.000016, 0.0000038         | 0.039, -0.937, 44.528
    bone 10                  | (better than using model bone) | (better than using model bone)

The challenge is to figure out how the per-bone offest transformations will change the affected vertices and normals.

Bone at index 10 is `Bip01 L Calf`.  Its offset transform for each of the two sub-meshes are different!  This means the idea of adding bones will mean even more bones than originally anticipated (i.e. even more impractical).

So, we can get the new "effective position" for the bone using the per-bone Skin Transform in `NiSkinData` - but how do we now modify the vertices?

## Adding bones

Tried adding extra bones - but it is very difficult to do it.  By the time the skin NiModel is created the skeleton is already loaded - to try to modify it the whole process has to start again.  It is also impractical to scan the possible additional bones required since there can be so many, e.g. shirts, pants.  Maybe if we restrict it to some known problematic creatures?  I would be rather reluctant to hard-code that.

# [19/03/2020] Skins cont.

## Modifying Ogre

Had a quick look at modifying Ogre to do extra transform at the point of Software Vertex Blend - but that code is optimised and it won't be easy to modify that.

## Modifying bone transform

Trying yet another idea - this time to add the addtional transform to the affected bones themselves.  This means anything else that requires the bone's original (i.e. correct) transform will need to take that into account.

The trouble with modifying bone translations and orientations is that they have parent/child relationships.  i.e. modifying one bone may affect many other bones.

# [20/03/2020] FaceGen emotions and lip synch

Rough outline of the code (pseudocode):

```cpp
    // need an animation for each emotion, and make the length configurable?
    animation = mesh->createAnimation(animationId, totalAnimLength);
    Ogre::VertexAnimationTrack* track = animation->createVertexTrack(subMeshIndex+1, Ogre::VAT_POSE);

    // with only 2 in the loop we can unroll
    for (unsigned int i = 0; i < 2; ++i) // we only have "Base" and the pose, e.g. "Happy"
    {
        Ogre::Pose* pose = mesh->createPose(subMeshIndex + 1, poseName);

        for (std::size_t v = 0; v < vertices.size(); ++v) // vertices in headhuman.nif, etc
            pose->addVertex(v, vertices[v]);

        // with only 2 in the loop we can unroll
        for (std::size_t k = 0; k < 2; ++k) // only 2 keyframes for us? (start and end)
        {
            // see the comments on animation length above
            Ogre::VertexPoseKeyFrame* keyframe = track->createVertexPoseKeyFrame(morphKeys->at(k).time);
            // influence value may require some experiments - maybe for lip sync go up to 1 but for others less?
            keyframe->addPoseReference(poseIndex + i, morphKeys->at(k).value);
        }
    }
```

# [23/03/2020] Vertex Pose animation

For some reason mouth, teeth and tongue has to have the x and z parts of the vertex delta swapped.  Probably something to do with the head rotation issue.

# [24/03/2020] Pathgrid and AI Package

The console command is TPG.  In TES4 there are blue and red variants.  It seems like the blue ones have higher priority.  There's probably some flag setting for it.

According to [an online article](https://www.tamriel-rebuilt.org/content/tutorial-pathgridding-tutorial) red ones mean "autogenerated" in TES3 while the blue ones are "custom".  For TES4, blue ones indicate "best path".

Looking at the flags, though, they range from 0x01 to 0x09.  The most frequent one is 0x05 (0b0101). Frequency distribution at ImperialDungeon01:

  flag | frequency
  -----|----------
   1   |  4
   2   | 50
   3   | 42
   4   | 37
   5   | 99
   6   | 24
   7   | 19
   8   |  7
   9   |  2


__TODO:__ But from the CS I can only see one blue node?

Pathgrids are in "Cell Temporary Child" group and loaded from `CellStore::loadTes4Record()`.  __NOTE:__ they are not loaded from `ESMStore::loadTes4Record()` because the cells are preloaded and only the persistent records are (partially) loaded from `ESMStore`.

## Side note on performance and dummy cell

Loading the dummy cell in `Scene::changeWorldCellGrid()` results in a huge performance hit.  But without that `ForeignDoor::activate()` won't work - I think all the doors are in the dummy cell.  We will need to figure out how to selectively insert doors based on their location.

I think calling `insertCell()` in `Scene::loadForeignCell()` results in everything in the dummy cell to be inserted into the scene.  We will need a new method.

But first, why does the dummy cell have that many references, anyway? (at least for Tamriel, 0x0000003c)

For some insight into the sequence of the loading, see `persistent-child-preload.log` which was created with some extra loggin on commit 3c411e8a1276e173484455617d13b1760d84f27b.

# [25/03/2020] Animation groups

`MWRender::Animation::play()` uses the concept of "animation group".  `MWRender::Animation::runAnimation()` is called from `CharacterController::update()` and ctor.  It runs animations in mStates and any controllers in mObjectRoot.

`mStates` contains `Ogre::SharedPtr<AnimSource>` and start time, etc.  It is populated by `play()` and keyed by the animation `groupname`.  It is selected from `AnimSourceList` based on the textKeys matching the `groupname`.  The `groupname` is a parameter in play() - despite what the name suggests, it is really just the animation name, e.g. "Idle". (in TES3 `AIWander` they are "idle2", "idle3", etc)

Most likely we will have to create TES4 versions of these methods since the way animations are implemented are different.

Note that in TES4 NiBSBoneLODController has NodeGroups that might be analogous to the "animation groups" in TES3.  However it is not immediately clear how they are meant to be used.

## Quick note on object lifecycle

  * Most use `Ogre::SharedPtr` which provides implicit destruction.
  * The `vertexData` created using `new` for `Ogre::SubMesh` is owned by `Ogre::SubMesh` and its dtor will delete it.
  * The shapes created by "bhk" methods are owned by `BtOgre::RigidBody` but PhysicEngine manages the deletion of the shapes.
  * There are some uses of `unique_ptr` and `boost::scoped_array` but they should be ok already.

# [26/03/2020] Animation cont.

Noticed that TES4 skeleton has 6 node groups while TES5 has 8.

```cpp
Ogre::Node *Animation::mAccumRoot;
Ogre::Node *Animation::mNonAccumRoot;
NifOgre::NodeTargetValue<Ogre::Real> *Animation::mNonAccumCtrl;
Ogre::Vector3 Animation::mAccumulate;
```

  * `mAccumRoot` is used for actually moving the skeleton. (probably Bip01)
  * `mNonAccumRoot` (probably Bip01 NonAccum)
  * `mNonAccumCtrl` is the controller for `mNonAccumRoot` and probably used for calculating the skeleton's position.  This is set by `Animation::resetActiveGroups()`.
  * `mAccumulate` is set by `CharacterController`, probably a movement request.

Subset of TES4 skeleton (Shivering Isle) hierarchy, kinda inverted:

                      0 Scene Root
                           |
                        3 Bip01         (UPB: BoneRoot)
                           |
                    8 Bip01 NonAccum
                           |
                    14 Bip01 Pelvis
                    /      |      \
                   /       |       \
                  /  18 Bip01 Spine \
                 /         |         \
        330 Bip01 R Thigh  |    299 Bip01 L Thigh
                |          |          |
                     27 Bip01 Spine1


# [26/03/2020] Back to Pathgrid

In TES3 Pathgrid records are loaded  in `ESMStore::load()` then the connected graph created in `CellStore::load()`.

In TES4 we can't take the same approach since we skip "Cell Temporary Child" group while in `ESMStore::loadTes4Record()`.

To draw the points and links, will need to add a method similar to `Debugging::enableCellPathgrid()`.  We need to either modify it or create a different method since `LAND_SIZE`, etc, will be different for TES4.  It also uses ESMStore to find the pathgrids which won't be the case for TES4.

# [27/03/2020] Pathgrid still

The PGRR record turned out to be similar to TES3, i.e. they are indices for the "end node" for number of links specified for each pathgrid point.

`ICMarketDistrictTheBestDefenseBasement` doesn't have a PGRR.  Maybe some links need to be auto-generated?  We may need a dummy physics shape so that a line-of sight test can be done.

    CELL FormId 00049E2A
    PGRD FormId 000304B7

__FIXME:__ Noticed that some pathgrid points are floating in the air - again, a dummy physics shape can be used to "snap" to ground.

We also need a way to find paths to adjacent cells as well as far away destinations.  And we still don't know which nodes are the blue "priority" ones. __FIXED:__ turns out that odd values in z poition indicates "priority".

# [29/03/2020 - 30/03/2020] LOD

From [a short description on TES5 LOD](https://en.uesp.net/wiki/Tes5Mod:LOD_Settings_File_Format):

    struct {
      signed short left;
      signed short top;
      signed int stride_pow2;
      signed int lowestsize_lod;
      signed int highestsize_lod;
    } lodsetting;

## `.lod` and `.cmp` files

xxd `icmarketdistrict_7_16.lod` which is from TES4:

    00000000: 0100 0000 7c0b 0000 0300 0000 00d0 fd46  ....|..........F
    00000010: 004b 8447 85af 6045 00fa ee46 002a 8747  .K.G..`E...F.*.G
    00000020: 85bf 6045 0060 ec46 804c 8747 85df 6045  ..`E.`.F.L.G..`E
    00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    00000050: 0000 0000 a4f0 b542 a4f0 e542 a4f0 c142  .......B...B...B

So, if I use long instead of short we get what appears to be some point vectors?

    0x0001 (32bit int)  // no of REFR? (**NOTE: 30/03/20** these are # of sections)
    0x0b7c (32bit int)  // if this is a REFR baseObj, then tree\TreeEnglishOakYoungSU.spt
    0x0003 (32bit int)  // qty = 3? (**NOTE: 30/03/20** these are # of obj in this section)

    32488, 67734, 3594.97 // there is an entry of the tree in CELL #7, 16
    30589, 69204, 3595.97 // there is an entry of the tree in CELL #7, 16
    30256, 69273, 3597.97 // there is an entry of the tree in CELL #7, 16
    0, 0, 0               // rotation
    0, 0, 0               // rotation
    0, 0, 0               // rotation
    90.97, 114.97, 96.97  // scale for each

And `icmarketdistrict_8_16.lod` has below.

    0x0001 (32bit int)    // 1 REFR (**NOTE: 30/03/20** 1 section)
    0x0b7c (32bit int)    // base Object ID
    0x0001 (32bit int)    // qty

    32985, 67787, 3597.97 // there is an entry of the tree in CELL #8, 16
    0, 0, 0               // rotation
    96.97                 // scale

There are indeed 4 trees (2 near BeggarICMarketsSimplicia and 2 near the entry into the sewers).  The `.cmp` file probably indicates the distance to these REFR?  icmarketdistrict.cmp has:

    00000000: 0700 0000                                ....

However anvilworld.cmp has:

    00000000: f7ff d2ff f9ff d2ff f7ff d3ff f8ff d3ff  ................
    00000010: f9ff d3ff f8ff cfff f8ff d0ff f9ff d0ff  ................
    00000020: f7ff d1ff f8ff d1ff f9ff d1ff 0700 0000  ................

So these look like `std::int16_t` CELL co-ordinates.  But these look back to front?  -45, -8, for example, is AnvilExteriorA.  But then 0, 7 does not make sense.  There is no CELL in AnvilWorld with such co-ordinates.  In Tamriel, 0, 7 is VindaselExterior which is too far from Anvil.

                -9  -46   -7  -46   -9  -45   -8  -45
                -7  -45   -8  -49   -8  -48   -7  -48
                -9  -47   -8  -47   -7  -47    7    0

Let's look at another one from Bravil.  We have 15, -8 and 0, 7.  The CELL 15, -8 is just outside one of the walls in Bravil and it doesn't contain the tall cathedral, either.

    00000000: f8ff 0f00 0700 0000                      ........

`bravilworld_15_-8.lod` refers to a couple of trees and a static 0x000018FF CastleWall01 (`Architecture\Castle\CastleWall01.NIF`)

__TODO:__ So, what are we meant to do when we encounter these trees or static objects?  What's in the `.lod` files are clear enough, but what do the cell co-oridnates in the `.cmp` files mean?

## LOD NIF files

Maybe some clue from the file names?  Is there a LAND or CELL with `FormId` 0x00113463? (Not according to OpenCS)  The NIF files are just NiTriStrips with NiTriStripsData without any materials info.  However there are corresponding textures, so maybe they are meant to be manually put together?

    meshes\landscape\lod\113463.00.00.32.nif
    meshes\landscape\lod\113463.00.-32.32.nif
    meshes\landscape\lod\113463.-32.00.32.nif
    meshes\landscape\lod\113463.-32.-32.32.nif

So, the texture 60.00.00.32.dds matches what OpenCS shows on cells 0,0 (bottom left), 0,31 (top left), 31,31 (top right), and 31,0 (bottom right).  Similarly, -31,0 (bottom left), -31,31 (top left), 0,31 (top right), and 0,0 (bottom right) matches 60.-32.00.32.dds.  So the file names must be (except that some have 00 left and -32 right?):

    <world id in decimal>.<grid x left>.<grid x right>.<y grid height>

These are the ones in `meshes\landscape\lod` directory (Oblivion.esm), note that not all worlds have LOD mesh(s):

  prefix | FormId     | World EditorId | World FullName
  -------|------------|----------------|---------------
  60     | 0x0000003c | Tamriel        |
  113463 | 0x0001bb37 | MS14World      | The Painted World
  118972 | 0x0001d0bc | OblivionMQKvatch | Plane of Oblivion
  154411 | 0x00025b2b | MS37World      | Frostfire Glade
  181496 | 0x0002c4f8 | MS13CheydinhalOblivionWorld | Realm of Oblivion
  181732 | 0x0002c5e4 | OblivionRD004  | Wastes of Oblivion
  248431 | 0x0003ca6f | DAPeryiteRealm | Realm of Peryite
  255242 | 0x0003e50a | OblivionRD001  | Wastes of Oblivion
  259409 | 0x0003f551 | OblivionRD002  | Wastes of Oblivion
  305567 | 0x0004a99f | OblivionRD003  | Wastes of Oblivion
  326381 | 0x0004faed | OblivionRD005  | Wastes of Oblivion
  336426 | 0x0005222a | OblivionRD006  | Wastes of Oblivion
  346632 | 0x00054a08 | MQ10BrumaOblivionGate | Plane of Oblivion
  545529 | 0x000852f9 | PalePassWorld  | Pale Pass
  629781 | 0x00099c15 | OblivionRD007  | Wastes of Oblivion
  97393  | 0x00017c71 | CamoranParadise | Camoran's Paradise

It's interesting that decimal is used here while hex is used for FaceGen - must have been a programmer preference or something. There are other entries in meshes\architecture directory:

    bravil\bravilhouselod.nif
    bravil\bravilhouselod_far.nif
    bruma\brumahouselod.nif
    bruma\brumahouselod_far.nif
    cheydinhal\cheydinhalhouselod.nif
    cheydinhal\cheydinhalhouselod_far.nif
    chorrol\chorrollodhouse01.nif            // why different naming convention?
    chorrol\chorrollodhouselod01_far.nif
    skingrad\skhouselower01lod.nif           // why yet another different naming convention?
    skingrad\skhouselower01lod_far.nif

Now the files in distantlod directory make sense a little.  They might be an indicator to use an LOD mesh, depending on which cell the character is in.

## Viewing Distance defaults

    [Viewing distance]
    fog end factor = 1.0
    fog start factor = 0.5
    limit small object distance = false
    max viewing distance = 5600
    small object distance = 3500
    small object size = 250
    viewing distance = 4600

## Oblivion Gates

The Oblivion gates are visible from distance (at least it feels that way) so let's check the records.  There seems to be many different types, one of which is door with `FormId` 0x00051925.  The first REFR with the `mBaseObj` that matches is:

    FormId   0x00091ca2
    Flags    0x00000400 (persistent reference) // note that it doesn't have the disable initially flag
    DestDoor 0x00000000 // no destination FormId, must be controlled by a script on the base object
    BaseObj  0x00051925 Oblivion\Gate\OblivionArchGate01.NIF

# [31/03/2020] LOD cont.

Looking at the `.cmp` file again.  `tamriel.cmp` has 153 co-ordinates plus 0,7.  But there are 9347 tamriel `.lod` files.

Maybe these are reference points for the generation of the LOD mesh and textures? __EDIT: 05/04/20__ The `.cmp` files have grids where visibly distant statics are located and the `.lod` files have the base object `FormId` and position/orientation/scale of the visibly distant statics and trees.

# [31/03/2020 - 02/04/2020] Visible when distant

## Initial attempt

We probably need to load these records, along with persistent records, for each world space.  But do we do that at the beginning or when we enter a world for the first time?

Either way, we need a special case of CellStore that holds these records (and change only when the worldspace changes).

        ESMStore         Store<ForeignCell> ForeignCell  ESM4::Cell
           |                     |             |            |
           | loadTes4Group()     |             |            |
           |--+                  |             |            |
           |  | loadTes4Record() |             |            |
           |  |--+               |             |            |
           |  |  | CELL          |             |            |
           |  |  | preload()     |             |            |
           |  |  |-------------->| new         |            |
           |  |<-+               |------------>|            |
           |  |                  | preload()   |            |
           |<-+                  |------------>| new        |
           |                     |             |----------->|
           |                     |             | preload()  |
           |                     |             |----------->|
           |                     |             |            |
           |                     |[if Grp_WorldChild]       |
           |                     | setDummyCell()           |
           |                     |------------>|            |
           |                     |             |            |


__TODO:__ `getForeignWorld()` should be changed to `getWorldCell()` __DONE__

        Scene       MWWorld::World   MWWorld::Cells     ESMStore  CellStore
          |                |              |               |          |
          | changeWorldCellGrid()         |               |          |
          |--+             |              |               |          |
          |  |             |              |               |          |
          |  |             | getWorldCell()               |          |
          |  |------------>|------------->|               |          |
          |  |             |              | find()        |          |
          |  |             |              |-------------->|          |
          |  |             |              | ForeignWorld* |          |
          |  |             |              |<--------------|          |
          |  |             |              | find()        |          |
          |  |             |              |-------------->|          |
          |  |             |              | ForeignCell*  |          |
          |  |             |              |<--------------|          |
          |  |             |              | ctor          |          |
          |  |             |              |------------------------->|
          |  |             |              |<-------------------------|
          |  |             |              | load()        |          |
          |  |             |              |------------------------->| loadForeignRefs()
          |  |             |              |               |          |--+
          |  |             |              |               |          |  | loadTes4Group()
          |  |             |              |               |          |  |--+
          |  |             |              |               |          |  |  | loadTes4Record()
          |  |             |              |               |          |  |<-+
          |  |             |              |               |          |  |
          |  |             |              |               |          |<-+
          |  |             | CellStore*   |<-------------------------|
          |  |<------------|<-------------|               |          |
          |  |             |              |               |          |
          |  | loadForeignCell()          |               |          |
          |  |--+          |              |               |          |
          |  |  | insertCell()            |               |          |
          |  |  |--+       |              |               |          |
          |  |  |  |       |              |               |          |


The loading of the REFR, ACHR and ACRE occurs in `CellStore::loadTes4Record()` and the creation of the rendering and physics shapes are initiated from `Scene::insertCell()`.

`MWWorld::Cells` stores `ForeignCell`s and it's probably the best place to keep a dummy cell for visibly distant REFRs.

There are a couple of options on where to load the records - either initiate the call from `ESMStore` (when first scanning the ESM/ESPs or from cells (when a new world is accessed for the first time).  I suspect that the former is going to be simpler, since it will have all the base and mods being scanned.  With the latter approach, WRLD context needs to be saved so that we can go back and scan all the CELLs that belong in the world, also all the mods that modifies the CELLS, REFRs, etc.  The only trouble with the former approach is the lack of access to `MWWorld::Cells`.  We may need to add a method to `WorldImp`.

## Redesign needed

Having one cell to hold all the visibly distant REFR won't work.  In Tamriel there are way too many trees.  The performance becomes worse than a slide-show.  There must be some alogorithm in vanilla to decide which ones to load, similar to cells - however it must be more than the number of cells being loaded?  Otherwise why bother grouping them as "visibly distant"?

Just outside Vilverin approx 1.2M triangles with exterior grid size of 3 - single digit FPS sometimes going down to 0.

__TODO:__ Not very happy with having to add methods in MBase::World.  Need to look for alternatives.
__TODO:__ Not happy with ForeignWorld storing dummy cell `FormId` but visibly distant `CellStore` (inconsistent).  We just need to ensure that it is created when the world is first accessed.  However, if we were to load _all_ the REFRs for the WRLD, which may have many CELLs, we had to load them in ESMStore and at that point nothing would be accessing any worlds.

__FIXME:__ Sometimes Morrowind cells get loaded?  I think this might be due to OpenMW using `getExterior(x, y)` which can confuse things.  We may need to keep the current world somewhere (player?) and change only when explicigly changing worlds.

__TODO:__ WRLD has a flag "no LOD water"

## Revisit `.lod` and `.cmp` files

Examining the out put of `xxd distantlod\oblivionmqkvatch.cmp`:

    00000000: 0300 ffff 0400 ffff 0300 0000 0000 0100  ................
    00000010: 0100 feff 0700 0000                      ........

Each of the co-ordinates in the `.cmp` file has statics in visibly distant cell child group:

     Grid | CELL FormId | REFR FormId | BaseObj FormId | BaseObj EditorId
    ------|-------------|-------------|----------------|------------------------------
    -1, 3 | 00021079    | 00034264    | 000314D2       | CitadelTowerSmall02
          |             | 000221FA    | 0003487B       | CitadelTowerBridgeLong01
    -1, 4 | 00021078    | 0002209E    | 000314CF       | CitadelTowerSmall01
     0, 3 | 00021072    | 00034263    | 000314CF       | CitadelTowerSmall01
          |             | 000221F9    | 0000A010       | CitadelTowerBridgeExtraLong01
          |             | 0002109D    | 0002D3E9       | CitadelTowerCenterPiece
     1, 0 | 0002106D    | 0002209F    | 000314D2       | CitadelTowerSmall02
    -2, 1 | 00021084    | 000221B3    | 000314CF       | CitadelTowerSmall01

OblivionMQKvatch has 5 `.lod` files, which correspond to above (I wonder if they all match like that?).

    oblivionmqkvatch_0_3.lod
    oblivionmqkvatch_1_0.lod
    oblivionmqkvatch_-1_3.lod
    oblivionmqkvatch_-1_4.lod
    oblivionmqkvatch_-2_1.lod

Examining `distantlod\oblivionmqkvatch_0_3.lod`:

    000314CF qty 1, pos 45720000, 464b6000, 45905fc3, rot 00000000, 80000000, 3f48efba, scale 42c9f0a4
    0002D3E9 qty 1, pos ...
    0000A010 qty 1, pos ...

So, these might be look-ups to quickly locate the visibly distant statics and their grid locations.  __Or, maybe they provide enough details so that the ESM/ESP files don't have to be scanned at all.__

Still, the question is when to load them, i.e. all the time when in the OblivionMQKvatch world or only when in certain cells?

Well, all that work to create the VisibleDistCell has been for nothing!  Maybe it can be salvaged (swapped out when the "real" one gets loaded?).

Each of the objects have a `_far` variant in the same directory:

    meshes\oblivion\architecture\citadel\exterior\maintowers\towercenterpiece_far.nif
    meshes\oblivion\architecture\citadel\exterior\subtowers\towersmall01_far.nif
    meshes\oblivion\architecture\citadel\exterior\subtowers\towersmall02_far.nif
    meshes\oblivion\architecture\citadel\exterior\walkways\towerbridgelong01_far.nif
    meshes\oblivion\architecture\citadel\exterior\walkways\towerbridgeextralong01_far.nif

## Tamriel `.lod` (from 05/04/20)

Grid 0,0 is not in `tamriel.cmp` and only has trees

    distantlod\tamriel_0_0.lod
    000232D8 \TreeWhitePineForest01.spt
    000237EE \TreeWillowOakForest01SU.spt
    0000089B \TreeSugarMapleForestSU.spt
    000232D9 \TreeSilverBirchForest01SU.spt
    00000B7D \TreeWhitePineForest.spt
    000009FE \TreeSilverBirchForestSU.spt

Grid 0,7 is in `tamriel.cmp`- but still only has trees.  But maybe a poor choice of grid for checking since it is the "back marker".  Also the numbering maybe Y, X?

    distantlod\tamriel_0_7.lod
    00017F9E \TreeGreyPoplarForestSU.spt
    00000BC6 \TreeWillowOakFreeSU.spt
    00017F98 \TreeYewForest.spt

Grid -18, 1 is in `Tamriel.cmp`, but still no static.

    distantlod\tamriel_1_-18.lod
    00000BC6 \TreeWillowOakFreeSU.spt

Try again and bingo!  __So it appears that the `.cmp` files have grids that have visible distant statics.__ Also the filename structure is `<EditorId>_<grid x>_<grid y>.lod`.

    distantlod\tamriel_-18_1.lod
    000232DB \ShrubVineMapleSU.spt
    00000BC9 \TreeWillowOakYoungSU.spt
    00009EFE Architecture\Skingrad\SkHouseLower01LOD.NIF SkHouseLower01LOD
    00000B7C \TreeEnglishOakYoungSU.spt
    00028773 Architecture\Skingrad\SkingradCastleWall01.NIF SkingradCastleWall01
    00035C32 Architecture\Castle\Skingrad\SkCastleWallGate01.NIF SkCastleWallGate01
    000232D6 \TreeEnglishOakForest01SU.spt
    000019DA \TreeSugarMapleFreeSU.spt
    000286CF Architecture\Skingrad\SkinGradCastleTower01.NIF SkinGradCastleTower01

## `Oblivion.ini`

We will need a lightweight class (in comparison to Ptr) to represent LOD trees.  The vanilla implementation renders _a lot_ of trees.  Maybe a 2D tree using billboard effect?

    [General]
    uGridDistantTreeRange=15
    uGridDistantCount=25
    uGridsToLoad=5
    uGridDistantTreeRangeCity=4
    uGridDistantCountCity=4

    [LOD]
    fLodDistance=500.0000
    bUseFaceGenLOD=0
    iLODTextureTiling=2
    iLODTextureSizePow2=8
    fLODNormalTextureBlend=0.5000
    bDisplayLODLand=1
    bDisplayLODBuildings=1
    bDisplayLODTrees=1
    bLODPopTrees=0
    bLODPopActors=0
    bLODPopItems=0
    bLODPopObjects=0
    fLODFadeOutMultActors=5.0000
    fLODFadeOutMultItems=2.0000
    fLODFadeOutMultObjects=5.0000
    fLODMultLandscape=1.0000
    fLODMultTrees=1.3000
    fLODMultActors=7.0000
    fLODMultItems=7.0000
    fLODMultObjects=7.0000
    iFadeNodeMinNearDistance=400
    fLODFadeOutPercent=0.9000
    fLODBoundRadiusMult=3.0000
    fTalkingDistance=2000.0000

    fTreeLODMax=2.0000
    fTreeLODMin=0.0200
    fTreeLODDefault=1.2000
    fObjectLODMax=15.0000
    fObjectLODMin=1.0000
    fObjectLODDefault=5.0000
    fItemLODMax=15.0000
    fItemLODMin=1.0000
    fItemLODDefault=2.0000
    fActorLODMax=15.0000
    fActorLODMin=2.0000
    fActorLODDefault=5.0000
    bLODUseCombinedLandNormalMaps=1
    bForceHideLODLand=0
    fLODQuadMinLoadDistance=65536.0000
    fLODFadeOutActorMultInterior=1.0000
    fLODFadeOutItemMultInterior=1.0000
    fLODFadeOutObjectMultInterior=1.0000
    fLODFadeOutActorMultCity=1.0000
    fLODFadeOutItemMultCity=1.0000
    fLODFadeOutObjectMultCity=1.0000
    fLODFadeOutActorMultComplex=1.0000
    fLODFadeOutItemMultComplex=1.0000
    fLODFadeOutObjectMultComplex=1.0000
    fLODLandVerticalBias=0.0000

## LOD strategy outline

  * Load the ESM/ESP files but don't load any references.
  * Scan the `meshes\landscape\lod` directory and build a map of low-poly land meshes for the worlds that has them.  They seem to be in 32 x 32 cells in size.  There are some odd ones in Tamriel - __TODO:__ check again
  * Scan the `distantlod` directory and build a map of visibly distant objects (statics and trees, not sure if there is anything else).  The `.cmp` file has the list of the cell grid positions for the world.  The `.lod` files have the details of the objects, enough to make a REFR, for the cells.  There should be a `_far` variant of these objects (there are some that don't).
  * The number of cells loaded for visible distant child groups are larger than the cells with everything loaded. When the REFR from the visibly distant child groups are loaded, they should replace the low-poly versions.
  * When a player enters a world cell grid(x, y), cells around that grid needs to be loaded (but not using `Scene::insertCell()`).  A larger group for visibly distant and a smaller group for everything.
  * __TODO:__ Not so sure how to treat the REFR in the dummy cell, especially the doors. i.e. how to decide when to render it? __DONE: 22/05/20__

The low-poly land meshes only have `NiTriStrips` and `NiTriStripsData` blocks.  In order to use the existing codebase, a dummy `NiNode` will need to be inserted at the root.

# [04/04/2020] LOD cont.

## Parent World

Worlds such as ICMarketDistrict seems to require the parent world's LAND.  It also needs the parent world's visibly distant REFR such as the White-Gold Tower (possibly the low-poly version).

__TODO:__ `Cells::getWorldCell()` needs to change as it is auto-loading any new `CellStore` and also calling `initWorld()`.  This results in unnecessarily loading parent world's dummy cell when just the land and visibly distant statics may be required.  See the interaction diagram circa [31/03/2020 - 02/04/2020]. __DONE: 25/05/20__

## When to parse and load the `.lod` and `.cmp` files

Basically 2 options here:

  * parse for all worlds when the game loads
  * parse for each world

The first implementation will parse and create the lookup maps for all at the beginning but load the visibly distant REFR separately for each world.

## Dummy Cell and partial insert

OpenMW doesn't have a concept of having references that are not rendered and without physics.  In order to be able to switch from visibly distant objects to "real" objects, we'll need some way of implementing this.

## `tamriel.cmp` and the grid positions

There are 153 grid positions in `tamriel.cmp`, excluding (0,7) at the end.  But there are 9347 `.lod` files.  This is different to `oblivionmqkvatch.cmp` where the number of grid positions and the number of `.lod` files were the same.

__EDIT: 05/04/20__ The `.cmp` file only has grids where visibly distant statics are located.

## Observations on loading times

For some strange reason Shivering Isles `.lod` files (and maybe others?) take much longer to load than from `Oblivion - Meshes.bsa`.  It might have something to do with the archive.
__TODO:__ try with loose files

The file loading for all the `.lod` files does take quite a while.

# [05/04/2020] LOD meshes

`MWRender::Objects::insertModel()` has the ability to deal with static geometry.  However it still relies on each object being a `Ptr`.

In order to add an `Ogre::Entity` or an `Ogre::StaticGeometry` we need access to an `Ogre::SceneNode`.  The root node is held by `MWRender::Objects`.

        MWWorld::    MWRender::          MWClass::       MWRender::  MWRender::       Static
        Scene        RenderingManager    ForeignBook     Objects     ObjectAnimation  Geometry
          |                |                |               |             |              |
          |                | setRootNode()  |               |             |              |
          |                |------------------------------->|             |              |
          |                |                |               |             |              |
          :                :                :               :             :              :
          :                :                :               :             :              :
          | InsertFunctor  |                |               |             |              |
          |--+             |                |               |             |              |
          |  | addObject() |                |               |             |              |
          |  |------------>|                |               |             |              |
          |  |             | insertObjectRendering()        |             |              |
          |  |             |--------------->|               |             |              |
          |  |             |                | insertModel() |             |              |
          |  |             |                |-------------->|             |              |
          |  |             |                |               | new         |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               | canBatch()  |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               | fillBatch() |              |
          |  |             |                |               |------------>|              |
          |  |             |                |               |             | addEntity()  |
          |  |             |                |               |             |------------->|
          |<-+             |                |               |             |              |
          |                |                |               |             |              |


`ObjectAnimation::canBatch()` looks for the lack of particle effects, lights, animation, etc.

The places where we add LOD objects are shown below.  But `MWWorld::Scene` does not have access to a `SceneNode`.  It will need to go via the `Rendering Manager` - which means we'll probably have to add a method (or two).

  method                            | LOD
  ----------------------------------|------------------------
  `Scene::changeToWorldCell()`      | landscape low-poly mesh
  `Scene::updateWorldCellsAtGrid()` | visibly distant


        MWWorld::    MWRender::          MWClass::       MWRender::  MWRender::       Static
        Scene        RenderingManager    ForeignBook     Objects     ObjectAnimation  Geometry
          |                |                |               |             |              |
          |                |                |               |             |              |
          | addLandscape() |                |               |             |              |
          |--------------->|                |               |             |              |
          |                | insertLandscapeModel()         |             |              |
          |                |------------------------------->|             |              |
          |                |                |               | addEntity() |              |
          |                |                |               |--------------------------->|
          |                |                |               |             |              |


# [06/04/2020] LOD meshes with only `NiTriStrips` and `NiTriStripsData`

There are a couple of impementation possibilities:

  * Option 1: Insert dummy `NiNode`, etc.  This will require quite a lot of work - there are no default constructors for `NiNode`, `NiAVObject`, `NiObjectNET`, `NiObject`, `NiTexturingProperty`, `NiSourceTexture`, etc.
  * Option 2: Modify the mesh building code and add a specil create method in `NiModelManager`.  This might be even more work and most likely to be more complicated.

## When do we render the mesh

    |                              |                              |
    | (-32,32)                     | (0,32)                       | (32,32)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |                              |       ^                      |
    |                              |       |                      |
    |               x            +-------+ |       x              |
    |                            | |     | |                      |
    |                            | | @1  |                        |
    |                            | |     |                        |
    |                            +-------+                        |
    |                              |                              |
    | (-32,0)                      | (0,0)                        | (32,0)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                   (-14,-6)   |                              |
    |                  +           |                    +-------+ |
    |                              |                    |       | |
    |                              |                    |   @2  | |
    |               x              |               x    |       | |
    |                              |                    +-------+ |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    | (-32,-32)                    | (0,-32)                      | (32,-32)
    +------------------------------+------------------------------+--------

There are 36 files for Tamriel.  The pair of numbers represent the bottom left corner grid of the block.  i.e. `<formid in dec>.<x bottom left><y bottom left><width/height of the square block>.nif`

    (-96, 64) (-64, 64) (-32, 64) (00, 64) (32, 64) (64, 64)
    (-96, 32) (-64, 32) (-32, 32) (00, 32) (32, 32) (64, 32)
    (-96, 00) (-64, 00) (-32, 00) (00, 00) (32, 00) (64, 00)
    (-96,-32) (-64,-32) (-32,-32) (00,-32) (32,-32) (64,-32)
    (-96,-64) (-64,-64) (-32,-64) (00,-64) (32,-64) (64,-64)
    (-96,-96) (-64,-96) (-32,-96) (00,-96) (32,-96) (64,-96)

In the game file, the bottom left cell is (-64,-40) and the top right cell is (59,69).  These don't have any CELL data.  The bottom left cell with any data is (-59,-28) and top right (69,47) - even these are LOD regions. (see the region map for 0x0000003C in OpenCS)  So the low-poly mesh extends far beyond the boundary of the cells the player character can go.

Looking at the diagram, the character `@1` will see all 4 blocks (-32,0), (0,0), (-32,-32) and (0,-32).  As the character travels up past the mid-points (marked by 'x'), the blocks (-32,-32) and (0,-32) will no longer be rendered and new blocks (-32,32) and (0,32) will be rendered instead.

Alternatively, if we find the overhead of having the LOD meshes is a problem, we can wait till the character gets closer to the edge.  However, in a pathological case, e.g. at (0,0), there will be 4 blocks being rendered.  So we may as well get used to rendering 4 at a time at all times.

## Algorithm

If the mid-point of the LOD landscape block is less than or equal to the size of the block distance to the player character's cell, then render the block.

i.e.

Subtract `block size / 2` from the current (x,y) - in the diagram above roughly (2,10) - (16,16) = (-14,-6)
The capture area then is:

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    x right       |  -14 +  32 =  18   |  18/32 =  0 +  18/32
    y bottom      |   -6 + -32 = -38   | -38/32 = -1 +  -6/32
    y top         |   -6 +  32 =  26   |  26/32 =  0 +  26/32

So 4 combinations (-1,-1), (-1,0), (0,0), (0,-1) in blocks, or multiply by 32 to get cell grid numbers.

```cpp
xLeft  = int((x - 16 - 32) / 32) * 32; // = int((x - 48) / 32) * 32
xRight = int((x - 16 + 32) / 32) * 32; // = int((x + 16) / 32) * 32
```

### Hysteresis

For loading cells, visibly distant objects and LOD landscape, hysteresis should be introduced to stop constant loading/unloading at specific points in the map.  i.e. loading and unloading occurs at different points

In order to avoid keeping an unreasonable number of blocks around (again, in pathological cases), we can make the unloading happen _before_ loading. e.g. 2 cells before midpoint would be (2,10) - (14,14) = (-12,-4)  As the player character goes up the map, the player will reach ((2,15).  At that point y bottom for unloading will be (15 -14 -32)/32 = 0 -31/32.

Testing for (0,0), unloading (note -14 rather than -16):

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    x right       |  -14 +  32 =  18   |  18/32 =  0 +  18/32
    y bottom      |  -14 + -32 = -36   | -46/32 = -1 + -14/32
    y top         |  -14 +  32 =  18   |  18/32 =  0 +  18/32

Which results in the same set of blocks for loading.  i.e. unloading before loading may not work?

    |                              |                              |
    | (-32,32)                     | (0,32)                       | (32,32)
    +------------------------------+------------------------------+--------
    |                              |                              |
    |                              |                              |
    |                              |                              |
    |           +--------------------------------------+          |
    |           |////////////////+-------+/////////////|          |
    |           |///x////////////| |     |/////////x///|          |
    |           |//////+---------| | @1  |-----+///////|          |
    |           |//////|         | |     |     |///////|          |
    |           |//////|      ^  +-------+     |///////|          |
    |           |//////|      |    |           |///////|          |
    |           |//////|      |    |           |///////|          |
    | (-32,0)   |//////|           | (0,0)     |///////|          | (32,0)
    +-----------|//////|-----------+-----------|///////|----------+--------
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////|           |           |///////|          |
    |           |//////+-----------------------+///////|          |
    |           |///x//////////////////////////////x///|          |
    |           |//////////////////////////////////////|          |
    |           +--------------------------------------+          |
    |                              |                              |
    |                              |                              |
    |                              |                              |
    | (-32,-32)                    | (0,-32)                      | (32,-32)
    +------------------------------+------------------------------+--------

Here the character is travelling up.  If we implemented unload before load, then the blocks (-32,-32) and (0,-32) would be unloaded at this point but the blocks (-32,32) and (0,32) are not yet loaded.  So it seems like it will work?

Testing for (2,15), unloading:

    trigger point | add block distance | divide by block size
    --------------|------------------------------------------
    x left        |  -12 + -32 = -44   | -44/32 = -1 + -12/32
    x right       |  -12 +  32 =  20   |  20/32 =  0 +  20/32
    y bottom      |    1 + -32 = -31   | -31/32 =  0 + -31/32
    y top         |    1 +  32 =  33   |  33/32 =  1 +   1/32

Not quite right, we lose the bottom two blocks but gain two from the top?  Maybe use this to unload from the list of currently loaded blocks?  This way while the character is inside the coloured section only 1 - 2 blocks are loaded. __NOTE: that the diagram assumes the loading point was also changed, say (x,y) - (18,18)__

## Bugs 1

__FIXME:__ `NiTexturingPropery` has below test code which is hiding a problem in `ForeignNpcAnimation::createMorphedObject()` where the proper texture was not being passed.

```
// FIXME: testing
if (material.texName[iter->first].find("EarsHuman") != std::string::npos)
    material.texName[iter->first] = "textures\\characters\\imperial\\earshuman.dds";
```

## Bugs 2

Need to look into `TES4BSAFile::getFile()` where it is extremely slow in reading one of the archives (Shivering Isles - Meshes)

# [07/04/2020 - 08/04/2020] Where to store LOD data

`MWWorld::Cells` might be a possibility.  Or `MWWorld::Scene`.  But `MWWorld::CellStore` is not, since much of the LOD data is not focused on a single cell.

Currently `Scene` only keeps active cells and uses `World` to retrieve  the required cells from `Cells`.  That makes sense, but the LOD data are not really cells and storing them in `Cells` doesn't seem to quite fit.  Much of the data are really simplified REFR and they are normally loaded into CellStore from ESMStore (except in this case they are loaded from either BSA or loose files).

So maybe keep the LOD data in `ESMStore`?  Or a separate one altogether?  If in `ESMStore` when to trigger the loading?  Anyway, the data is not in an ESM so this feels wrong, too.

How about storing them in `ForeignWorld`?  We can still trigger the loading somehow in `ESMStore`, for example when the first group world child block is encountered.

## Dummy cell

Tamriel has 0x7B9 = 1977 REFR in its dummy cell.  There would also be ACRE and ACHR in the dummy cell. Currently all these are inserted into the scene, resulting in a major FPS drop.  __NOTE:__ another test suggest 1509 including ACHR/ACRE so further tests are needed - but the point is still valid, there are _a lot_.

Can't quite remember why the cell persistent children are read for door cells in ESMStore.  That was done back in 2016.  I think it is because if we leave that until we load a world or a cell, then there is a possibility that we haven't yet loaded a destination door to find out in which cell it is located. (i.e. because the cell in which a door is located is implied in the group structure, not explicitly stated anywhere)

## `MWWorld::Ptr` and `MWWorld::CellRef`

We many need to introduce some changes here in order to deal with LOD data.  Currently we pretend to be a TES3 `ESM::CellRef` by copying similar data across.  Using ESM::Door as an example:

              mRef
        Ptr o------------------------------------------------ LiveCellRefBase*
          o                                                        ^
          | mCell             mDoors                    mList      |
          +------ CellStore* o------ CellRefList<Door> o----- LiveCellRef<Door>


A `Ptr` has an implicit understanding of to which cell it belongs.  Can we still use `Ptr` for the objects in the dummy cell?  The objects in the dummy cell can have positions in different actual cells (at least for exterior dummy cells).

Also, `CellStore::forEachImp()` converts everything in its `CellRefList` stores into `Ptr` before inserting them into the scene.  __We need a way to selectively disable the rendering/animation/physics.  In case of doors, we would like to add them to the scene based on their positions, similarly with visibly distant statics and trees.__

                          mRef                   mCellRef
        LiveCellRefBase o------------- CellRef o---------- ESM::CellRef
              ^     o o                    o o
              |     | | mClass             | | mFormId
              |     | +------ Class*       | +------------ ESM4::FormId  (REFR/ACHR/ACRE)
              |     |  mData               |   mDestDoorId
              |     +-------- RefData      +-------------- ESM4::FormId  (DOOR)
              |                o o o
        LiveCellRef<Door>      | | |
                               | | +-- (current position/rotation/etc)
                               | +---- Ogre::SceneNode*
                               +------ CustomData*
                                           ^
                                           |
                                      DoorCustomData


__FIXME:__ not happy having mDestDoorId in CellRef, need to move it to somewhere else
__TODO:__ not sure of the original intent / design to use `std::list` in `CellRefList` - might have to investigate (might be because iterators don't become invalid as new items get inserted/erased?)

## Initial design

  * Consider inheriting from `CellStore` to create `ForeignCellStore` or something similar.
  * Load _all_ REFR/ACHR/ACRE in Cell Persistent Child group from `ESMStore`.  Store them in a `CellStore` as usual but keep a map of their grid locations (at least for external dummy cell).
  * Load the visibly distant REFR from BSA and store them in a `CellStore`, similar to the dummy one.
  * These special `CellStore`s should be kept in their respective `ForeignWorld`, at least for external ones.
  * Modify (or create a similar one) `Scene::insertCell()` so that objects can be inserted selectively, based on location, class, etc.

__TODO:__ Fix the interaction diagram from 31/09/20

## `CellStore` use cases

Keeping a map of grid positions turns out to be difficult for dummy cell, since all the data are held in `std::list`.  Had a quick look at various accesses to `CellRefList` but can't really see too many insertions/deletions except at loading time and even then it's mostly `push_back()`.

So maybe there might be some performance improvements if `std::list` was replaced with `std::vector`.

## Rethinking the dummy cells and grid map

Maybe keeping indices isn't the optial solution, anyway?  Perhaps keep a "Persistent" section on each `CellStore`?  But doing so will result in 3 of each type of object - e.g. persistent static, temporary static and visually distant static.

Or just brute-force by searching with x/y range each time?

__TODO:__ The references in "Persistent" cell child group may potentially be used for some performance gains since most of them do not move?

# [09/04/2020] LOD meshes clipping with terrain

I think this issue may be resolved by having a manual alpha map and using alpha rejection in the LOD mesh materail. There are a lot of questions about how to actually implement it, however.  For example, what exactly is an alpha map?  Is it a texture itself?  If so does it have to be the same size as the other texture? (in this case 1024x1024) How does one create an area where alpha values are transparent?

With regards to the size of the texture, it appears that alpha rejection is done per pixel basis.  Which also means that when a cell becomes "active" or "inactive" the corresponding pixels of the alpha map needs to be updated.

The `StaticGeometry` will need to be updated with the new material and built again each time terrain is updated.

# [10/04/2020] Terrain

Alpha rejection does work, but results in ugly seams at the boundaries (in hindsight it had to happen due to the low-poly mesh having less vertices and at different positions).  I recall reading something about Oblivion LOD and alpha blending a long time ago - so went looking to see if I could find that article again.  I didn't find that particular one, but [this page](http://testg.wikidot.com/oblivion:lods) seems to have some good info.

Also, the current terrain will need to change to _finally_ use the proper materials.  [This Ogre wiki](https://wiki.ogre3d.org/Terrain+Alpha+Splatting) might be a good starting point.  With LOD landscapes we are unlikely to be having many cells & associated terrain at a time (maybe 3 x 3 or 4 x 4).  Maybe we can get away with a simpler terrain system.

## Back-porting to OpenMW

If the Oblivion-like LOD was to be used for OpenMW, there are a number of things that may need to change:

  * Terrain - not sure how the latest terrain in OpenMW works, but some kind of alpha blending of textures will need to be introduced (prob. using shaders).
  * Terrain, object and actor insertion - I suspect they are currently tied to cell insertion. If so, more fine-grain control is needed, especially statics and trees (for visibly distant rendering without physics).  Most likely changes in `MWWorld::Scene` and others.
  * A mechanism to render the same object with different LOD levels. e.g. the `_far` variant of a static object.  Most likely changes in `MWRender::Objects` and others.
  * A mechanism to selectively display certain statics (e.g. Ghost Fence or an Oblivion Gate) based on a quest progress or some other conditions.  This will require either the NIF model to have non-standard attribute (non-standard for a vanilla Morrowind perspective, anyway) such as adding NiSwitchNode to existing NIF models.  Alternatively we can achieve the same result by adding an `XESP` sub-record to REFR like Oblivion (this way existing NIF models won't require any changes, but it does require selective rendering as per above bullet point).
  * A set of additional config to control the distance of rendering various LOD elements, including actor fading distance, etc. (this is optional but most likely will be beneficial)

There are also some new things that will need to be introduced:

  * Add the ability to parse and load simple landscape LOD NIF models.  These have only 2 blocks, NiTriStrips and NiTriStripsData. (we can probably use NiTriShape/NiTriShapeData instead for OpenMW, depends on the tool generating these)
  * A tool to generate low-poly landscape LOD mesh, if we decide not to use the Construction Set.
  * Landscape LOD meshes and textures themselves.  These can be part of a MOD.
  * Low-poly models of the visibly distant statics and trees. These can be part of the same MOD.  (if we want to be fancy, we can have multiple levels of complexity like Skyrim)
  * The `.cmp` and `.lod` files to indicate where to place the visibly distant statics and trees.  Again part of the same MOD.  These are needed so that we know where to place them _before_ the cells are read from the ESM/ESP/save files.  Unfortunately the formats of `.lod` files probably will need to differ from TES4 since there is no concept of FormId in OpenMW.

## Landscape LOD mesh - Fallout 3, Fallout NV and Skyrim

Each of these also have LOD meshes but their naming convensions are a little different.  Skyrim also has different size blocks, 16 x 16 as well as 4 x 4.  Some Fallout meshes have "level4" and "level8" in their names - might have something to do with the player level.

__TODO:__ If we're going to deal with each of these in one engine, we'll need something like an "interface" pattern with an abstract base class.

# [11/04/2020] Terrain cont.

Some notes from way back in January 2016 (corrected):

        Texture       mTextures[4]; // 0 = bottom left. 1 = bottom right. 2 = upper-left. 3 = upper-right

            ///////////////// ////////////////   <-- discard texture row?
           +-----------------+----------------+/
        32 |\                |                |/
        31 |\                |                |/
           |\     17x16      |      16x16     |/
         . |\                |                |/
         . |\       2        |        3       |/
         . |\                |                |/
         . |\                |                |/
        17 |\                |                |/
           +-----------------+----------------+
        16 |\                |                |/
        15 |\                |                |/
         . |\     17x17      |      16x17     |/
         . |\                |                |/
         . |\       0        |        1       |/
         . |\                |                |/
         2 |\                |                |/
         1 |\                |                |/
         0 |\\\\\\\\\\\\\\\\\|\\\\\\\\\\\\\\\\|/ <-- this row of vertices is a copy of cell below
           +-----------------+----------------+
                          111 1             33 ^
            0123  ......  456 7    .....    12 |
            ^                                 discard texture column?
            |
           this column of vertices is a copy of the cell to the left


Existing implementation:

        MWWorld::  MWRender::        Terrain::       ESM4Terrain::
        Scene      RenderingManager  TerrainGrid     Storage
          |              |               |              |
          | cellAdded()  |               |              |
          |------------->|               |              |
          |              | loadCell()    |              |
          |              |-------------->|              |
          |              |               | fillVertexBuffers()
          |              |               |------------->|
          |              |               | getBlendMapsImpl()
          |              |               |------------->|
          |              |               |              |
          |              |               |              |


# [11/04/2020 - 12/04/2020] FO3, FONV and Skyrim

## TES5 issues

Whiterun:

    mName = "meshes\\architecture\\whiterun\\wrdrawbridge01.nif#51@WRDrawBridge01"

Tamriel:

    clutter\\mehrunesdagonaltar\\mehrunesdagonaltar01.nif

    mName = "meshes\\furniture\\clutter\\leveranimatingmetal.nif#4@RuinsLever"

## FO3/FONV Hair - Hat and NoHat

### FaceGen hair differences

The hair EGM files for FO3/FONV have these variants (haircurly as an example):

    meshes\characters\hair\haircurly.nif
    meshes\characters\hair\haircurlyhat.egm
    meshes\characters\hair\haircurlynohat.egm
    meshes\characters\hair\haircurlyf.nif
    meshes\characters\hair\haircurlyfhat.egm
    meshes\characters\hair\haircurlyfnohat.egm

Skyrim doesn't seem to have EGM or EGT for hair (or anything else) at all?  Only TRI files exist.

### NIF hair differences

The hair NIF files now have two `NiTriBasedGeom` - one named "Hat" and the other "NoHat".

## NPC model

### No FaceGen coefficients

Some don't have any symmetric or asymmetric coefficients.

### No skeleton for some

Some NPC have `marker_creature.nif` as their model (should normally be a skeleton).  These seem to be some kind of place marker for a random generated NPC.

### No `CREA` or `ACRE` in Skyrim

The creatures are now considered "Actors".  The game logic handling creatures will need to change since we can no longer assume an NPC will have a skeleton with certain face parts and body parts, etc.

### BaseConfig

The size and content of the `ACBS` sub-record are different between games.  It would have been good to have a method wihin the `Npc` class to provide an interface, but there doesn't seem to be a reliable detection within `NPC` sub-records for the game.  For now we'll have to build a helper class to do this.

### Body and head parts in `RACE`

Each game differs on what body and head parts are used for an NPC.  Similar to `BaseConfig` this should be abstracted to an interface class.

### `BSDismemberSkinInstance` partitions in NIF files

The visibility of body parts can be selected in FO3/FONV/TES5 NIF files.  It is no longer feasible to have all the permuations created and have them ready in a `ResourceManager`.

How this is done in real-time is uncertain.  __One idea is to have a map of availabile options and have the sub-entity visibilty to be controlled.__  That might mean the naming of the sub-mesh and sub-entity may need to be carefully designed.

__TODO:__ what to do with the ragdoll physics of dismembered parts?  I noticed that `BPTD` records indicate bones and nodes so maybe they have some info that can be used.

### Inventory

Different types of items can be carried.  Currently the inventory slots are hard-coded based on the `BMDT` sub-record flags of `ARMO` record (see below).

Not sure how to approach this.  It might be worth implementing a separate inventory class for each game type.  Having a bunch of if/else statements is not going to be workable.

The use of `MWMechanics/InventoryStore` is pervasive in OpenMW - so unless we're prpared to re-write a whole lot of new code everywhere we may be forced to sub-class `InventoryStore`.  Note that eventually we may still be forced to re-write all the code.  Not sure yet.

## No `CLOT` in FO3/FONV/TES5

Only `ARMO` records are present in FO3/FONV/TES5.  The `BMDT` sub-record contents are different (although FO3 and FONV share the same flag values).

See some notes back in 07/03/2020 regarding body part handling.

## FO3/FONV font textures

For FO3/FONV the font textures have LOD levels, although there is only one level provided. e.g.

    textures\fonts\fixedsys_comp_uniform_width.fnt
    textures\fonts\fixedsys_comp_uniform_width_0_lod_a.tex
    textures\fonts\fixedsys_comp_uniform_width_0_lod_a.dds

## Detection of TES4, TES5, FO3 and FONV

A combination of info from `NPC_` and `RACE` may be required to reliably detect which game.  The main issue is with FO3 which uses ESM version 094 (0x3f70a3d7) which Skyrim also uses. This means we can't just use the ESM version to detect which game.  As a workaround we use the size of the sub-record `DATA` in `RACE` to determine if the ESM is from Skyrim.

__Note that in future we need to be careful of which ESP version is allowed.__ e.g. if a Skyrim verision of ESP is used for a MOD in FONV it will mess up the logic in the code.

## Skeleton and `BSX` flags

TES4 versions of NIF has a flag to indicate that it was a skeleton.  Later games doesn't have this flag.
__TODO:__ how to reliably detect a `skeleton.nif` without comparing the filename?

# [13/04/2020 - 16/04/2020] Debugging

## FO3 Door not moving

There is a door in `zBethOffice01` with NIF model `Dungeons\Office\Doors\OffDoorSmL02.NIF`.  There are two problems with this door.

First, it has a `NiControllerSequence` target node with name "OffDoorSmL02@#0".  The name has the '@' character which we were using to identify node names in a mesh.  One obvious solution is to change it to another character, say '%', but that results in _a lot_ of changes and it is not easy to confirm that all the changes were done correctly.

Key places where the mesh naming convention is used:

  * `NiModel::createMesh()` - creating a mesh with a unique name
  * `NiTriBasedGeom::getMaterial()` - creating a unique name for a material (currently NiNode name is _not_ used, but it may be used in future).
  * `BtOgreInst::buildEntities()` - check `NiModel::mBuildData::mAnimNodesMap` to see if an `Ogre::Entity` should be inserted into `BtOgreInst::mNodeAnimEntities` (which is used in many places).
  * `ForeignActivatorAnimation` ctor - to check against `BtOgreInst::mNodeAnimEntities`.
  * `Animation::getBones()` - to check against `BtOgreInst::mNodeAnimEntities`.
  * `Animation::activateAnimatedDoor()` - not currently used
  * `ObjectAnimation` ctor - adding `FlameNode` to bone
  * `ForeignNpcAnimation::replaceSkinTexture()` - to find the corresponding `NiNode` name to check against the results from `NiModel::fillSkinIndices()`.
  * `mBhkRigidBodyMap` - not currently used

Nest, the moving collision shape is `bhkPackedNiTriStripsShape` - this shape is considered "static" and therefore `PhysicsSystem::rotateSubObject` ignores it.  Not only that, this shape has the world transform baked in (since it is static) and can't rotate with the parent node (i.e. bone).

One solution might be to somehow let the shape know that it is a target of a transform controller and build it as non-static.  The trouble is that currently `btBvhTriangleMeshShape` is used which can only be a static shape.  So some work will be required.

Another solution might be to supply a MOD that "corrects" the mesh, especially if there are only a few of these.  But doing so will mean that the "hole" in the mesh may be "filled".

__FIXED:__ Decided that the door meshes are not really "static" in terms of Bullet definition, since we're moving them via `updateSingleAabb()` anyway.  So the final solution is to selectively apply full world transform depending on whether the `bhkRigidBody` target was a `NiMultiTargetTransformController` target.  These are the ones in `zBethOffice01`:

    meshes\clutter\health\firstaidkit01.nif
    meshes\furniture\officeruined\filingcabinetbunch04.nif
    meshes\furniture\officeruined\filingcabinetbunch02.nif
    meshes\dungeons\office\doors\offdoorbigmetal01.nif
    meshes\dungeons\office\doors\offdoorbigmetal01.nif
    meshes\dungeons\office\doors\offdoorsml02.nif
    meshes\dungeons\caves\lamplight\lamplightlamp.nif
    meshes\dungeons\caves\lamplight\lamplightlamp.nif

## FO3 Dismember body parts

Need a way to control visibility at runtime.  Maybe keep a map of `Ogre::SubEntity*` and `BSDismemberSkinInstance::BodyPartList` in `BtOgreInst`.  Not sure if there is a reliable way to get the sub-entity index, however. Hopefully they are the same as sub-mesh index, which we already have. __FIXED__

## FO3 Inventory

Maybe the Armor flags in FO3 don't work like TES4? A Hockey Mask has ArmorFlags 0x00004E00 which has these:

    FO3_Headband     = 0x00000200
    FO3_Hat          = 0x00000400
    FO3_EyeGlasses   = 0x00000800
    FO3_Mask         = 0x00004000

Which means wearing a Hockey Mask will take any hat or eye glasses off.  Whereas `HelmetRaider02` has  ArmorFlags 0x00004200:

    FO3_Headband     = 0x00000200
    FO3_Mask         = 0x00004000

Sometimes (often?) the `LVLI` selection returns just a helmet.  __FIXED:__ had to observe `LVLI` "use all" flag

__FIXME:__ ManualRef create() just puts dummy values

## FO3 Gnd and Go

We need a special handling for FO3.  __FIXED__

    ForeignArmor Armor\EnclaveScientist\OutfitM_gnd.nif
    ESM          Armor\EnclaveScientist\GO.NIF"
    BSA          armor\enclavescientist\go.nif

## FO3 NPC with model `marker_creature.nif`

__FIXED:__ These seem to work like ACHR (similarly with ACRE for Creatures). e.g.

    mEditorId = "FFHitSquadDCTalonLeader"
    mBaseTemplate = 0x0003d9c5

## FO3 Land level

The ground level just outside `OurLadyHope01` is too low. __FIXED__

## Always female

At `zBethOffice01` only female raiders spawn, e.g:

    mEditorId = "Raider1GunAAFTEMPLATE"
    mBaseConfig.flags = 0x00000219

    FO3_Female         = 0x00000001
    FO3_Respawn        = 0x00000008
    FO3_AutoCalcStats  = 0x00000010
    FO3_NoLowLevelProc = 0x00000200

## FO3 Utility door not working

The troublesome door is:

    mModel = "Dungeons\\Utility\\Rooms\\UtlDoor01.NIF"

It seems like the children of node 180 `IKTrainMain` don't move down.   Maybe the bones are not there for those nodes because the `NiMultiTargetTransformController` doesn't refer to them directly?  If so we may be able to work around it by adding bones to the children of the controller targets, but what about the `NiTriStrips` children such as `UtlDoor01:13@#5`?  Also, shouldn't the children of the node move along with the parent?  Maybe they are inserted to the root rather than the parent?

### Option 1: Parent/Child nodes

If we have to have proper parent/child node structure for NIF models that may be quite a change to the existing codebase.  Currently each of the meshes are created with full world transform as if they're all static and the corresponding `Ogre::Entity` are inserted to the root `SceneNode` (see `BtOgreInst::buildEntities()`)

To change this without too many changes we may need to restrict it to animated models only.

### Option 2: Add Bones

Or maybe just add bones?  To do that we will probably have to hack `NiNode::addBones()` to add bones to the children (and their children, etc) of controller target nodes. The controller targets were added only yesterday to deal with `Dungeons\Office\Doors\OffDoorSmL02.NIF`.  See `BtRigidBodyCI::loadImpl()`:

```cpp
const std::vector<NiNodeRef>&  ctlrTargets = nimodel->getControllerTargets();
bool dynamic = std::find(ctlrTargets.begin(), ctlrTargets.end(), targetRef) != ctlrTargets.end();
```

But what would be the point of adding the bones?  There aren't any controllers moving them, so unless they are linked to another bone they won't be moving, anyway.  So this option may end up being similar to the first option.

### VGearDoor01

The issue we had with `Dungeons\Vault\RoomU\VGearDoor01.NIF` may be due to similar issue?  One controller target node is block 350 `VGearDrill01e01` which has several children including `VGearDrill01e` (which has a child node tree of its own) and `VGearDrill01e:2`.  Note that some of the children _are_ being controlled - which means we can't just add bones willy-nilly.   The sub-tree looks like below.

    350 VGearDrill01e01 - has rendering only
           |
    351 VGearDrill01e   - has rendering only
           |
    352 VGearDrill01d   - has collision
           |
    359 VGearDrill01a   - has collision and rendering
           | |
           | +- 430 VGearDrillb - has rendering only
           |
           +--- 364 VGearDrill  - has collision and rendering

Each of these are controller targets. That implies the issue may be different to `UtlDoor01`.

### VDoor01

The issue with `Dungeons\Vault\Halls\VDoor01.NIF` may be the same.  It looks like the controller targets should _not_ have world transform baked in.  Looking at one of the sub-trees:

    69 VDoorHinge01 - has rendering only
           |
    70 VDoorHinge02 - has collision and rendering
           |
    75 VDoorHinge03 - has rendering only
           |
    76 VDoorDoor01  - has collision and rendering
         | | |
         | | +- 81 VDoorGear01
         | +--- 93 VDoorGear02
         +----- 98 VDoorLock01
          ...  103 VDoorLock02
          ...  108 VDoorBolt03
          ...  113 VDoorBolt02
          ...  118 VDoorBolt01
          ...  123 VDoorBolt04
          ...  128 VDoorHandle01

### Node tree alternative

We may be able to work around the issue (hack?) by using the inverse of derived position/rotation of the parent nodes.  But then, doing so might be even more complicated.

### More collision issues

    mModel = "Dungeons\\Office\\Doors\\OffDoorBigMetal01.NIF"

### FONV issues

Added some NiObjects:

    BSRefractionFirePeriodController trees\prickly_pear_cactus\nv_pricklypearcactus.nif
    NiBSplineCompPoint3Interpolator  creatures\nvsecuritron\mtidle.kf
    BSRefractionFirePeriodController characters\_male\locomotion\mtidle.kf (also FO3)
    NiFloatInterpController          characters\_male\locomotion\mtidle.kf (also FO3)

Manny Vargas's 1st Recon Beret has an issue with TRI file - it dosn't exit (only EGM exists), so the code should be trying to create one from the mesh.  The issue is that the "dummy" TRI file does not get built properly. __FIXED:__ There were two issues - first, when it got built the second time the "name" parameter was not folded to lower case.  Next, there was an incorrect use of `std::map::insert()`.

    Novac is at "WastelandNV" 5 -8
    (Repconn is at "WastelandNV" -2 -8)
    mEditorId = "HatNCR1stReconBeret"
    NIF = "meshes\\armor\\headgear\\red beret\\red_beret.nif"
    EGM = "meshes\\armor\\headgear\\red beret\\red_beret.egm"

There are missing meshes.  __WONTFIX:__ Not sure if there is a fix - maybe the original devs didn't clean up properly?

    resourceName = "meshes\\architecture\\novac\\novac_motel03.nif"
    resourceName = "meshes\\architecture\\novac\\novac_motel02.nif"
    resourceName = "meshes\\architecture\\novac\\novac_bungalow03.nif"
    resourceName = "meshes\\architecture\\novac\\novac_bungalow02.nif"

Missing texture `grey.dds` (shouldn't it be `grey.bmp`?) - it's just a thin strip under the door:

    mName = "meshes\\dungeons\\caves\\lamplight\\lamplightsouvenirdoor.nif#0%LamplightSouvenirDoor"

# [17/04/2020] FO3 Issues (cont.)

Fixed some issues but many more remain.  Some of the outstanding ones include:

  * Lack of interior lighting __FIXED:__ FO3/FONV uses `LGTM` records for lighting.  __TODO:__ had to multiply by a magic number to make it look right - need to see what is the correct way to interpret the numbers.
  * Raiders seem to be females only?
  * Floating animations - creatures only?
  * Doors with moving child nodes.
  * UpperBody skin texture (meant to be using shaders but can we simulate?)
  * UpperBody skin mesh sometimes offset from the rest.
  * FONV COC "RocketLabTop" one of the lights in a hallway has badly generated collision shape mesh.  The renders are ok, maybe clockwise/anti-clockwise difference?
  * `188NCRMerchant` has both hair and hat

# [18/04/2020] Chance None in `LVLI`

It seems to run from 0 to 100 in FO3. Lots of them has value 0 and these have the max value in FO3.
__TODO:__ does this mean they _never_ get spawned?  But [this page](https://fallout.fandom.com/wiki/Fortune_Finder) seems to indicate the chance for Fortune Finder is 10%?  Or maybe it is 0% chance of _additional_ loot until the perk is obtained? (which means we need game logic to handle the dynamic data)

    VendorChestProntoFreeformListGoodStuff
    VendorChestAhzrukhalChems
    Ammo308CaliberScrounger
    Ammo5mmScrounger
    AmmoElectronChargePackScrounger
    VendorCaravanChemsBasic2List
    VendorCaravanChemsBasic1List
    VendorCaravanApparelBasic2List
    VendorCaravanApparelBasic1List
    VendorCaravanJunk2List
    VendorCaravanJunk1List
    VendorCaravanWeaponsBasic2List
    VendorCaravanWeaponsBasic1List
    AmmoDartScrounger
    CapsChangeFortuneFinder
    CapsFortuneFinder

Some `LVLI` in FO3 have these high values.  Accoding to [this page](https://fallout.fandom.com/wiki/Nuka-Cola_Quantum_(Fallout_3)), the chance of finding a Nuka Cola Quantum is 10%.

    LootGrenadeFrag10           90
    LootArmorMilitary10         90
    MailboxLetter5percentChance 95
    LootMirelurkMeat10          90
    LootMirelurkMeatSoftshell10 90
    PrewarApparel10             90
    LootSkillBooks05            95
    ClutterNukaColaQuantum10    90
    LootStealthBoy10            90
    LootAmmoGeneric10           90
    LootAmmoPowerCells10        90
    LootAmmoBullets10           90
    CapsChange10                90

Similarly, `LVLI` with 100 for FONV:

[//]: # (                                                             {{{)
    Ammo20GaScrounger
    LootAmmoFatmanScrounger
    Ammo127mmScrounger
    Ammo4570Scrounger
    Ammo25mmGrenadeScrounger
    Ammo9mmScrounger
    Ammo50MGScrounger
    Ammo40mmGrenadeScrounger
    Ammo357magnumScrounger
    Ammo22LRScrounger
    Ammo12GaScrounger
    VendorChestProntoFreeformListGoodStuff
    VendorChestAhzrukhalChems
    Ammo308Scrounger
    Ammo5mmScrounger
    AmmoElectronChargePackScrounger
    VendorCaravanChemsBasic2List
    VendorCaravanChemsBasic1List
    VendorCaravanApparelBasic2List
    VendorCaravanApparelBasic1List
    VendorCaravanJunk2List
    VendorCaravanJunk1List
    VendorCaravanWeaponsBasic2List
    VendorCaravanWeaponsBasic1List
    CapsChangeFortuneFinder
    CapsFortuneFinder
[//]: # (                                                             }}})

And for TES5:

[//]: # (                                                             {{{)
    VendorEorlundSkyforgeSteelSet
    ArmorCompanionsSet
    LootPerkGoldenTouch
    AtrFrgDaedricRecipeListChest
    AtrFrgRecipeListChest
    AtrFrgDaedricRecipeList
    AtrFrgRecipeList
    PerkMasterTraderGold
    TGLootProwlersProfit
    MGRitualRestorationBooks
    MGRitualIllusionBooks
    MGRitualDestructionBooks
    MGRitualConjurationBooks
    MGRitualAlterationBooks
    VendorGoldFenceStage04
    VendorGoldFenceStage03
    VendorGoldFenceStage02
    VendorGoldFenceStage01
    PerkInvestorRiftenMagicList
    PerkInvestorSolitudeMagicList
    PerkInvestorWhiterunMagicList
    PerkInvestorFalkreathGeneralList
    PerkInvestorMorthalApothecaryList
    PerkInvestorWinterholdGeneralList
    PerkInvestorDawnstarBlacksmithList
    PerkInvestorDawnstarApothecaryList
    PerkInvestorWindhelmBlacksmithList
    PerkInvestorWindhelmApothecaryList
    PerkInvestorWindhelmMagicList
    PerkInvestorWindhelmGeneralList
    PerkInvestorMarkarthMagicList
    PerkInvestorMarkarthGeneralList
    PerkInvestorMarkarthBlacksmithList
    PerkInvestorMarkarthApothecaryList
    PerkInvestorRiftenPawnList
    PerkInvestorRiftenApothecaryList
    PerkInvestorRiftenBlacksmithList
    PerkInvestorSolitudeBlacksmithList
    PerkInvestorSolitudeFletcherList
    PerkInvestorSolitudeTailorList
    PerkInvestorSolitudePawnList
    PerkInvestorSolitudeApothecaryList
    PerkInvestorWhiterunBlacksmithList
    PerkInvestorWhiterunHuntingList
    PerkInvestorWhiterunGeneralList
    PerkInvestorWhiterunApothecaryList
    PerkInvestorRiverwoodWhiteriverTraderList
    PerkInvestorRiverwoodAlvorList
    LootImperialLuck
    LItemSpellTOmes50AllRestoration
    LItemSpellTomes50AllIllusion
    LitemSpellTomes50AllDestruction
    LItemSpellTomes50AllConjuration
    LItemSpellTomes50AllAlteration
    LItemSpellTomes75AllRestoration
    LItemSpellTomes75AllIllusion
    LItemSpellTomes75AllDestruction
    LItemSpellTomes75AllConjuration
    LItemSpellTomes75AllAlteration
    LItemSpellTomes75Alteration
    LootPerkGoldenTouchChange
[//]: # (                                                             }}})

For TES4 the max value is 99, although there are a few above 94:

    SE38ItemList98             98
    SELL1LootWeapon0Magic05    95
    SELL1LootArmorLightMagic05 95
    SELL1LootArmorHeavyMagic05 95
    SELL1LootArmorAllMagic05   95
    SE38Item3Amber             99
    LL1LootArmorHeavy05        95
    LL1LootWeapon0Magic05      95
    LL1LootArmorLightMagic05   95
    LL1LootArmorHeavyMagic05   95
    LL1LootArmorAllMagic05     95

# [18/04/2020] `NPC_` and `CREA` with `marker_creature.nif` model

## Inventory, `LVLN`, `LVLC` and `marker_creatue.nif`

The issue with only females appearing seems to be related to which NPC data is used when a template is used to generate an Npc or a Creature.  The original record may have spcified "male" but when a new record is selected from a template it may have "female".

The only solution here is to properly implement supporting levelled Npc and Creatues. There are some things to consider:

  * Some of the data must come from the original `ACHR` or `REFR` - e.g. position

COC "zBethOffice02"
__FIXME:__ Should have continued until the final Npc was found __FIXED__

    BethRuinsLvlRaiderBoss Hispanic NPC_ with marker_creature.nif and BaseTemplate  0002f723
    LvlRaider2SpecialVar   Hispanic NPC_ with no model            and BaseTemplate  00029620
    VarRaider2Flamer                LVLN
    /* stopped here */

__FIXME:__ original inventory (this particular new doesn't have any inventory but some may have more than original)

    BOOK BookSkillBigGuns
    LVLI
    LVLI
    LVLI
    LVLI
    KEYM

## ManualRef

We can't use the data from one `NPC_` record any more - one has to be created with data from different sources.

OpenMW creates a `ManaualRef` then calls `World::safePlaceObject()` which then calls `World::copyObjectToCell()`.  Some change will be needed since the existing code does not have any concept of worldspace and `World::positionToIndex()` uses different cell sizes. __FIXED__

## Female Head parts and FaceGen coefficients

FO3/FONV provide separate female models and textures for head parts, as well as FaceGen coefficients.  This explains why some male raiders had fenimine facical features. __FIXED__

## Visible skin mesh

__FIXME:__ Setting the race texture (both diffuse and normal/bump) results in breaking the current FaceGen code.  (and the raiders/fiends look better without FaceGen texture which is too "smooth" for some reason)

# [20/04/2020 - 22/04/2020] Back to doors

Been stuck on this for a couple of days now.  I now have a branch that instantiates each mesh for controlled nodes and attach them to bones but it has a number of issues:

  * Each `Ogre::Entity` seems to have its own skeleton instance.  Trying to share a single skeleton instance is producing strange results.
  * The nodes and meshes that are not controller targets do not move - possibly because the entities are attached to the root's skeleton instance.  It is not clear how these can share the skeleton instance of thier ancestor that _is_ a controller target (if that works at all, currently unproven). [23/04/20] this bullet point doesn't really make any sense
  * The animations are wrong.  This might be because the meshes and sub-meshes have their own transforms? But that doesn't really make sense.  Even a simple animation example such as `Dungeons\Office\Doors\OffDoorSmL02.NIF` at `zBethOffice01` which has no interpolator transforms and only has rotation keyframes. In theory rotating the bone should rotate the door mesh - but it seems to be offset by something as it rotates.  NOTE: by attaching a coffee mug to the bone ` OffDoorSmL02@#0` one can verify that the bone is in the expected place.

# [25/04/2020] Doors still

Didn't do much past few days - too depressing.  Looks like all that effort has been for naught (well, almost).  The way I understand Ogre, a skeleton's animation has node tracks for each of the bones we want to animate (for node animation, anyway). But we have some bones that are not controller targets and they don't have node animation tracks (hence they are not part of the node animations and don't move).

We need to either create node tracks using dummy interpolator values or create separate animation for these bones using `Ogre::Controller` like how the current skeletal animations are done.  If we are going to use the latter approach then why bother with Ogre's node animations at all?  May as well convert the entire thing over.

One of the things that needs to be established is - can we reliably detect all the nodes (i.e. bones) that are not controller targets but still require animation (because they are descendants of nodes that _are_ controller targets _and_ they have meshes/collision shapes). __DONE:__ but we may end up re-implementing it using the supplied object palette

## Node Animation recap

Node animation build is usualy triggered from `NiModel::loadImpl()` which calls `NiNode::build()`.  The node can have controllers, e.g `NiControllerManager` which has controller sequences, target, object palette, etc.

    openmw.exe!NiBtOgre::NiNode::build(NiBtOgre::BuildData * data, NiBtOgre::NiObject * parent) Line 799	C++

Note that the object palette will list all the sub-meshes that needs to be built - which means this can be used as a starting point of finding the bones for the skeleton.  However, it also has nodes that are controlled but doesn't have any mesh/sub-mesh e.g. block 27 "AttachSound" in `Furniture\OfficeRuined\Desk01.NIF`

The `NiControllerManager` will build each of the controller sequences.

    openmw.exe!NiBtOgre::NiControllerManager::build(std::multimap<float,std::string,std::less<float>,std::allocator<std::pair<float const ,std::string>>> & textKeys, std::vector<Ogre::Controller<float>,std::allocator<Ogre::Controller<float>>> & controllers) Line 414	C++

The `NiControllerSequence` will in turn build a controller for each of the controlled blocks.

    openmw.exe!NiBtOgre::NiControllerSequence::build(const NiBtOgre::NiDefaultAVObjectPalette * objects) Line 299	C++

Finally we build the controller.

    openmw.exe!NiBtOgre::NiMultiTargetTransformController::build(int nameIndex, NiBtOgre::NiAVObject * target, NiBtOgre::NiTransformInterpolator * interpolator, float startTime, float stopTime) Line 553	C++

## Nodes that are not controller targets

Currently only the nodes listed in the controlled blocks will have a controller built for node animation.  But we may also have nodes that are children of these moving nodes that are part of the overall animation.

It is not clear how to resolve this.  One option is to abandon this node animation solution altogether.  Another is to create dummy `NiTransformInterpolator` and `NiTransformData` to create controllers for these extra nodes (i.e. create extra targets).

Too demotivating to start all over again, so will try to stick with node animation for now.

## Skeletons for node animations only

Some NIF models have `NiControllerManager`, `NiMultiTargetTransformController`, etc, but do not have any node animations and hence do not require a skeleton.  e.g. `clutter\vintageradio\vintageradio01.nif` which does have an `niTransformController` but without an interpolator nor any associated data.

__FIXME:__ How to deal with this?  Destroy the skeleton afterwards once we know that there aren't any node animations?

# [26/04/2020 - 27/04/2020] Node hierarchy

The issue with extra controller targets for node animation is resolved (by using dummy objects).  However the animation is still wrong.  It feels as if the sub-mesh vertices are not based on local coordinates.

Some of the animations, such as simple doors, are now working.  Had to use full transform when creating a node animated sub-mesh then apply the inverse transform of the node when attaching the entity to the node (i.e. bone).  However some doors still don't work - e.g.  `Dungeons\Vault\RoomU\VGearDoor01.NIF`, `Dungeons\Vault\Halls\VDoor01.NIF`

__FIXME:__ The issue with `Dungeons\Utility\Rooms\UtlDoor01.NIF` could be due to lack of support for `LINEAR_KEY` rotation type (which I think means use "Quaternion Keys")

__FIXME:__ The issue with `Dungeons\Vault\Halls\VDoor01.NIF` could be due to lack of support for `TBC_KEY` rotation type

The TES4 activator `Architecture\Anvil\BenirusDoor01.NIF` appears almost working, however - except that the whole thing is rotated by 90 degrees.

# [28/04/2020] Node animation - too many dummies

In order to get node animation to work with some of these complicated doors and activators, several dummy objects needed to be added:

  * additional bones (but the need for additional bones might be true for skeletal animation as well)
  * dummy NiMultiTargetTransformController, NiTransformInterpolator and NiKeyframeData (NiTransformData)
  * dummy meshes because enities are needed for node animation track
  * add controllers to each of the moving nodes and their ancestors (this would also be the case for skeletal animations)
  * further duplication of code for interpolation

# [30/04/2020 - 01/05/2020] Music and resource namespace

Adding music and sounds brought up the issue of common names for resource directories.  Each game has `Music\Explore` directory of music and current game logic simply includes all the files from the matching directories.

One possibility is to remove the resource location once we move to a cell with a different game.

Another is to have the sound manager maintain a list of resource groups for searching music from different game types (and sounds I guess).

# [02/05/2020] FONV Music and Sound

Looking at the "Garden of Eden Creation Kit" the music selection logic for FO3/FONV seems to be quite different:

  * CELL: TES4 does not have XCAS sub-record for Acoustic Space; use XCMT sub-record for Music Type.  NOTE we can't detect the _lack_ of XCMT since the value may be 0.
  * CELL: FO3/FONV cells specify music type with XCMO sub-record which is a formid of MUSC records. Note some have none ("1NoMusic").  Some MUSC files specify directory (e.g. "base\") but for FONV there are no such music directory.
  * CELL: Not sure what " DEFAULT" (sic.) music type means in FO3/FONV (doesn't seem to be one of the config entries?)
  * CELL: (guess} if no music type, use the default acoustic space data which typically has region sound and ambient looping sounds.
  * Regions in FO3 can be "Audio" type while in FONV there are other types e.g. "Map", "Weather", etc
  * Not sure how to translate the music type to the correct music directory in FONV; probably something to do with ALOC and MSET but how?
  * REFR: FONV has CNAM sub-record which is a formid of an ALOC record.  These are STAT records "AudioMarker" present in dummy cell as well as internal cells.  Not sure what happens when there are more than one in active cells.

Summary:

  * use the lack of `Cell::mAcousticSpace` to detect TES4
  * use `Cell::mMusicType` for TES4
  * use `Cell::mMusic` if available for FO3/FONV (but don't know how to do folders in FONV, nor " DEFAULT")
  * maybe use the files in Music\OLD\FO3 directory somehow?
  * if no `Cell::mMusic` then use `Cell::mAcousticSpace` ambient looping sounds (take note of mIsInterior)
  * use AudioMarker REFR

# [03/05/2020] Audio Marker - try interior first

Exterior Auido Markers are in the world dummy cells.  We will need some way of determining which is the closest one from the current cell.

Interior Audio Markers are easier.  __TODO:__ test if there can be more than one in an interior cell

Above summary bullet points appear incorrect.  FONV seems to rely entirely upon Audio Marker / Media Location Controller to choose the music.

# [04/05/2020] Radio - where is the music list?

There are several vCasinoTopsSpeaker Actvators in cell `TOPSCasino`.  The base object points to radion station `vCasinoTopsRadio` which is a Talking Activator.  Its Radio Template is `AMLRadioTheTops` which is a Sound record - the trouble is that it does not list any music.  Instead it has `fx\xxx_placeholder_silence.wav`.  So, it is not clear at all how the music is selected.

Similarly with cell `ULCasino`.

It turns out that the song lists are in INFO.  They are probably linked via script in either ACTI or TACT records.

Since the INFO formid seems to be used by nothing else, it is probably the starting point.  INFO has a quest formid in QSTI - maybe lookup these?  Or maybe it all starts with the dialog "RadioHello"? - but none of the scripts seem to mention it in context of the casino radios.

Maybe the quest id's from DIAL and INFO needs to be matched?  Using `0016B66D`, "vUltraLuxeRadioQuest" as an example - it is found in:

  * DIAL RadioHello - in the quest list
  * INFO {Song 1 Concerto for 2} - quest id, conditions & subscript global reference
  * INFO {Song 2 Concerto Grosso in B Minor Allegro} - quest id, conditions & subscript global reference
  * INFO {Song 3 Concerto Grosso in B Minor Allegro 2} - quest id, conditions & subscript global reference
  * INFO {Song 4 Flower Duet} - quest id, conditions & subscript global reference
  * INFO {Song 5 Four Seasons} - quest id, conditions & subscript global reference
  * INFO {Song 6 Piano Concerto No 21} - quest id, conditions & subscript global reference
  * INFO {Song 7 Spring Song} - quest id, conditions & subscript global reference
  * QUST vUltraLuxeRadioQuest formid

They match ok, but what starts it off?  Something must be "choosing" the RadioHello topic to trigger the responses?  Anyway, one of the INFO would be selected based on the conditions.

Noticed that TACT 0016B46E is referred in QUST 0016B66D vUltraLuxeRadioQuest CTDA.  Its model is a terminal (not a vintage radio) and it is positioned under the casino floor, near Mortimer.

Guess: So, something kicks off RadioHello (auto-start somehow, or maybe all dialogs run all the time?).  Then DIAL goes through the quests and the associated INFO for the quest.  It then checks the conditions to choose a response.  The first parameter of the INFO condition is the QUST that refers to the TACT to be instantiated (I'm guessing GetIsID means that).

    CELL ULCasino
         ...
         REFR 0016B6D4
              NAME 0016B66A (ACTI vCasinoUltraLuxeSpeaker)
         REFR 0016B74B
              XRDO radio station data
              NAME 0016B46E (TACT vCasinoUltraLuxeRadio)
         ...

    ACTI 0016B66A vCasinoUltraLuxeSpeaker
         SCRI 000770C6 (SCPT VintageRadioStartOnSCRIPT)
         RNAM 0016B46E (TACT vCasinoUltraLuxeRadio)

    SCPT 000770C6 VintageRadioStartOnSCRIPT
         SCHR header
         SCDA compiled script
         SCTX /* init then activate (presumably activate vCasinoUltraLuxeSpeaker) */
         ...

    scn VintageRadioStartOnSCRIPT                                     {{{)

    short init
    ref mySelf

    ;**********************************

    Begin onLoad

        if (init == 0)
            set mySelf to getSelf
            activate mySelf
            set init to 1
        endif

    End

    ;**********************************

    Begin onActivate

        activate

    End

    ;**********************************
    end                                                               }}})

    TACT 0016B46E vCasinoUltraLuxeRadio
         SCRI no script
         VNAM 0000002D voice type
         INAM 0015D39C radio template (SOUN AMLRadioLarge)

    (unchecking "Cont. Broadcast" and saving to an ESP does not change anything other than record flags)
         flag 00000200 On Local Map
              00000400 Quest Item
              00002000 No Voice Filter
              00010000 Random Anim Start
              00020000 Radio Station
              10000000 Non-Proxy (only valid if Radio Station)
              40000000 Cont. Broadcast (only valid if Radio Station)

    TACT 0016B46F vCountryRadio
         SCRI no script
         VNAM 0000002D voice type
         INAM 0004EC8A radio template (SOUN AMLRadio)
         OBND FFEEFFF4 0034FFE9 00130016

    SOUN 0004EC8A AMLRadio
         FNAM fx\xxx_placeholder_silence.wav
         RNAM (null)
         SNDD ...

    /* how to link? */

    DIAL 00000126 RadioHello
         type 7 (radio)
         mQuests[i]        = 0016B66D <- INFO QSTI and INFO.mSubScripts[0].globReference
         mQuestsRemoved[i] = ?

    INFO 0016B743 <- this formid only occurs once (as part of this INFO record)
         QSTI 0016B66D (QUST vUltraLuxeRadioQuest)
         TRDT.sound 0016B079 (SOUN)
         SCRO 0016B66D (QUST vUltraLuxeRadioQuest)
         CTDA 20       not equal to AND
               0000000
              3F800000 comparison (1.0)
              0000004F function 0x4F = 79 (GetQuestVariable)
              0016B66D param1 (formid of QUST vUltraLuxeRadioQuest)
              00000001 param2 (variable 1)
              00000000 run on
              00000000 reference formid
         CTDA 20       not equal to AND
                000000
              3F800000 comparison (1.0)
              0000004F function 0x4F = 79 (GetQuestVariable)
              0016B66D param1 (formid of QUST vUltraLuxeRadioQuest)
              00000002 param2 (variable 2)
              00000000 run on
              00000000 reference formid
         CTDA 20       not equal to
                000000
              3F800000 comparison (1.0)
              0000004F function 0x4F = 79 (GetQuestVariable)
              0016B66D param1 (formid of QUST vUltraLuxeRadioQuest)
              00000003 param2 (variable 3)
              00000000 run on
              00000000 reference formid

    INFO 0016B744   00169BDF
         0016B745   00169BE0
         0016B746   00169BE2
         0016B747   00169BE3
         0016B748   00169BEC
         ^          ^
         |          +---- TRDT.sound (formid)
         +--------------- INFO (formid)

    QUST 0016B66D vUltraLuxeRadioQuest
         SCRI 0016B66F (SCPT vUltraLuxeRadioQuestSCRIPT) <- this just exposes 3 variables for INFO subScripts
         DATA flags, priority, delay
         CTDA 00       equal to
                000000 padding
              3F800000 comparison (1.0)
              00000048 function 0x48 = 72 (GetIsID)
              0016B46E param1 (formid of a TACT)
              00000000 param2
              00000000 run on
              00000000 reference formid

    QUST 0016B66C vGomorrahRadioQuest
         SCRI
         DATA
         CTDA

    QUST 0016B66E vCountryRadioQuest
         SCRI
         DATA
         CTDA 00       equal to
                000000 padding
              3F800000 comparison (1.0)
              00000048 function 0x48 = 72 (GetIsID)
              0016B46F param1 (formid of a TACT vCountryRadio)
              00000000 param2
              00000000 run on
              00000000 reference formid

    SOUN 0016B079 songs\radionv\mus_concerto_for_2_vl_str_in_d_minor.mp3
         00169BDF songs\radionv\mus_concerto_grosso_in_b_minor_allegro_01.mp3
         00169BE0 songs\radionv\mus_concerto_grosso_in_b_minor_allegro_02.mp3
         00169BE2 songs\radionv\mus_flower_duet_lakm_kpm.mp3
         00169BE3 songs\radionv\mus_four_seasons_no_4_the_winter.mp3
         00169BEC songs\radionv\mus_piano_concerto_no_21__elvira_madigan.mp3
         ^        ^
         |        +---- FNAM (string mSoundFile <- yes!)
         +------------- SOUN (formid)

__TODO:__ In Fallout.esm `vCasinoTopsRadio` only has EDID, FULL, MODL, OBND, VNAM and INAM.  But in the GECK there are several flags including "Radion Station" and "Cont. Broadcast" - not sure where these come from.

__FIXME:__ CTDA needs adjust param1 formid depending on the function (I think?) How to do this without a function type lookup table?

# [05/05/2020] Dialogue Manager

Not sure how to deal with this one. A quick look through the code seems to indicate that the current system is designed around dialogue for the player.

# [06/05/2020] Bit shuffling

Refactored ESMStore and ForeignStore (still a work in progress).

# [07/05/2020 - 08/05/2020] NVRadio

Going back to deciphering the logic.

The quest `vUltraLuxeRadioQuest` has "Start Game Enabled" and "Allow repeated conversation topics" flags.  This may mean that the quest is running all the time but applies to the condition that runs only on `vCasinoUltraLuxeRadio`.  How to implement this?

We can't get the TACT to check all the running quests since the `vCasinoTopsRadio` is in fact in the outside cell - in the vanilla game if you `COC "TopsCasino"` from outside Novac (or even from inside the gift shop) you still hear the radio.

The only other way must be that the quest `TopsRadioQuest` checks that `vCasinoTopsRadio` is __defined__ in the game.  Remember that this quest (like many others, e.g. `vCountryRadioQuest`) has the "Start Game Enabled" flag.  But then why bother checking?  Barring a bug it __will__ be defined in the game.  As mentioned above, it isn't checking that the TACT is in the current cell, nor checking any proximity (not that I can see).

Maybe the trigger comes from the speakers?

    ACTI 0016B66A vCasinoUltraLuxeSpeaker
         SCRI 000770C6 (SCPT VintageRadioStartOnSCRIPT)
         RNAM 0016B46E (TACT vCasinoUltraLuxeRadio)

If so the logic should be:

  * When the current cell changes check the activators in the new cell.
  * If there are radio stations (i.e. the ones with RNAM) see if there are running quests looking for a matching condition (which should be all of the ones with "Start Game Enabled" flag, probably all the radio ones).
  * If there is a match, look for "RadioHello" topic for the radio quest.

# [09/05/2020] Region sounds

__FIXME:__ SoundManager crash at exit
__FIXME:__ Momentary stutter (i.e. low FPS) when env sound is played
__FIXME:__ TES4 external cells env sounds

__TODO:__ env sound start point - not sure if the supplied value is the % of the length

# [10/05/2020] Containers and sound effects

To get containers to work with the Morrowind UI, we need a few methods to be implemented in addition to the usual:

```cpp
virtual int getValue (const MWWorld::Ptr& ptr) const;
virtual std::string getUpSoundId (const MWWorld::Ptr& ptr) const;
virtual std::string getDownSoundId (const MWWorld::Ptr& ptr) const;
virtual std::string getInventoryIcon (const MWWorld::Ptr& ptr) const;
```

For picking up objects in TES4, had to hard-code editor id's to choose the sound formid.  Not sure how else to get the correct sound.

FO3 container sounds are specified as text keys in the NIF models. __FIXME__

FONV seems to specify the open/close sounds for some (e.g. cash register) but need to fallback to checking text keys for others (e.g. filing cabinets).

# [11/05/2020] World Dummy Cell design

__NOTE: the interaction diagrams from [31/03/2020 - 02/04/2020] are now outdated__

Current call stack: (NOTE: loadDummy is now in ForeignStore)

     openmw.exe!MWWorld::CellStore::loadTes4Record(const MWWorld::ESMStore & store, ESM::ESMReader & esm) Line 1018	C++
     openmw.exe!MWWorld::Store<MWWorld::ForeignCell>::loadDummy(MWWorld::ESMStore & store, ESM::ESMReader & esm, MWWorld::CellStore * cell) Line 1481	C++
     openmw.exe!MWWorld::ESMStore::loadTes4Group(ESM::ESMReader & esm) Line 315	C++
     openmw.exe!MWWorld::ESMStore::load(ESM::ESMReader & esm, Loading::Listener * listener) Line 140	C++
     openmw.exe!MWWorld::EsmLoader::load(const boost::filesystem::path & filepath, std::vector<std::vector<std::string,std::allocator<std::string>>,std::allocator<std::vector<std::string,std::allocator<std::string>>>> & contentFiles) Line 62	C++
     ...

Only `FXInvertedDaylightWorld`, "Holder Space for Inverted Region" does not have a wrld dummy cell.  All others have at least one Audio Marker (except FFEncounterWorld and TestMap01).

__See the notes from 07/04/20 - 08/04/20__

Need a map of REFR/ACHR/ACRE keyed on cell grid.  Maybe per type?  e.g. statics and trees vs npcs and creatures.

So when cell x,y becomes active statics/trees from a configurable distance can be rendered.

Will need to render the models without physics and without making them a `Ptr`, etc, etc.

## Not really a `CellStore`?

`CellStrore` keeps lists of `CellRef`.  However do we want to store `CellRef` or just the base data, especially since many of the statics will only be rendered with a low-poly mesh, anyway?

## Reference types

  * Low-poly mesh terrain for far distance
  * Terrain (without physics) for medium distance
  * Terrain for active cells
  * Low-poly statics/trees for far distance (trees rendering different for Tamriel cf. other worlds)
  * Statics/trees (without physics) for medium distance
  * All objects for active cells

We will need to modify `NiModel` so that simple mesh without FaceGen, animation, etc, are available for LOD.

The relevant `Oblivion.ini` entries for low-poly tree rendering are:

    [General]
    uGridDistantTreeRange=15
    uGridDistantCount=25
    uGridsToLoad=5
    uGridDistantTreeRangeCity=4
    uGridDistantCountCity=4

The "counts" are probably for speed tree.

The types seem to be as per below config entries:

    [LOD]
    ...
    fLODMultLandscape=1.0000
    fLODMultTrees=1.3000
    fLODMultActors=7.0000
    fLODMultItems=7.0000
    fLODMultObjects=7.0000
    ...

Skyrim doesn't have `fLODMultLandscpe` nor `fLODMultTrees` but instead has `fLODFadeOutMultSkyCell`.  That might be referring to its low-poly landscape mesh (remember it has a tree-like structure unlike other games).

    [Display]
    ...
    fTreesMidLODSwitchDist=9999999.000
    ...

    [LOD]
    fLODFadeOutMultSkyCell=1.0000
    fLODFadeOutMultObjects=5.0000
    fLODFadeOutMultItems=1.5000
    fLODFadeOutMultActors=5.0000

## `.lod` files - only for Oblivion?

FO3, FONV and Skyrim don't have these (well, Skyrim has a few `.lod` files under `lodsettings\` but the contents look like the `.cmp` files from Oblivion).  FO3 and FONV also has `lodsettings\` folder (in Fallout - Misc.bsa) and the filenames are `.dlodsettings` just to make it more complicated.

So the use of `.cmp` files, or equivalent, seem universal.  __This means we need a way to quickly scan the specified locations for lod objects__

  Game     |  BSA              |  Folder     | filename
  ---------|-------------------|-------------|--------------
  Oblivion | Oblivion - Meshes | distantlod  | .cmp
  FO3/FONV | Fallout - Misc    | lodsettings | .dlodsettings
  Skyrim   | Skyrim - Meshes   | lodsettings | .lod

Note that a DLC can have its own `lodsettings\` folder, e.g. `PointLookout - Main.bsa`

__NOTE: 06/06/20__ FO3/FONV/Skyrim's `dlodsettings` or `.lod` files do _not_ list distant statics. See notes from 29/03/20 for the format

## Record types

Record types found in Oblivion.esm world dummy cell:

    REFR SOUN
    REFR ACTI
    REFR CONT
    REFR DOOR
    REFR LIGH
    REFR MISC
    REFR STAT
    REFR TREE
    REFR FLOR
    REFR FURN
    REFR WEAP
    ACHR NPC_
    ACRE CREA
    REFR LVLC
    REFR SBSP

Additional record types found in Fallout3.esm:

    REFR ARMO
    REFR AMMO
    REFR KEYM
    REFR ALCH
    REFR IDLM
    REFR MSTT
    REFR TERM
    REFR TACT
    REFR PWAT

For LOD, start with DOOR, STAT and TREE (maybe FLOR, MSTT and PWAT later).  Others (e.g. ACTI, FURN, TERM and TACT) are probably too small.

# [12/05/2020] World Dummy Cell implementation

Initial attempt is to create a new class `DummyStore` which is fashion on `CellStore`.

The first issue is that the actors defined in the dummy cell are no longer in a game "cell" (in fact they were never in it - I just failed to notice it).  I will need to devise some scheme to place them in the appropriate active cell.  Current code simply assumes that a `Ptr` will be associated with a `CellStore`.

So, we have a couple of options:

  1. Make `DummyStore` a `CellStore` (presumably via inheritance)
  2. Instantiate actors then move them to active cells.

__TODO:__ This leads to the question of how to deal with actors that are not in an active cell - they all have schedules, etc.

## Persistent but only for References?

There are actors in dummy cells.  These actors can move to another cell - that means the dummy cell now has "state" info which needs to be saved.

# [13/05/2020] World Dummy Cell - back to `CellStore`?

OpenMW code relies on `Ptr` and `CellStore` relationship.  It is looking like too much effort to break that.  One example is unloading cells in `MWWorld::Scene` - `CellStoreCollection::iterator` is used to call functor `ListAndResetHandles`.  Either `DummyStore` has to implement something similar or it has to fit into `CellStoreCollection`.

  * Objects::mCellSceneNodes is used for choosing which `Ogre::SceneNode` to use for inserting a new child scenenode and when updating Ptr movements between CellStore (called by `World::moveObject()`).
  * `if(world->isUnderwater(ptr.getCell(), pos) || world->isWalkingOnWater(ptr)) /* get correct sounds, update drowning */`
  * `MWWorld::Ptr placed = MWBase::Environment::get().getWorld()->safePlaceObject(ref.getPtr(), ptr.getCell() , ptr.getCellRef().getPosition());`
  * `const std::string& playerCell = MWBase::Environment::get().getWorld()->getCellName(player.getCell());`
  * `if (!mPtr.getCell()->isExterior()) /* gui travel window, getting region when waiting, update actor head tracking (apparently done different when exterior), updating actors for sun damage, various AI packages */` pathfinding, etc, etc

## A new base class or inherit from `CellStore`?

Or another option is to find a way to index `std::list` (impossible?).

Or simply do away with `std::list` - if we assume that there won't be many insert/delete in a cell, we can simply keep adding to a vector and mark any deleted records as such (vector deletion won't be very efficient).

Note that insertions occurs from the classes, calld from `World::copyObjectToCell()` and `World::moveObject()`, e.g.:

```cpp
MWWorld::Ptr ForeignActivator::copyToCellImpl(const MWWorld::Ptr &ptr, MWWorld::CellStore &cell) const
{
    MWWorld::LiveCellRef<ESM4::Activator> *ref = ptr.get<ESM4::Activator>();

    return MWWorld::Ptr(&cell.getForeign<ESM4::Activator>().insert(*ref), &cell);
}
```

__FIXME:__ need to add code to update the indices in `CellStore` after the insertion. __FIXED:__ updateLookupMaps()

# [13/05/2020 - 15/05/2020] World Dummy Cell - world of issues

Spent most of 13/05/20 debugging weird issues where physics would not work sometimes, etc.  Had to re-implement in small increments to track down the cause.  Strangely, for the physics issue, had to insert the "foreign" objects in `CellStore::forEach()` - still no idea why this is needed. __FIXED: 16/05/20__

Another: `ACHR` with formid 0006C35E in Vilverin results in "Error in framelistener: Bad LiveCellRef cast to struct ESM4::Npc from struct ESM4::Npc".  Its base object is an `NPC_` with formid 0006C35D, and editor id "VilverinBanditFurnitureKhajiit". __FIXED: 15/05/20__ not really "fixed", but to resolve this had to keep using std::list in `CellRefList`

__TODO:__ can't remember how levelled actors are generated

__TODO:__ trees are not inserted as index map insertion was way too long

__TODO:__ replace objects should be marked as such __DONE__ actually replaced rather than marking the record

__FIXME:__ `PhysicsSystem::addObject()` never clears `handleToMesh[]` (also noted on 04/03/20)

# [16/05/2020] Physics issues and `CellStore::forEach()`

A crash happens in `RigidBodyState::setWorldTransform()` where `mSceneNode->getParentSceneNode()` returns a nullptr.  Need to investigate how `mSceneNode` is set.

It looks like the issue might be that sometimes the physics collision shapes are not being deleted.

    CellStore *Scene::updateWorldCellsAtGrid (ESM4::FormId worldId, int X, int Y)
    void Scene::changeToForeignInteriorCell (const std::string& cellName, const ESM::Position& position)
    void Scene::changeCellGrid (int X, int Y)
    void Scene::changeToInteriorCell (const std::string& cellName, const ESM::Position& position)
    void Scene::changeToVoid()
        void Scene::unloadCell (CellStoreCollection::iterator iter)
            mPhysics->removeObject (node->getName());

    MWWorld::Ptr World::moveObject(const Ptr &ptr, CellStore* newCell, float x, float y, float z)
    void World::disable (const Ptr& reference)
    void World::deleteObject (const Ptr& ptr)
        void Scene::removeObjectFromScene (const Ptr& ptr)
            mPhysics->removeObject (ptr.getRefData().getHandle());

First guess would be either `updateWorldCellsAtGrid()` or `changeToForeignInteriorCell()` doing something different.  To test, disable loading the dummy cell and visibly distant cell in `updateWorldCellsAtGrid()`.  Surprisingly the issue persists.  The testing sequence:

  1. COW "ICMarketDistrict" 8 17
  2. COC "Vilverin" (doors don't work without dummy cell being loaded)
  3. COW "ICMarketDistrict" 8 17
  4. COC "ICMarketDistrictAFightingChance"
  5. go outside using an internal door
  4. COC "ICMarketDistrictThreeBrothersTradeGoods"

By using the console command `TCG` some of the items that looks to be from "A Fighting Chance" can be seen in "Three Brothers Trade Goods".  So it might have been using the door to go out from "A Fighting Chance"?  If so the culpit would be`updateWorldCellsAtGrid()`.  Going out the door from "A Fighting Chance" is the block of code with the condition `if (worldId != currentWorldId)`.

Ok, the issue is this block of code.  Because the handles from foreign `CellRefList<X>` are not being collected in the `functor`, they never get removed.

```cpp
void Scene::unloadCell (CellStoreCollection::iterator iter)
{
    std::cout << "Unloading cell\n";
    ListAndResetHandles functor;

    (*iter)->forEach<ListAndResetHandles>(functor);
```

# [16/05/2020 - 19/05/2020] Updating the Dummy Cell

As the player moves around the external cells the dummy cell needs to be updated - references within a certain distance needs to be instantiated and others removed.

We need a search function that will return:

  * all the records that needs to be instantiated
  * all the records that needs to be visible without physics

We then need to compare against the current set of records to decide which ones to remove, which ones to create and which ones will remain as they are.

## Cell loading time

Not all objects require indexing - statics and trees in a cell will probably only require sequential access for creating and deleting them (unless they're in a dummy cell, in which case they need to be indexed for grid positions).  Actors and inventory items, however, would be different.   This will provide a minor reduction in cell loading times.  To do this some thought needs to go into how to deal with getting object formid while in console mode - either bulk create indices (for statics, etc) for the current cell when the console is invoked, or make it a debug option to enable at the start time.  Or maybe even create a special console command to update the indices.  Yet another approach might be to have the loading done in a separate thread so that a little longer loading time does not matter at all.

## Updating Dummy cell objects

Removing objects as they become far away from the player's current cell appears non-trivial.  Current OpenMW code calls `Scene::unloadCell` which then calls a number of managers including mechanics manager, sound manager, physics, scripts, etc.

I had thought about trying to avoid writing specific code to remove the objects by placing the objects in other active cells, but then they will no longer be "persistent" and will have re-create them each time?  Also, what about the visibly dist objects without physics (they aren't in active cells)?

So I will have to implement something like `unloadObjects()` or similar.  Because of the need to access the managers, it will need to be called from `MWWorld::Scene`.  A broad outline would be:

  * get which objects need to be removed from they dummy CellStore
  * update the indices while getting the objects (e.g. for the handles, formid, store type, etc)
  * remove the objects

It turns out that there's already `void Scene::removeObjectFromScene (const Ptr& ptr)` which can be used if there'a functor that returns all the objects that needs to be removed.  It's a shame that a `Ptr` needs to be constructed for each object - maybe another method that will accept a `LiveCellRefBase*` should be created?  It also doesn't deal with physics child objects (yet).

__FIXME:__ `CellStore::hasFormId()` is not being used
__FIXME:__ `CellStore::preload()` does not support newer games (TES4, FO3, FONV, etc)

# [20/05/2020 - 21/05/2020] LOD Landscape

## Hysteresis revisited

__FIXME:__ distant landscape near Namira's shrine (11, 34) has a gap __FIXED__
__FIXME:__ going from AnvilWorld to outside does not add LOD landscape mesh __FIXED__

Unlike the notes from 06/04/2020, I now think the loading should happen _before_ unloading.

IDEA: assuming this method gets called each time the player's cell changes, put priority based on distance and add/delete one at a time - which means 4 cell changes are required before they are fully refreshed at a "corner" case.

## Viewing distance

With range 2, try:

    max viewing distance = 152600
    viewing distance = 139600

or to be a little closer to vanilla:

    max viewing distance = 142600
    viewing distance = 99600

FPS is around 27 at (12, 1) with range 2, going up to around 31 with range 1;

## FO3/FONV Landscape LOD

Looking at the BSA files the block size appear to be 16x16, 8x8 and 4x4 cells.  Possibly some kind of quad-tree.

# [22/05/2020 - 25/05/2020] Distant Statics

__FIXME:__ animation broken since ee64b18bb1552374aae498b1e7ea0263be11bbb0 - disabling the "insert without physics" in the dummy cell stops the crash __FIXED:__ well, avoided by not loading any actors without physics.

Had an idea about distant statics - along with implementing the visibly distant statics with `.lod` and `.cmp` files, a modified CellStore could be used to load just the statics and trees (and terrain?) without any physics.  It may even be possible to simplify the terrain mesh on the fly. __NOTE:__ it tuns out that vanilla doen't bother adding statics (e.g. rocks) beyond the loaced cells.

## `.lod` files in TES4

The positions of some entries seem incorrect.  e.g. see the left tower sunken too low - COW "OblivionMQKvatch" 0 0

I'm also guessing that scale of 0.f actually means 1.f and it has to be divided by 100 to get the actual scale?

Maybe abandon the use of the `.lod` files and use the entries in the visibly distant cell groups, based on the grids indicated in the `.cmp` files, instead?

## Oblivion comparison

It's depressing - the console command TDT shows approx 250 FPS without trees (bEnableTrees=0) :-(

## FO3 and FONV

These don't seem to have "visibly distant" cell groups at all.

The landscape LOD low-poly meshes seem to be organised in 4x4, 8x8, 16x16 and 32x32 cell blocks.  Quad tree of some sort?

## CellStore rethink

Rather than keep separate CellStores for visibly distant objects, maybe keep all the objects in one CellStore but keep separate indices for temporary, persistent and visibly distant child groups.

# [25/05/2020 - 27/05/2020] Distant Statics again

Spent the last few days getting side tracked on dummy cell code refactoring (and being stumpted by hidden bugs).

Given the position (and scale?) issues with the `.lod` files a new implementation will be attempted.  Instead of using the data in the `.lod` files, use the visibly distant cell group children of the cells indicated in the `.cmp` file for the world.

We can even try to mimic the quad-tree like landscape LOD in FO3/FONV, i.e. add more statics based on distance

    |                              |                               |
    | (-32,32)                     | (0,32)                        | (32,32)
    +------------------------------+---------------+---------------+--------
    |                              |               |               |
    |                              |               |               |
    |                              |               |               |
    |                              |               |               |
    |                              |               |               |
    |                              |               |               |
    |                              +---------------+-------+-------+
    |                              |               |       |       |
    |                              |               |       |       |
    |                              |               |       |       |
    |                              |               +-------+---+---+
    |                              |               |       | @ |   |
    |                              |               |       +---+---+
    | (-32,0)                      | (0,0)         |       |   |   | (32,0)
    +------------------------------+---------------+-------+---+---+--------
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    |                              |                               |
    | (-32,-32)                    | (0,-32)                       | (32,-32)
    +------------------------------+-------------------------------+--------

Above diagram assumes (to be tested) that the loaded terrain can be next to either 4x4 or 8x8 landscape LOD mesh.  It could be that the loaded terrain can only be next to a 4x4 mesh - which will result in 4x4-1 = 15 level4 blocks and no real need for level8 blocks.  i.e. given that level8 blocks exist the initial assumption might be the correct one.

Looking at FONV watelandnv there are 16 level32 blocks, 64 level16 blocks, 256 level8 blocks and _lots_ of level4 blocks.

## FIXME

__FIXME:__ COC "FortVariela" mesh name "meshes\\dungeons\\misc\\necrotapestryskinned01.nif#0%NecroTapestrySkinned01" Results in `Ogre::Mesh::softwareVertexBlend()` throwing an exception due to the lack of blend weights, etc.

This one is a skinned mesh, one of those that relies on Havok to move the self-made skeleton. The issue must be that we are reporting to Ogre that the mesh has animation even though it relies on Havok for animation instead.

I suspect Ogre tries to animate all `Ogre::Entity` that has a skeleton or has vertex animation (see `Entity::_updateRenderQueue()`).  So this is tricky - we want to have a skeleton for Havok animation but that will confuse Ogre.

Worked around by stop setting the skeleton name for skinned meshes (see `NiBtOgre::NiTriBasedGeom::buildSubMesh()`).  Seems ok but not sure if this will break something else.

__FIXME:__ loading terrain and landscape LOD near the "32" cells boundary appear broken.  Test by going into Cheydinhal starting from COC "Tamriel" 27 22

__FIXME:__ door mRefID="AnutwyllExRef", mFormId = 0x00017571, mBaseObj = 0x0002eed2 seems to have an empty AABB Seems to be related to the experimental change in `CellRefList::search()`. Reverted the change for now, needs more testing and debugging.

# [28/05/2020 - 3/06/2020] Terrain texture

Terrain is one of the first things on TES4 to be implemented, in OpenCS, way back in 2015.  I cannot remember why the TES4 terrain related classes were structured in such a convoluted way (possibly to support both OpenCS and OpenMW?).  To get an idea:

          Terrain::Storage -------------------o Terrain::World
                 ^                                 ^     ^
                 |                                 |     |
        ESMTerrain::Storage                       /       \
                 ^                               /         \
                 |                              /           \
                 |                Terrain::TerrainGrid  Terrain::DefaultWorld
        MWRender::TerrainStorage           o                     o
                                           |                     |
                                  Terrain::GridElement  Terrain::QuadTreeNode
                                           o                     o
                                           |                     |
                                     Terrain::Chunk        Terrain::Chunk


                ESM4::Land                     Terrain::Storage              Terrain::TerrainGrid
                    ^                                 ^                               ^
                    |                                 |                               |
              ESM4Terrain::Land              ESM4Terrain::Storage         ESM4::Terrain::TerrainGrid
                  ^    ^                           ^     ^                (maybe inherit directly
                  |    |                           |     |                 from Terrain::World?)
                 /      \                         /       \
                /        \                       /         \
               /          \                     /           \
        CSMForeign::    MWWorld::       CSVForeign::       Foreign::
        Land            ForeignLand     TerrainStorage     TerrainStorage


## Texture Quadrants

How to implement this?  Either create a `SceneNode` for each quadrant or we need to create a composite texture for each layer, including the base.

The initial result of trying a composite texture is not so good - it looks like each of the base textures need to be loaded and then each pixel copied across.  Can't figure out how to use `blit()` since each of the `Ogre::HardwarePixelBuffer` for the texture has box dimention of (0,0,1,1)?

Also, once the pixels are copied across the texture details are lost (kinda like how the FaceGen texture details being lost).  Not sure why, but it may be due to the texture format being used?

May have to try creating 4 separate quadrants.

## Lack of Base Texture

How to handle this?  Is there a default texture?  Looking at a few samples when there is no base texture there aren't any other texture for that quadrant, either.  e.g. Tamriel 5 15, LAND 0x000075DB which I think is near Talos Plaza

For now, we'll try using `TerrainHDDirt01.dds` 0x000008C0 as the default base texture. (in the CS that's what the "-NONE-" selection looks like)

## TerrainGid, DefaultWorld or TES4World?

Or both?  Start with TerrainGrid, but some code from DefaultWorld and/or QuadTreeNode will be needed (e.g. for composite texture).

Not sure at this stage whether another one, e.g. `Terrain::TES4World` will need to be created.  For now will try to fit in with existing implementation.

That means, for TerrainGrid, we need to modify ESM4Terrain::Storage to supply blendmaps and layerList, but with composite textures.  This may turn out to be overly complicated.  Will still need to check for unique textures in case they are used in different layers in the same cell.

## Indexing differences

Ogre::PixeBox starts at __top__ left corner while the VTXT sub-record starts at __bottom__ left corner.  Not so sure about the textures.

## Unique textures

Due to TES4 applying textures per quadrant, they may need to be combined into one.  Not sure of the performance impact of doing so - but typically there's only 9 or so cells loaded at one time so hopefully any impact won't be too noticeable.

Alternatively, we can try to keep one texture per layer (but scaled and indexed according to the quad position) - in pathological case that could end up being 9 x 4 = 36 layers if not combining the additional layer textures.

Some quick testing suggests that many cells have up to 13 unique textures (on top of the base textures).  It also shows that the unique textures are not always at the same layer (e.g. see LAND 0x0000757F, texture 0x0x0004f9e3 are sometimes on layer 0 and other times on layer 1).

So the choice is between:

  1. composite base and up to 13? layers, or
  2. composite base and up to 9 composite layers

The first implementation to try is option 1.

## Texture mapping

The landscape textures for each quadrant are 512x512 but the a quadrant's size is 2048x2048.  Are the textures meant to "stretch" to fit one per quadrant or repeat 4x4 times?  Looking at the CS - the broken Wayshrine in cell (12,1), there are roughly 3 repeating patterns for the diameter of the Wayshrine.  That implies the textures are not "stretched" but "wrapped".

## BufferCache size

This needs to change (i.e. smaller) for the quads.

## Issues that need investigations and/or fixing

  1. The `Ogre::AxisAlignedBox` calculation appear incorrect, causing strange culling problems (quad render disappearing when not directly looking at it).  For now work around the issue by making the AABB larger (the cell size).  The issue might be due to box orientation being different to the positions of the quads.

  2. ~~Similar issue exists with the position of the `SceneNode` for the quads.~~ __FIXED:__ well, not fixed but the issue moved to `fillQuadVertexBuffers()`, see below.  (if done here then the quads appear wrong)

  3. For some reason the quad positions 1 (bottom right) and 2 (top left) need to be swapped to get the correct heights and weird culling issues (actually culling issues stil exist, but even the workaround sometimes fails without the swap).  See `getMinMaxQuadHeights()` and `fillQuadVertexBuffers()`.

  4. The order of VTXT values does not match the expectation.  The position indices are supposed to start from the bottom left corner, but it seems to start from the top left corner instead.  See `getQuadBlendmaps()`.

  5. ~~The layers for cell (27,21) seems to be mixed up - small pebbles are seen in the middle when the large ones should be.~~ __FIXED:__ the issue was using wrong texture scaling for additional passes, due to the initial experimental code haniging around unnoticed

  6. Non-shader version of terrain material no longer works.

  7. Cell -9 19 terrain in TES4 looks odd (see screenshot)

  8. `ESM4::LandTexture::mTextureSpecular` is not used (maybe only applies to the base texture?)  Similarly, potential grass is not handled.

  9. FO3 and FONV use `TXST` record for the land texture, using one more level of indirection.

  10. FO3 and FONV use `_lod.nif` rather than `_far.nif` for the low-poly mesh.  Not sure how to distinguish TES4 and FO3/FONV.

  11. Not sure what is the correct default texture for FO3/FONV.

  12. There are some very dark patches e.g. COC "WastelandNV" -9 3 Load base texture and 2 additional layers (0 and 1) to see the difference.  Also see just outside Anvil gates.  It could be some textures are somehow rendered very dark by Ogre.

## Unrelated FIXME

Container store related to foreign NPC custom data crash at exit.

# [06/06/2020] TE5 Animation

## Bone name differences

The following methods have hard-coded "Bip01 " (note the space):

    bool CharacterController::updateWeaponState()
    void CharacterController::updateHeadTracking(float duration)

    void RaceSelectionPreview::updateCamera()

    size_t Animation::detectAnimGroup(const Ogre::Node *node)
    ForeignCreatureAnimation::ForeignCreatureAnimation(const MWWorld::Ptr &ptr, const std::string& skeletonModel)
    void ForeignCreatureAnimation::addAnimSource(const std::string &skeletonName)
    void ForeignNpcAnimation::updateTES4NpcBase()
    void ForeignNpcAnimation::updateFO3NpcBase()
    NifOgre::ObjectScenePtr ForeignNpcAnimation::createMorphedObject(const std::string& meshName,
        const std::string& meshName, const std::string& group, NiModelPtr skeletonModel)
    NifOgre::ObjectScenePtr ForeignNpcAnimation::createObject(const std::string& meshName,
        const std::string& group, NiModelPtr skeletonModel, const std::string& raceTexture)
    void ForeignNpcAnimation::addForeignAnimSource(const std::string& model, const std::string &animName)
    Ogre::Vector3 ForeignNpcAnimation::runAnimation(float timepassed)
    Ogre::Vector3 NpcAnimation::runAnimation(float timepassed)
    void WeaponAnimation::pitchSkeleton(float xrot, Ogre::SkeletonInstance* skel)

    std::pair<MWWorld::Ptr,Ogre::Vector3> World::getHitContact(const MWWorld::Ptr &ptr, float distance)

    void NiBtOgre::BtOgreInst::instantiateBodyPart(Ogre::SceneNode *baseNode, Ogre::Entity *skelBase)
    void NiBtOgre::TransformController::Value::setValue (Ogre::Real time)

TES4 `characters\_male\skeleton.nif` has:

    Bip01
    Bip01 Tail03
    Bip01 Tail06
    Bip01 L Finger41
    Bip01 R Finger42
    Bip01 R Finger01
    Bip01 L Finger0
    Bip01 L Finger22
    Bip01 R Toe0
    Bip01 L Toe0
    Bip01 L Finger12
    Bip01 Tail07
    Bip01 L Finger02
    Bip01 L Finger01
    Bip01 R Finger2
    magicNode
    Bip01 R Finger31
    Bip01 R Finger21
    Quiver
    Bip01 L Finger31
    Bip01 Tail04
    Bip01 R Finger3
    Camera01
    Bip01 R Finger11
    Bip01 Tail08
    Bip01 Tail02
    Bip01 Tail01
    Bip01 L Finger2
    Bip01 TailRoot
    Bip01 R Finger22
    Bip01 L Finger3
    Bip01 Tail05
    Bip01 L Finger32
    Bip01 R Finger0
    Bip01 L Finger42
    Bip01 R Finger4
    Bip01 R Finger32
    Bip01 R Finger1
    Bip01 R Finger41
    Bip01 R Finger12
    Bip01 L Finger4
    Bip01 R Finger02
    Bip01 L Finger21
    Bip01 L Finger11
    BackWeapon
    Bip01 L Finger1
    Bip01 L Shoulder Helper
    Bip01 R Shoulder Helper
    Bip01 R Forearm
    Torch
    Weapon
    Bip01 L Wrist Helper
    Bip01 L ForearmTwist
    Bip01 L Hand
    Bip01 Neck1
    Bip01 R Hand
    Bip01 R ForearmTwist
    Bip01 L Forearm
    Bip01 Head
    Bip01 R Wrist Helper
    Bip01 R UpperArmTwist
    Bip01 Neck
    Bip01 R Foot
    Bip01 R Clavicle
    Bip01 L Clavicle
    Bip01 R UpperArm
    Bip01 L UpperArm
    Bip01 L Foot
    Bip01 L UpperArmTwist
    Bip01 L Calf
    Bip01 Spine2
    Bip01 R Calf
    Bip01 Spine1
    Bip01 Pelvis
    Bip01 R Thigh
    SideWeapon
    Bip01 Spine
    Bip01 L Thigh

# [08/06/2020 - 09/06/2020] TES5 Animation cont.

## Lighting Shaders

It turns out that the dark skin textures were due to the lack of support for TES5 backlight in the shaders.

## Skinning and Bone offset

Looks like the issue with Spider Daedra has come back.  Will have to try to see if it is necessary to modiy Ogre or can get away with creating a few extra bones.

## Something from Reddit

    ¯\_(ツ)_/¯

# [27/07/2020] Back from the diversion

Spent 6 weeks or so trying to port OpenMW to Ogre 2.x.  At this point some things are working but a lot of things are not.  Here is a summary of Ogre related issues:

  * SubEntity visibility control is not yet supported.  See [this thread](https://forums.ogre3d.org/viewtopic.php?f=2&t=95873).  This will affect, among other things, the visibility control of dismembered body parts.
  * Without FFP support, many Morrowind meshes can't be used because they don't provide UV coordinates.  See [this thread](https://forums.ogre3d.org/viewtopic.php?p=548734#p548734).  Most likely the FFP emulation for these will need to be implemented (or some fancy shader work?).
  * Tagpoint on Skeletons do not work properly, even with [this workaround](https://forums.ogre3d.org/viewtopic.php?f=2&t=95896).  Haven't really investigated fully, but sometimes the Node rotations are not replicated by the listener.  The best solution is probably to move to the new Mesh/Node classes.
  * Pose/Vertex animations and Skeletal animations can't be mixed, at least without a patch.  See [this thread discussion](https://forums.ogre3d.org/viewtopic.php?f=2&t=95910).  Even with the patch any Pose/Vertex animation will force the skinning to be done in software.
  * Normal textures in DXT5 format are not supported.  There is [a workaround patch](https://forums.ogre3d.org/viewtopic.php?f=25&t=95904) but only for Ogre 2.2+.
  * MyGUI port of Ogre 2.2 results in extreme performance loss.  See [this thread](https://forums.ogre3d.org/viewtopic.php?f=25&t=95925) for more details.  There are other performance loss in general with Ogre 2.x.  Not sure what their causes are.
  * The default Pbs shaders do not produce correct lighting or colours (NOTE: it could be the way the materials are being setup).  See the [comparison screenshots of Vilverin](https://forums.ogre3d.org/viewtopic.php?p=548816#p548816).
  * The new HLMS system is a bit like Shiny but less flexible.  It creates a "mega" shader which gets generated differently during run-time based on provided config.  This makes it difficult to create small shaders to do custom jobs (at least I don't know how to do it without creating a separate implementation).
  * Ogre 1.12.x and Ogre 2.x are subtly different (e.g. Vector3, Node identifiers, etc).  It won't be easy to maintain codebases in both.

What can be worked on while deciding on which rendering framework to use?

  * Anything that requires material handling (which is almost everything?) can't be done without later rework.
  * Any shader related changes will result in rework later.  This means the skinning issues with the "bone offset" problem and Skyrim can't be worked on.
  * Maybe the terrain handling for Fallout/Skyrim (i.e. quad-tree-like LOD terrain) but any texture handling and shaders will need rework.
  * Code refactoring to allow the support of multiple games.  At the moment there are too many conditional checks everywhere.
  * Maybe multi-threading.  Probably should move away from boost threads.
  * FFMpeg rewrite. Probably the lowest priority.

# [27/07/2020 - 28/07/2020] Multi threading

Saw a bunch of videos and read a few slideware/documents on multi-threaded architectures.  Some interesting ones include:

  * [GCAP 2016: Parallel Game Engine Design - Brooke Hodgman - YouTube](https://www.youtube.com/watch?v=JpmK0zu4Mts)
  * [GDC Vault - Parallelizing the Naughty Dog Engine Using Fibers](https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine)
  * [SergeyMakeev/TaskScheduler: Cross-platform, fiber-based, multi-threaded task scheduler designed for video games.](https://github.com/SergeyMakeev/TaskScheduler)
  * [RichieSams/FiberTaskingLib: A library for enabling task-based multi-threading. It allows execution of task graphs with arbitrary dependencies.](https://github.com/RichieSams/FiberTaskingLib)
  * [GameTechDev/GTS-GamesTaskScheduler: A task scheduling framework designed for the needs of game developers.](https://github.com/GameTechDev/GTS-GamesTaskScheduler)
  * [CppCon 2014: Jeff Preshing "How Ubisoft Develops Games for Multicore - Before and After C++11" - YouTube](https://www.youtube.com/watch?v=X1T3IQ4N-3g)

One of the key takeout point is that in order to implement a multi-threaded game engine, the data flow architecture needs to be done first.  This will allow running multiple jobs/tasks without resorting to heavy use of locks / atomic premitives.

Some of the presentations above go into a rather complicated architectures.  But I would like to start simple without necessarily committing on some complex feature that I may not need for my target platforms.

So the first step is to instrument the problem.  One idea from Brooke Hodgman is to use Chrome's tracing profiler.  Some articles:

  * [Gamasutra - In-depth: Using Chrome://tracing to view your inline profiling data](https://www.gamasutra.com/view/news/176420/Indepth_Using_Chrometracing_to_view_your_inline_profiling_data.php)
  * [Chrome Tracing as Profiler Frontend · Aras' website](https://aras-p.info/blog/2017/01/23/Chrome-Tracing-as-Profiler-Frontend/)
  * [Trace Event Format - Google Docs](https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#!)
  * [High frequency timers](https://docs.microsoft.com/en-us/archive/msdn-magazine/2004/march/implementing-a-high-resolution-time-provider-for-windows)
  * [minitrace](https://github.com/hrydgard/minitrace)

# [29/07/2020] minitrace

Added minitrace to the `extern` directory.  Maybe should think about keeping it as a separate package.

Had to add `target_compile_options(${MINITRACE_LIBRARY} PUBLIC /TP)` so that it compiles as a `C++`.

Applied a couple of PRs that are still open (one that uses `C++11` and another that adds markdown syntax to the README file).  Should also consider applying the "concurrent flushing" PR.

__TODO:__ Should try the commented out block of code using `InterlockedExchangeAdd()`.

# [30/07/2020] minitrace cont.

## Activation

Too much data is captured to make it useful.  Need to add a key binding to capture a single frame (and maybe another key binding to toggle capture?).

`MWInput::InputManager` is probably where I can add a keybinding for a single frame capture.

`MWBase::Environment::get().getInputManager()->hasCaptureRequest()` can be added to the main rendering loop to check for a capture and flush.

## Optimise Ogre instead?

Looking at the captured trace, the vast majority of the time is spent inside `renderOneFrame`.  Optimising OpenMW is not really going to improve the overall performance.  Note that with Ogre 1.10.11 only D3D9 is supported (single threaded) and it will be difficult to improve its performance.

## Try with Ogre 2.2

Well, the result is the same.  Except now the proprtion of time spent within Ogre is even greater than before.

Need to see what is going on within Ogre 2.2.  Given the difficulty of shutting down without exceptions, will probably go with `Remotery` as per [this post](https://forums.ogre3d.org/viewtopic.php?p=548801#p548801).

# [31/07/2020] Ogre performance

## Baseline, `Sample_PbsMaterial`, @1920x1080

Intel UHD Graphics 630

Direct3D11 : 110 FPS
OpenGL 3+  :  70 FPS

Nvidia Quadro P1000

Direct3D11 : 240 FPS
OpenGL 3+  : 235 FPS

## OpenMW-Ogre-1.10, @1600x900, Vilverin

Intel UHD Graphics 630

Direct3D9 : 75 FPS

Nvidia Quadro P1000

Direct3D9 : 130 FPS

## OpenMW-Ogre-2.2, @1600x900, Vilverin
(with `setOptimizationStrategy(Ogre::ConstBufferPool::LowerGpuOverhead)`)

Intel UHD Graphics 630

Direct3D11 : 25 FPS

Nvidia Quadro P1000

Direct3D11 : 80 - 100 FPS

# [15/08/2020] V.A.T.S.

So far the attempted port to Ogre 2.2 has been disappointing.  There are a number of non-trivial issues that are going to be rather time consuming to resolve:

  * Poor performance, especially with iGpu.  No idea why at this point.
  * Specular materials do not display correctly.
  * others that I can't remember for now.

So I'm going to take a break from working on the Ogre 2.2 port for a while and do something else.

## Identifying V.A.T.S. body parts for displaying

Looks like each of the skinned meshes provide the `Body Part`s under `BSDismemberSkinInstance` `Partitions`.

Initially I thought the body parts were provided via `ACHR` or `ACRE` records' ragdoll data - but not all have these.  It seems that they could be for dead characters or creatures.

Neither `NPC_` or `RACE` records seem to have records that relate to body parts.  Maybe they are simply hard coded based on the skeleton model path.

## Cycling through actor targets

Can't remember if vanilla allows friendly actors to be targetted. (probably not)

Don't know if vanilla limits the actors based on distance from the player. (probably)

Most likely only the actors that passes LOS test for at least a body part. (actually can target even if hidden, but the chance to hit any body part will be zero)

## Displaying V.A.T.S. info

How these will be displayed is to be worked out - don't know if vanilla uses shaders or changes to the materials or uses overlays, etc.

## Bullet time

Not quite "bullet time" but animations, etc will need to be slowed down.

# [16/11/2020 - 17/11/2020] Back from Fallout 4

Not sure what to do after a break of 3 months.  I should probably make Oblivion work since it is probably the easiest at this point.

## Oblivion ToDo

  * Quests (and a multi-threaded scheduler?)
  * Character Controller
  * Incorporate navmesh (since it will be required for other games, anyway)
  * Physics improvements (take hints from OpenMW?)
  * Ragdoll
  * Terrain blending (needs shader work though)
  * Fix bone offset with shaders (using Shiny for now?)
  * Fix animation issue with moving child nodes
  * Ground cover (needs D3D11 for instancing?)
  * SpeedTree replacement (best to have D2D11 for instancing)
  * Intro screen and video
  * Read/write save files
  * UI (that supports popular UI MODs)
  * Support Mesh LOD
  * Support FadeNode (probably need to do this in shaders)
  * Particle effects (will probably result in rework later)

## Development Sequence

There are some interdependencies, e.g. Character Controller would be needed to demonstrate Navmesh based pathfinding with NPCs.  Physics improvements are also difficult to show unless the Character Controller and pathfinding are working properly.

A working Direct3D11 based rendering will be required before GPU based instancing for Grass models. i.e. no point working on that with Ogre 1.10

Similarly, any shader changes are best done once the rendering engine is decided.  Otherwise some, or significant amount of rework will be required.

## On mixing assets from different games

For example, an NPC from FO3 does not have `Willpower` attribute from TES4.  So it would be impossible to make an NPC that can be used in different game types without bloating the NPC object with lots of data.

Another example is TES3's Pauldron - an NPC from FO3 could not equip it, at least without creating some special attribute to a Pauldron so that it can be fitted to an equipment slot of an FO3 NPC.

# [19/11/2020] Script Support

Probably the best item to work on is scripts.  First check to see when a script is loaded.

## Call Stack

     openmw.exe!MWScript::InterpreterContext::startScript(const std::string & name, const std::string & targetId) Line 435	C++	Symbols loaded.
     openmw.exe!Interpreter::OpStartScript::execute(Interpreter::Runtime & runtime) Line 29	C++	Symbols loaded.
     openmw.exe!Interpreter::Interpreter::run(const unsigned int * code, int codeSize, Interpreter::Context & context) Line 248	C++	Symbols loaded.
     openmw.exe!MWScript::ScriptManager::run(const std::string & name, Interpreter::Context & interpreterContext) Line 123	C++	Symbols loaded.
     openmw.exe!MWScript::GlobalScripts::run() Line 81	C++	Symbols loaded.
     openmw.exe!OMW::Engine::updateAll() Line 136	C++	Symbols loaded.
     openmw.exe!OMW::Engine::go() Line 545	C++	Symbols loaded.
     openmw.exe!main(int argc, char * * argv) Line 396	C++	Symbols loaded.

# [03/12/2020] Compiling OpenCS and Launcher

NOTE: `components` have a dependency on `${NIBTOGRE_LIBRARIES}` due to OEngine using class `NiBtOgre::BtRigidBodyCI`.

NOTE: for some reason the working directory for the launcher doesn't change in MSVC?  Had to copy a couple of DLLs as a workaround.

Launcher's `CMakeLists.txt`: `${SDL2_LIBRARY_ONLY}` was changed to `${SDL2_LIBRARY}`

OpenCS's `CMakeLists.txt`: `${FGLIB_LIBRARIES}` was renamed to `${FGLIB_LIBRARY}`

# [05/12/2020] Back to Script

Many object classes can have scripts attached to them.  A simple `grep` for `mScriptId` results in:

    acti.hpp:        FormId mScriptId;
    alch.hpp:        FormId mScriptId;
    appa.hpp:        FormId mScriptId;
    armo.hpp:        FormId mScriptId;
    book.hpp:        FormId mScriptId;
    clot.hpp:        FormId mScriptId;
    cont.hpp:        FormId mScriptId; // TES4 only
    crea.hpp:        FormId mScriptId;
    door.hpp:        FormId mScriptId;

    flor.hpp:        FormId mScriptId;
    furn.hpp:        FormId mScriptId;
    ingr.hpp:        FormId mScriptId;
    keym.hpp:        FormId mScriptId;
    ligh.hpp:        FormId mScriptId;
    lvlc.hpp:        FormId mScriptId;
    misc.hpp:        FormId mScriptId;
    npc_.hpp:        FormId mScriptId;
    sgst.hpp:        FormId mScriptId;
    slgm.hpp:        FormId mScriptId;
    tact.hpp:        FormId mScriptId;
    term.hpp:        FormId mScriptId;
    weap.hpp:        FormId mScriptId;

# [06/12/2020] Co-existing with TES3 Scripts

The structure of TES4 scripts seem to be different.  There is a new keyword `scn` for the script name and the `begin` keyword is now followed by a condition (e.g. OnActivate) rather than the script name.

## ToDo

For now the `FormId` of the script is converted to a string but it should be possible to add new methods to accept `FormId` directly.

## New Functions

TES4 introduces many new functions.  The ones with the same name as TES3 have different Opcodes - not sure if that matters since the current script engine always compiles from the source.

# [07/12/2020] Script Compiler

Rather than modifying the existing script compiler to handle TES4 scripts, a different compiler should be used.  The scripts are just too different.

However, it appears that modifying the `MWScript::ScriptManager` would be simpler than creating a separate script manager.

# [09/12/2020] Script Compiler (cont.)

Decided to keep some classes from `components/compiler`.  e.g. `ErrorHandler`, `StreamErrorHandler`, `TokenLoc`, `Context`, `Literals` and `Locals` (there may be others)

# [10/12/2020] Script Compiler (cont.)

The scripting system is initialised in `OMW::Engine::prepareEngine()`:


    Compiler::registerExtensions (mExtensions);

    // Create script system
    mScriptContext = new MWScript::CompilerContext (MWScript::CompilerContext::Type_Full);
    mScriptContext->setExtensions (&mExtensions);

    mEnvironment.setScriptManager (new MWScript::ScriptManager (MWBase::Environment::get().getWorld()->getStore(),
        mVerboseScripts, *mScriptContext, mWarningsMode,
        mScriptBlacklistUse ? mScriptBlacklist : std::vector<std::string>()));


    ...


    // scripts
    if (mCompileAll)
    {
        std::pair<int, int> result = MWBase::Environment::get().getScriptManager()->compileAll();
        if (result.first)
            std::cout
                << "compiled " << result.second << " of " << result.first << " scripts ("
                << 100*static_cast<double> (result.second)/result.first
                << "%)"
                << std::endl;
    }
    if (mCompileAllDialogue)
    {
        std::pair<int, int> result = MWDialogue::ScriptTest::compileAll(&mExtensions, mWarningsMode);
        if (result.first)
            std::cout
                << "compiled " << result.second << " of " << result.first << " dialogue script/actor combinations a("
                << 100*static_cast<double> (result.second)/result.first
                << "%)"
                << std::endl;
    }


Notice how the functions and instructions are registered.  In order to support TES4, we may be able to register TES4 functions and instructions then use a different script context.

Maybe we need a public function in the engine to change the script system?  Or alternatively switch to a different context if we see `scn` or `scriptname` in the script?

# [11/12/2020] Script Compiler (cont.)

Need to decide whether to create a separate `Extensions` class for TES4 or modify the existing `Extensions` to accept a parameter.  With the former approach there may be some code duplication but probably end up with cleaner code in the end.

To implement a separate `Extensions` we will need to figure out when to create and register the TES4 functions/instructions - ideally at the first use of a TES4 script (i.e. detect by `scn` or `scriptname`).  It is used by the compiler `Context` so maybe a method in `ScriptManager` is the way to go.

We can also try to have a separate compiler `Context` for TES4.

Note that we don't want to allow the parser to accept both TES3 and TES4 at the same time (otherwise syntax checks can't be done).

# [13/12/2020 - 16/12/2020] Script Compiler (cont.)

Looks like TES3 scripts didn't support boolean operators.  I will have to figure out how to support them (parse, generate code, etc).

According to `components/interpreter/opcodes.hpp`, class Opcode1 is for 1 argument, Opcode2 is for 2 arguments.

    scn CGAmbushAGateScript

    begin onActivate
        ; make sure NPCs don't open the gate until after Renote is dead.
        if IsActionRef player == 1 || getstage charactergen > 26
            Activate
        endif
    end

                                                                      {{{
    script name: CGAmbushAGateScript
    file parser keyword: begin
    file parser: event onActivate
    control parser keyword: if
    function IsActionRef
    generate push string player index 0
    scan special: cmpEQ
    generate push int 1 index 0
    scan special: or
    generate compare e
    function getstage
    generate push string charactergen index 1
    generate push int 26 index 1
    control parser keyword: if end
    generate compare g
    generate boolean or <----- opportunity to optimise?
    append code
    run foreign script: 00014A21

    0x0000000e // number of words in code block
    0x00000002 // number of words in integer literal block
    0x00000000 // number of words in float literal block
    0x00000005 // number of words in string literal block
    0x00000000 <- start
                op  0: push arg0
                OpPushInt
                Runtime::mStack[0] has "0"
    0xca000302
                OpIsActionRef<Implicit>
                use the value of Runtime::mStack[0] as index to retrieve string literal "player"
                then reduce Runtime::mStack by 1 (i.e. pop)
                then push the result s.t. Runtime::mStack[0] is 1 (i.e. true)
    0x00000000
                op  0: push arg0
                OpPushInt
                Runtime::mStack[1] has "0"
    0xc8000004
                op   4: replace stack[0] with integer literal index stack[0]
                OpFetchIntLiteral
                Runtime::mStack[1] has the integer literal "1"
    0xc800001a
                op  26: compare (intger) stack[1] with stack[0]; pop twice; push 1 if equal, 0 else
                OpCompare
                (actually pop once and replace the Runtime::mStack[0] with the result)
    0x00000001
                op  0: push arg0
                OpPushInt
                Runtime::mStack[1] has "1" which was arg0
    0xca000304
                OpGetStage<Implicit>
                use the value of Runtime::mStack[1] as index to retrieve string literal "charactergen"
                then reduce Runtime::mStack by 1 (i.e. pop)
                then push the result s.t. Runtime::mStack[1] is 0 (just a dummy value)
    0x00000001
                op  0: push arg0
                OpPushInt
                Runtime::mStack[2] has "1"
    0xc8000004
                op   4: replace stack[0] with integer literal index stack[0]
                OpFetchIntLiteral
                Runtime::mStack[2] has the integer literal "0x1a" (i.e. 26)
    0xc800001e
                op  30: compare (intger) stack[1] with stack[0]; pop twice; push 1 if greater than, 0 else
                OpCompare
                Runtime::mStack[1] is now 0 (remember Runtime::mStack[0] has the previous OpCompare result)
    0xc8000049
                op 73: logial operation (intger) stack[1] with stack[0]; pop twice; push 1 if either, 0 if neither
                OpLogical
                Runtime::mStack[0] is now 1
    0xc8000019
                op  25: skip next instruction if stack[0]!=0; pop
                OpSkipNonZero
                Runtime::mStack is now empty
                Runtime::mPC is changed from 0xc to 0xd
    0x01000002 // 00 000001 0000 0000 0000 0000 0000 0010
                op  1: move pc ahead by arg0
                (in this case there's no further code to execute)
    0xc2002f00
                OpActivate
    0x00000001 <- start of integer literal block
    0x0000001a
    0x79616c70 <- start of string literal block
    0x63007265
    0x61726168
    0x72657463
    0x006e6567
                                                                      }}}

## Partially working

Things to fix include:

  * local variables (16/12/20: workaround hack in place; 19/12/20: solution found)
  * Script event handling (e.g. `OnActivateRef`)
  * `OnActivateRef` function not implemented
  * `WorldImp::searchPtr()` needs to support TES4 objects
  * `OpGetStage` doesn't handle quests
  * `OpActivate` has 2 optional arguments but it is based on `Opcode1` (with 1 argument)
  * `OpActivate` arguments are ignored
  * `InterpreterContext::getActor()` and `setActor()` are clumsy

## CGDungeon01ExitDoorScript

    scn CGDungeon01ExitDoorScript                                     {{{

    short hintCount

    begin OnActivate
        if IsActionRef player == 1
            Activate
            if GetLocked == 1
                if hintcount == 0
                    MessageBox "This door is locked. Maybe you can find the key somewhere nearby."
                else
                    MessageBox "This door is locked. Try searching the dead goblin shaman for the key."
                endif
                set hintcount to 1
            endif
        endif
    end                                                               }}}

                                                                      {{{
    script name: CGDungeon01ExitDoorScript
    local var: short
    file parser keyword: begin
    file parser: event OnActivate
    control parser keyword: if
    function IsActionRef
    generate push string player index 0
    scan special: cmpEQ
    generate push int 1 index 0
    control parser keyword: if end
    control parser keyword: if
    function GetLocked
    scan special: cmpEQ
    generate push int 1 index 1
    control parser keyword: if end
    control parser keyword: if
    scan special: cmpEQ
    generate push int 0 index 2
    control parser keyword: if end
    generate compare e
    generate push int 1 index 3
    generate compare e
    generate compare e
    run foreign script: 0004E86E

    0x0000001e // number of words in code block
    0x00000004 // number of words in integer literal block
    0x00000000 // number of words in float literal block
    0x00000024 // number of words in string literal block
    0x00000000 <- start
    0xca000302
    0x00000000
    0xc8000004
    0xc800001a compare eq
    0xc8000019 skip non zero
    0x01000018 move PC ahead by 0x18
    0xc2002f00 activate
    0xca000306 getlocked
    0x00000001
    0xc8000004
    0xc800001a eq
    0xc8000019 skip non zero
    0x01000011 move PC ahead by 0x11
    0x00000000
    0xc8000015
                OpFetchLocalShort
                op  21: replace stack[0] with local short stack[0]
    0x00000002
    0xc8000004
    0xc800001a
    0xc8000019
    0x01000004
    0x00000001
    0xc0000000 messagebox
    0x01000003 jump forward by arg0 which is 3 --+
    0x00000002                                   |
    0xc0000000                                   |
    0x00000000 <---------------------------------+
    0x00000003
    0xc8000004 fetch int literal (i.e. 1)
    0xc8000000 store local short (i.e. hintcount)
    0x00000001 <- start of integer literal block
    0x00000001
    0x00000000
    0x00000001
    0x79616c70 <- start of string literal block
    0x54007265
    0x20736968
    0x726f6f64
    0x20736920
    0x6b636f6c
    0x202e6465
    0x6279614d
    0x6f792065
    0x61632075
    0x6966206e
    0x7420646e
    0x6b206568
    0x73207965
    0x77656d6f
    0x65726568
    0x61656e20
    0x2e796272
    0x69685400
    0x6f642073
    0x6920726f
    0x6f6c2073
    0x64656b63
    0x7254202e
    0x65732079
    0x68637261
    0x20676e69
    0x20656874
    0x64616564
    0x626f6720
    0x206e696c
    0x6d616873
    0x66206e61
    0x7420726f
    0x6b206568
    0x002e7965
                                                                      }}}

Now working - things to fix include:

  * local variables in objects' run-time data
  * message box size (hacked a workaround for now)
  * local scripts from TES3 should be removed once in TES4

# [17/12/2020] Script Compiler (cont.)

## Namespace clash between TES3 and TES4

The intention is for the Interpreter to support both TES3 and TES4 - how to deal with functions of the same name (but have different behaviour)?

It might be ok (i.e. no clash) since the TES4 compiler will generate a different opcode to that of TES3 and the interpreter works off the opcodes?

## Dark04Sewers02

    scn SewerWheel01SCRIPT                                            {{{

    ; activates parent after a 2 sec delay

    short busy
    ref mySelf
    ref myParent
    short open
    short activated
    float timer

    begin onActivate

        if busy == 0
            if open == 0

                playgroup forward 1
                set open to 1
                set activated to 1
                set timer to 2
                set busy to 1

            else

                playgroup backward 1
                set open to 0
                set activated to 1
                set timer to 2
                set busy to 1

            endif
        endif

    end

    begin gameMode

        if activated == 1 && timer <= 0

            set mySelf to getSelf
            set myParent to getParentRef
            myParent.activate mySelf 1
            set activated to 0

        endif

        if timer > 0
            set timer to timer - getSecondsPassed
        endif

        if isAnimPlaying == 0 && busy == 1
            set busy to 0
        endif

    end                                                               }}}

NOTE: later versions of code generator will most likely produce different opcodes, e.g. ref related
                                                                      {{{
    decl: s busy
    decl: r myself
    decl: r myparent
    decl: s open
    decl: s activated
    decl: f timer
    script name: SewerWheel01SCRIPT
    decl: s busy
    decl: r myself
    decl: r myparent
    decl: s open
    decl: s activated
    decl: f timer
    file parser keyword: begin
    file parser: event onActivate
    control parser keyword: if
    scan special: cmpEQ
    generate push int 0 index 0
    control parser keyword: if end
    control parser keyword: if
    scan special: cmpEQ
    generate push int 0 index 1
    control parser keyword: if end
    generate push string forward index 0
    generate push int 1 index 2 <---- argument for playgroup
    generate push int 1 index 3 <---- open
    generate push int 1 index 4 <---- activated
    generate push int 2 index 5 <---- timer
    generate push int 1 index 6 <---- busy
    generate compare e
    generate push string backward index 1
    generate push int 1 index 7
    generate push int 0 index 8
    generate push int 1 index 9
    generate push int 2 index 10
    generate push int 1 index 11
    generate compare e
    run foreign script: 00083192

    0x00000039
    0x0000000c
    0x00000000
    0x00000005
    0x00000000 <- start
    0xc8000015 fetch local short (busy)
    0x00000000 index for fetch int literal
    0xc8000004 fetch int literal (i.e. 0)
    0xc800001a eq
    0xc8000019 skip non zero
    0x01000033 move PC ahead by 0x33 (i.e. the end)
    0x00000001
    0xc8000015 fetch local short (open)
    0x00000001
    0xc8000004 fetch int literal (i.e. 0)
    0xc800001a eq
    0xc8000019 skip non zero
    0x01000017 move PC ahead by 0x17
    0x00000002
    0xc8000004 fetch int literal <-- why?
    0x00000000
    0xca000307 playgroup
    0x00000001 push int arg0: Runtime::mStack[0] has "1" <- index for store local short (i.e. "open")
    0x00000003 push int arg0: Runtime::mStack[1] has "3" (3 must be index for fetch int literal?)
    0xc8000004 fetch int literal: Runtime::mStack[1] has "1" <- data for store local short
    0xc8000000 store local short: "open" is now "1"
    0x00000002 index for store local short (i.e. "activated")
    0x00000004 index for the data for fetch int literal?
    0xc8000004 fetch int literal
    0xc8000000 store local short: "activated" is now "1"
    0x00000000
    0x00000005
    0xc8000004 fetch int to literal
    0xc8000003 int to float
    0xc8000002 store local float: probably setting "timer" to "2"
    0x00000000
    0x00000006
    0xc8000004
    0xc8000000 store local short: probably setting "busy" to "1"
    0x01000016 move PC ahead by 0x16
    0x00000007
    0xc8000004
    0x00000001
    0xca000307 playgroup
    0x00000001
    0x00000008
    0xc8000004
    0xc8000000 store local short
    0x00000002
    0x00000009
    0xc8000004
    0xc8000000 store local short
    0x00000000
    0x0000000a
    0xc8000004
    0xc8000003 int to float
    0xc8000002 store local float
    0x00000000
    0x0000000b
    0xc8000004
    0xc8000000 store local short
    0x00000000 <- start of integer literal block
    0x00000000
    0x00000001
    0x00000001
    0x00000001
    0x00000002
    0x00000001
    0x00000001
    0x00000000
    0x00000001
    0x00000002
    0x00000001
    0x77726f66 <- start of string literal block
    0x00647261
    0x6b636162
    0x64726177
    0x00000000
                                                                      }}}

The second block of code starting with `begin gameMode` is not present.  Need to figure out how to jump to the correct code block based on the event.

## Events

Maybe keep a map in interpreter context with the events for the script with the corresponding PC?

We may also need to add a new instruction at the "end" keyword so that PC becomes "-1" and doesn't keep going.

# [18/12/2020] Script Compiler (cont.)

## LineParser new syntax

The new syntax, i.e.

    myParent.activate mySelf 1

seems to be basically the old one:

    "object_id"->function

except that a reference is used.

The tricky part is to distinguish it from the syntax, i.e.

    "object_id".variable

It may be that with the TES4 scripts the "fix", i.e. "->", has been replaced with ".".

It may not be necessary to distinguish the syntax because in TES4 the old syntax doesn't seem to be used.  Note that

    object_ref.variable

is still valid.  So the parser needs to be able to distinguish between a function and a variable.

## LineParser states

For our scenario `LineParser` would have been called from the `ScriptParser::parseName` or `ControlParser::parseName` if called from inside an `if` block.

    "BeginState"
    Scanner::scanToken --> scanName --> parseKeyword (e.g. "set", "short")
                                    --> extension parseKeyword (e.g. "activate")
                                    --> parseName

    Scanner::parseName --> "PotentialExplicitState" (if name is ref local variable)
                       --> parseExpression (if mAllowExpression - TODO: when is it used?)

    "PotentialExplicitState"
    Scanner::scanToken --> scanSpecial --> parseSpecial (if "." then -> "ExplicitState")

    "ExplicitState"
    Scanner::scanToken --> scanName -> LineParser::parseKeyword (extensions, i.e. "activate")

    LineParser::parseKeyword -> ExprParser::parseArguments -> StringParser::scanName (i.e. "mySelf") -->
                             --> StringParser::parseName

NOTE: later versions of code generator will most likely produce different opcodes, e.g. ref related
                                                                      {{{
    decl: s busy
    decl: r myself
    decl: r myparent
    decl: s open
    decl: s activated
    decl: f timer
    decl: s busy
    decl: r myself
    decl: r myparent
    decl: s open
    decl: s activated
    decl: f timer

    file parser: event onActivate
    control parser keyword: if
    scan special: cmpEQ
    generate push int 0 index 0
    control parser keyword: if end
    control parser keyword: if
    scan special: cmpEQ
    generate push int 0 index 1
    control parser keyword: if end
    generate push string forward index 0
    generate push int 1 index 2
    generate push int 1 index 3
    generate push int 1 index 4
    generate push int 2 index 5
    generate push int 1 index 6
    generate compare e
    generate push string backward index 1
    generate push int 1 index 7
    generate push int 0 index 8
    generate push int 1 index 9
    generate push int 2 index 10
    generate push int 1 index 11
    generate compare e

    file parser: event gameMode
    control parser keyword: if
    scan special: cmpEQ
    generate push int 1 index 0
    generate compare e
    generate push int 0 index 1
    control parser keyword: if end
    function getSelf
    function getParentRef
    generate push string myself index 0
    generate push int 1 index 2
    generate push int 0 index 4
    generate compare L
    generate boolean and
    control parser keyword: if
    generate push int 0 index 5
    control parser keyword: if end
    generate compare g
    control parser keyword: if
    function isAnimPlaying
    scan special: cmpEQ
    generate push int 0 index 6
    generate compare e
    scan special: cmpEQ
    generate push int 1 index 7
    control parser keyword: if end
    generate push int 0 index 8
    generate compare e
    generate boolean and
    run foreign script: 00083192

    0x0000003a
    0x00000009
    0x00000000
    0x00000004
    0x00000002 <- start
    0xc8000015 fetch local short
    0x00000000
    0xc8000004 fetch int literal
    0xc800001a cmp eq (i.e. activated == 1)
    0x00000000
    0xc8000017 fetch local float
    0x00000001
    0xc8000004 fetch int literal
    0xc8000003 int to float
    0xc8000023 cmp le float (i.e. timer <= 0)
    0xc8000048 logical and
    0xc8000019 skip non zero
    0x0100000f ------------------------+
    0x00000000                         |
    0xca000308 getself                 |
    0x00000001                         |
    0xca00030a getparentref            |
    0x00000002                         |
    0xc8000004 fetch int literal       |
    0x00000000                         |
    0x00000003                         |
    0xc8000004 fetch int literal       |
    0xc2003002 activate                |
    0x00000002                         |
    0x00000004                         |
    0xc8000004 fetch int literal       |
    0xc8000000 store local short (i.e. set activated to 0)
    0x00000000 <-----------------------+
    0xc8000017 fetch local float
    0x00000005
    0xc8000004 fetch int literal
    0xc8000003 int to float
    0xc8000024 cmp greater float
    0xc8000019 skip non zero
    0x01000007 ------------------------+
    0x00000000                         |
    0x00000000                         |
    0xc8000017 fetch local float       |
    0xc8000032 getsecondspassed        |
    0xc800000c subtract                |
    0xc8000002 store local float       |
    0xca00030b isanimplaying <---------+
    0x00000006
    0xc8000004 fetch int literal
    0xc800001a cmp eq
    0x00000000
    0xc8000015 fetch local short
    0x00000007
    0xc8000004 fetch int literal
    0xc800001a cmp eq
    0xc8000048 logical and
    0xc8000019 skip non zero
    0x01000005 ---> jump to end
    0x00000000
    0x00000008
    0xc8000004 fetch int literal
    0xc8000000 store local short
    0x00000001 <-
    0x00000000
    0x00000001
    0x00000001
    0x00000000
    0x00000000
    0x00000000
    0x00000001
    0x00000000
    0x6573796d <-
    0x6d00666c
    0x72617079
    0x00746e65
                                                                      }}}

## ToDo

In `Scanner::scanName` maybe use a map to search the keywords?  But then for such a small number of keywords it may not be beneficial.

In `ExprParser`, `CompilerContext::isId()` not used in TES4.

# [19/12/2020] Script Compiler (cont.)

## Local scripts

`OMW::Engine::updateAll()` calls `OMW::Engine::executeLocalScripts()`.  The scripts are retrieved from `World::mLocalScripts` which is of type `MWWorld::LocalScripts`.

For TES4 we only want those with `GameMode` block types.  These will execute every frame.  Others such as `OnActivate` will run when an actor activates doors/containers/etc.

The scripts are added via:

    World::copyObjectToCell()
    World::addContainerScripts()
    World::undeleteObject()
    World::moveObject()

and also from:

    Scene::loadCell()

which calls

    MWBase::Environment::get().getWorld()->getLocalScripts().addCell (cell);

Sooo... the logical place to make the changes appears to be `MWWorld::LocalScripts`.  New methods such as:

    addForeignCell()
    listForeignCellScripts()

By keeping the script id as a string, `mScripts` can be used as is and `clearCell()` and `remove()` won't need to change, either.

## Local variables in object references

Because TES3 scripts don't have separate events or blocktypes, all local scripts in a loaded cell always runs.  The local variables for the object references are created during the cell load - see `MWWorld::LocalScripts::addCell()` and `MWWorld::LocalScripts::add()`.  The latter calls `RefData::setLocals()` to create the local variables.

In TES4 only the scripts with `GameMode` block types behave like TES3 local scripts.  However, it is still possible to create the local variables during the load even if the script itself won't run until an event such as `OnActivate` occurs.  The only issue with this approach is that it is not immediately obvious from reading the code where the local variables are created.

## Container scripts

Not sure what these are.  The code seems to suggest that these are local scripts of items inside containers.  Not sure if these scrips are also meant to run each frame?  It would be good to see some examples.  Maybe they are meant to run once the objects are taken out of the container?

## Global scripts

Since the function `StartScript` no longer exists in TES4 it is unclear how the global scripts are started.

According to [this article](https://wiki.nexusmods.com/index.php/An_introduction_to_Oblivion_scripting), global scripts are the same as Quest scripts.  So, we now need to figure out when a quest is triggered and starts running.

## PlayGroup

`Dungeons\Sewers\sewerWheel01.NIF` has a `NiControllerSequence` block named "Forward".  Note that the script uses lowercase "forward".

According to [this wiki entry](https://cs.elderscrolls.com/index.php?title=PlayGroup) the integer flag "1" indicates:

    Immediate Start - The current animation will stop regardless of the frame it is on, and the new animation will start from its beginning.

The parent `FormId` can be found in the `XESP` subrecord.  The parent `REFR` has below script attached:

    scn SewerSloughGate01SCRIPT                                       {{{

    ; activated by linked child
    ; activates optionally linked parent after 1 sec delay

    short activated
    short open
    short next
    short busy
    float timer

    ref mySelf
    ref myParent

    begin onActivate

        if activated == 0
            set mySelf to getSelf
            set myParent to getParentRef
            set activated to 1
        endif

        if isActionRef player == 1

            if open == 0
                message " This gate is opened remotely."
            endif

        elseif isActionRef mySelf == 0 && busy == 0

            if open == 0
                playgroup forward 0
                set open to 1
            else
                playgroup backward 0
                set open to 0
            endif

            set next to 1
            set timer to 1
            set busy to 1

        endif

    end

    begin gameMode

        ; daisy-chain activation
        if next == 1 && timer <=0
            set next to 0
            myParent.activate mySelf 1
        endif

        if timer > 0
            set timer to timer - getSecondsPassed
        endif

        if isAnimPlaying == 0 && busy == 1
            set busy to 0
        endif

    end                                                               }}}

Note that this parent `REFR` itself can have a parent as well.  See the object instances `TDSSloughGate01` and `TDSSloughGate01b` in cell `ImperialSewerSystemTempleDistrict`.

Presumably it fails safely if the parent `REFR` is not found in the cell.

# [20/12/2020] Script Compiler (cont.)

## Reference handling

`MWScript::ExplicitRef::operator()` calls `World::getPtr()` with "myparent" string literal.  But what we want is to be able to search for the content of "myparent" which should be `FormId` `0x0006BC07`.

## Named references

Looks like object references can be specified by their `EditorId`s.  See below script as an example.

    scn CGCrumbleWall01SCRIPT

    short pushed
    float timer
    short triggered		; set to 1 when waiting to trigger rats

    begin onLoad

        ; prepare linked pathsgrid points
        disableLinkedPathPoints

    end

    begin onActivate

        if pushed == 0 && isActionRef player == 0
            playgroup Unequip 1
            CGCrumbleDust01REF.playgroup forward 1
            set pushed to 1
            set timer to 2
            setstage MQ01 24
            setdestroyed 1
            enableLinkedPathPoints
        endif

    end

    begin gameMode
        if timer > 0
            set timer to timer - getSecondsPassed
        endif

        if pushed == 1 && timer <= 0
            CGCrumbleDust02REF.playgroup forward 1
            set pushed to 2
            set timer to 4
        elseif pushed == 2 && timer <= 0
            CGCrumbleDust03REF.playgroup forward 1
            set pushed to 3
        endif

    end

# [21/12/2020] Script Compiler (cont.)

## Adding new funcitons and instructions

For TES4, Segment 3 opcodes begin from 0x2002d and segment 5 opcodes begin from 0x2000302.

Functions/instructions that have optional arguments must be in segment 3.

  Action                          |  File
  --------------------------------|---------------------------------------------
  define opcodes                  | components/tes4compiler/opcodes.hpp
  register extensions to compiler | components/tes4compiler/extensions0.cpp
  install opcodes to interpreter  | apps/openmw/mwscript/tes4extensions.cpp, etc
  update documentation on opcodes | apps/openmw/mwscript/docs/vmformat.txt

## Adding new interpreter operations

E.g. OpFetchLocalRef

  Action                          |  File
  --------------------------------|---------------------------------------------
  add new operations              | components/interpreter/localopcodes.hpp
  install opcodes to interpreter  | components/interpreter/installopcodes.cpp
  update documentation on opcodes | components/interpreter/docs/vmformat.txt

Note that the interpreter works for both TES3 and TES4, at least for now.

## BlockType event

    scn CGDungeon01ExitDoorScript

    scan with ScriptParser
        Scanner::scanName "if"
        ScriptParser::parseKeyword
            ControlParser::parseKeyword
            :   scan with ExprParser  <----------------------------- start here
            :       Scanner::scanName "IsActionRef"  <-------------- blockType
            :           ExprParser::parseKeyword
            :               parseArguments  <----------------------- arguments (special if none)
            :               extensions->generateFunctionCode  <----- maybe a template
            :               push back return type
            :       Scanner::scanSpecial "=="
            :           ExprParser::parseSpecial
            :               pushBinaryOperator  <----------------------+
            :       Scanner::scanInt "1"                               |
            :           ExprParser::parseInt                           |
            :               pushIntegerLiteral  <-------------------------+
            :       Scanner::scanSpecial "\n"                          |  |
            :           ExprParser::parseSpecial                       |  |
            :               Scanner::putbackSpecial                    |  |
            v   mState is now IfEndState  -------------------------- hard code
            scan with ControlParser
            :   ControlParser::parseSpecial (the "\n" put back)
            :       mState is now IfBodyState  <-------------------- normal scan with ScriptParser
            :   Scanner::scanName "Activate"
            :       ControlParser::parseKeyword
            :           ControlParser::parseIfBody
            :               LineParser::parseKeyword
            :                   ExprParser::parseArguments
            :                       scan with StringParser
            :                   Extensions::generateInstructionCode
            :               scan with LineParser
            :   ...
            :
            :   Scanner::scanName "endif"  <------------------------ normal end with ScriptParser
            :       ControlParser::parseKeyword
            :           ControlParser::parseIfBody
            :               mIfCode.push_back
            :               ...
            :               generate jump code
            :               ...
            v               mState is now IfEndIfState
            ControlParser::appendCode
        Scanner::scanName "end"

# [22/12/2020] Script Compiler (cont.)

## Back to named references

Inside an "if" body, each line is parsed with a `LineParser` starting with `parseName()`.  Previously some code was addd to see if the name was a local ref variable e.g. "myparent".  Now we have to recognise if it might be an `EditorId` of an object `REFR` in a cell.

Similar conditions exist for `ExprParser::parseName()`

In addition to the `EditorId` of an object `REFR`, we may also see `EditorId` of quests. But the following token (e.g. "debug" is the name of a local variable to the script attached to the quest with `EditorId` "CharacterGen".

    scn CGPrisonSecretWallSwitchSCRIPT

    begin onActivate
        if getstage charactergen < 19 && isActionRef RenoteRef == 1
            if charactergen.debug == 1
                messagebox "DEBUG: CGPrisonSecretWallSwitchSCRIPT: Secret wall activated by Renote"
            endif
            playgroup forward 1
            CGPrisonSecretWallRef.playgroup forward 1
            set charactergen.secretDoor to 1
            set charactergen.convTimer to 5     ; time for wall to open fully
        endif

    end

## Explicit syntax variations

Looks like the parser needs to be able to distinguish the same notation to different outcomes:

      <object reference in local variable>.<function or instruction> <arguments>
      <object reference EditorId>.<function or instruction> <arguments>
      <quest EditorId>.<quest script local variable> <value>

The scanner can identify the first two by checking the registered extensions.  How to do the third one?

We may be forced to set a flag to indicate a member access when we encouter the special character "." in `ExprParser::parseSpecial()`.

Line 12 of below script hould be of the second form, i.e. `BaurusRef.SayTo player CharGenVoice`  Since it is in the "if" block body, a `LineParser` should first check for a name.


     scn CGEmperorScript                                              {{{

    short target
    ref combattarget
    ref bladeHelp
    short temp
    short warncount	; how many warnings has the Emperor given for player hitting him?
    short warnstage	; what stage was the last warning?

    begin OnActivate
        if IsActionRef player == 1 && GetDead == 1
            BaurusRef.SayTo player CharGenVoice
        else
            Activate
        endif
    end

    begin gamemode

    ; if dead, set stage:
    if getstage charactergen == 74
        if getdead == 1
            setstage charactergen 76
        endif
    endif

    ; talk when it is time
    if CharacterGen.speaker == 4 && CharacterGen.convTimer <= 0
        set target to CharacterGen.target

        if target == 0
            set CharacterGen.convTimer to Say CharGenMain 1
        elseif target == 1
            set CharacterGen.convTimer to SayTo BaurusRef, CharGenMain 1
        elseif target == 2
            set CharacterGen.convTimer to SayTo RenoteRef, CharGenMain 1
        elseif target == 3
            set CharacterGen.convTimer to SayTo GlenroyRef, CharGenMain 1
        elseif target == 4
            set CharacterGen.convTimer to SayTo UrielSeptimRef, CharGenMain 1
        elseif target == 5
            set CharacterGen.convTimer to SayTo player, CharGenMain 1
        elseif target == 6

        endif

        ; special case -- endless loop with Glenroy
        if charactergen.convCount == 35
            set charactergen.convTimer to 10
        endif

        ; special case -- endless loop with player
        if charactergen.convCount == 45
            set charactergen.convTimer to 12
        endif

    endif

    ; special: birthsign speech
    ;if ( getstage charactergen == 42 || getstage charactergen == 44 ) && CharacterGen.convTimer <= 0
    ;	set CharacterGen.convTimer to SayTo player, CGEmperorBirthsign 1
    ;endif

    end

    ; Assassin kills emperor in one blow
    begin OnHit CGAssassinFinal
        kill
    end

    ; NOTE: order is important here. OnHit player block needs to come first
    begin OnHit player
        if getdead == 0
            if warncount <= 4
                stopcombat
                player.scaonActor
            endif
            SayTo player CharGenEmperor 1
            set warnCount to warnCount + 1
            set warnstage to getstage charactergen

            ; make sure disposition of anybody never goes below 30
            ; Baurus
            set temp to BaurusRef.getdisposition player
            if temp < 30
                set temp to 30 - temp
                BaurusRef.moddisposition player temp
            endif

            ; Renote
            set temp to RenoteRef.getdisposition player
            if temp < 30
                set temp to 30 - temp
                RenoteRef.moddisposition player temp
            endif

            ; Emperor
            set temp to UrielSeptimRef.getdisposition player
            if temp < 30
                set temp to 30 - temp
                UrielSeptimRef.moddisposition player temp
            endif

            ; Glenroy
            set temp to GlenroyRef.getdisposition player
            if temp < 30
                set temp to 30 - temp
                GlenroyRef.moddisposition player temp
            endif

        endif
    end

    begin OnStartCombat
        if warnstage < getstage charactergen
            set warncount to 0
        endif

            ; Blades react if not the player
            set combattarget to GetCombatTarget
            if combattarget != player && combattarget > 0
                if getdistance BaurusRef < getdistance GlenroyRef || GlenroyRef.GetDead == 1
                    set bladeHelp to BaurusRef
                    if charactergen.debug == 1
                        message "DEBUG: Baurus calling for help for Emperor"
                    endif
                else
                    set bladeHelp to GlenroyRef
                    if charactergen.debug == 1
                        message "DEBUG: Glenroy calling for help for Emperor"
                    endif
                endif
                bladeHelp.SayTo player CharGenBlades
                bladeHelp.startcombat combattarget
            endif
    end

    begin OnHit
        if getstage charactergen < 74
            ; Emperor can't die until the end of charactergen
            set temp to GetBaseActorValue health
            forceav health, temp
        endif
    end

    begin OnPackageDone CGEmperorToMarkerB
        setstage CharacterGen 16
    end


    begin OnPackageDone CGEmperorToMarkerH
        setstage CharacterGen 62
    end

    begin OnPackageDone CGEmperorToMarkerJ
        setstage CharacterGen 68
    end                                                               }}}

## Identifiers

Currently there's some difficulty distinguishing an object reference being used for explicit function call and it being used in an expression (e.g. comparison).

    ScriptParser (name == "if") -> ScriptParser::parseKeyword
        ControlParser::parseKeyword (keyword = "if) -> scan with ExprParser
            Scanner::scanName (extension, local variable or EditorId, unlikely to be a keyword inside "if")
                ExprParser::parseName or ExprParser::parseKeyword

Here is where we have some trouble.  If we find a local ref variable or an `EditorId`, we need to check if that will result in an explicit function call or just a reference value.

One possible solution is to defer the decision till the next token.  If we encounter a "." then we have an explicit function call.  If we find a white space or ")", "||" or "&&" then we have a reference value.

            if combattarget != player && combattarget > 0
                  ^               ^           ^
                  |               |           |
            should contain    FormId of     check that there
            the FormId from   the player    is a combat target
            GetCombatTarget   (EditorId)
            (local ref var)

# [23/12/2020 - 24/12/2020] Script Compiler (cont.)

## References again

In TES3, the `Scanner` identifies `->` as a "ref" special token and `.` as a "member" special token.  However in TES4 `.` can represent either.  Hence we will need a different way to distinguish between the two.

For TES3 `LineParser` and `ExprParser` use `S_ref` and `S_member`.

Member variable access is required for object scripts or quest scripts.  References are used for calling script functions (explicit).  In TES3 the `LineParser` uses the following logic to distinguish:

    Start: if a name is an object `Id` then go to "PotentialExplicitState" and store the name in `mExplicit`
    PotentialExplicitState: if the `Scanner` detects `S_ref` then go to "ExplicitState" or
                            if the `Scanner` detects `S_member` then go to  "MemberState"

### New logic for TES4

Since there are no special token to distinguish the two scenarios we need to use other ways.

Note that member accesses are for object and quest scripts.  So one possible solution is to detect the type of reference.  i.e. member access for scripts else explicit functions/instructions

Alternatively, if the name following the special token is not a function or instruction we can deduce that they are script member variables.

## Persistent references for global scripts

For compiling global scripts it is not possible to check if an identifier is a reference by searching the active cells.  In fact the references wouldn't have been loaded, i.e. we will be forced to load _all_ cells to be able to check.

However, `GlarthirRef` for example, is a "persistent" reference.  That means it should be possible to load all the references required by the global scripts.  The difficulty is in where and how to manage the data.  Currently the references are stored in `CellStore` and it would be impractical to keep all of those with persistent references "active".

It may be possible to keep them in `ESMStore` then have its run-time data updated when the reference is loaded to a cell.  i.e. store the references in `CellRefList` but have the location data updated as the references are moved into a scene (by becoming a `Ptr`?).  This approach will mean that we need to take extra care that the reference data in two places do not get out of sync (the one in `ESMStore` and the other in `CellStore`).  See the notes on LOD data back in 7/04/2020, especially regarding the `Ptr` and `CellRef` data structures.

Maybe keep `CellRefList<ESM4::Npc>` in `ESMStore` and just keep the `FormId` of NPCs in `CellStore`? But doing so will mean that we will need to keep a number of different types of `CellRefList` for each base object types, e.g. Statics, Doors, etc.  It may be better to store the `ACHR`, `ACRE` and `REFR` records themselves.

## More reference base object types

Creatures, containers, furniture

# [25/12/2020 - 26/12/2020] Script Compiler (cont.)

Now able to parse all the global scripts after addressing below issues.

## Parsing issues

Looks like `ExprParser` can't handle the `(` special in complex situations e.g. SE06SCRIPT:

    if SEKanehRef.getincell XPCylarne01 == 1 && ( SEKanehRef.getdistance player < 750 || getstagedone SE06 70 == 1 )

Potential solution - change the priority of the `||` and `&&` operations to be higher than `(`.  Not entirely sure if I really understand this.

## AI package reference

SE05QuestScript expects reference from AIPackage:

    ;Make sure Script Package stays on Herdir's target if he takes a while to get there for any reason

        if ( SEHerdirRef.CastSpell >= 1 )
            if ( HerdirTarget.GetCurrentAIPackage != SE05TortureHoldPosition )
                if ( HerdirTarget.GetSitting == 0 )
                    HerdirTarget.AddScriptPackage SE05TortureHoldPosition
                endif
            endif
        endif

Sequence of current code:

        S_open mOperators.push_back
        ExprParser::parseName HerdirTarget is a local ref, mPotentialExplicit
        ExprParser::parseSpecial mExplicit = HerdirTarget, mRefOp = true
        ExprParser::parseKeyword GetCurrentAIPackage is a function
        ExprParser::parseSpecial compare not equal pushBinaryOperator
        ExprParser::parseName SE05TortureHoldPosition <- is an EditorId of an AIPackage i.e. is a ref
           getContext().getReference(name2) should have picked it up

## Strange quirks

Ignore the "endif" with extra "backtick" character in MG09Script.

SE06SCRIPT uses "int" rather than "long" to declare the local variables.

## Message display seconds parameter

See TG11HeistScript and MQ14Script for an examples.

Need to add the handler in `LineParser::parseInt()`.

## Stray itentifier

SE11QuestScript uses another script's local variable (SERakheranScript).  SERakheranScript has:

    ;Variables
        short   IsHostile                       ;Variable for apostle being hostile to player
        short   FindPlayer                  ;Set to 1 when player enters the cell XPHowlingHalls02
        short   HasSpokenTo Player      ;Set to 1 after Rakheran greets the player
        short   PlayerHasAcceptedOffer  ;Set to 1 when the player accepts Rakheran's offer
        ...

Need to add a special check to `DeclarationParser::parseName()`

## Accessing local variables of references (in if condition)

SE05QuestScript

    if ( HerdirTarget.GetCurrentAIPackage != SE05TortureHoldPosition )

Need to update `CompilerContext::getMemberType()` to handle various object types.

# [27/12/2020] Interpreter

## `RefId` woes

The `ContainerStore::count()` uses `getCellRef().getRefId()` to match against the supplied string.  However TES4 scripts supply the `EditorId` of the base object. e.g. `GetItemCount` used in `CGChest02SCRIPT` (ImperialDungeon05)

The whole thing needs a bit of rethink, but for now just add a TES4 specific method.

# [28/12/2020 - 30/12/2020] Activator

## Animation design problem

Can't remember how things were done - seems so long ago.

Currently door animations are implemented Ogre's Node Animation.  This can lead to trobles - see notes around 20/04/2020.

# [01/01/2021] Activator animation

## Tripwire script infinite loop issue

CTrigTripwire01 in Vilverin:

    scn CTrigTripwire01SCRIPT

    short triggered
    ref target
    ref mySelf

    begin onActivate

        if triggered == 0
            set target to getParentRef
            set mySelf to getSelf
            target.activate mySelf 1 <--- calls activate script before setting triggered to 1
            playgroup forward 0
            set triggered to 1
            setDestroyed 1
        endif

    end

    begin onTrigger

        if triggered == 0
            set target to getParentRef
            set mySelf to getSelf
            target.activate mySelf 1
            playgroup forward 0
            set triggered to 1
            setDestroyed 1
        endif

    end

    begin onReset

        reset3DState
        set triggered to 0
        setDestroyed 0

    end

# [02/01/2021 - 04/01/2021] Door animation

Now that activator animations are working, time to try using the same for door animations.

## Issues

  * __FIXME:__ BenirusDoor01.NIF either the animation plays too fast or the sound starts late - worked around by using "0.5f" speed multiplier when calling `play()` from `MWRender::Animation::activateAnimatedDoor()`
  * Physics shapes for activators not updated (fixed 04/01/2021)
  * Physics shapes for descendants of animated bones not done (fixed 04/01/2021)

## Testing doors

First disable lock level check in `ForeignDoor::activate()`.  Also force activation in `World::activate()` in order to test `BenirusDoor01`.

  * COC "OblivionMQKvatchCitadelHall01" or COW "MS13CheydinhalOblivionWorld" 1 -1
    - Oblivion\Architecture\Citadel\Interior\CitadelHall\CitadelHallDoor01Anim.NIF (000182E8)
  * COC "KvatchChapelHall" - Architecture\Cathedral\Crypt\CathedralCryptDoor01.NIF
  * COC "Vilverin" - Dungeons\AyleidRuins\Interior\ARNHallGateDoor01.NIF
  * COC "ImperialDungeon03" - Dungeons\Chargen\IDGate01.NIF, Dungeons\Chargen\IDPortcullis01.NIF
  * COC "ICMarketDistrictRindirsStaffs" - Clutter\UpperClass\UpperClassDisplayCasePurple01.NIF
  * COW "AnvilWorld" -46 -7 (then go to Benirus Manor) - Architecture\StoneWall\StoneWallGateDoor01.NIF
  * COC "AnvilBenirusManorBasement" - Architecture\Anvil\BenirusDoor01.NIF

Some activators:

  * COC "Dark04Sewers02"
  * COC "ImperialSewerSystemMarketDistrict" (or enter via ICMarketDistrictTheBestDefenseBasement)

## More known Issues

  * One of the display cases in Ridir's Staffs has slightly twisted collision shapes after activation.
  * Don't forget to add `getScript()` to the rest of the classes. (see  05/12/2020)

# [05/01/2021 - 07/01/2021] Ragdoll

See some notes from around 08/03/2020.

Some experiments to do:

Try adding a SceneNode if a node with a rigidbody has a constraint.  This would be done when the `Ogre::Entity` is created.  For TES4 we can use the BSX flags to see if a model has havok enabled.  We'll still need a map, probably populated when `bhkRigidBody`/`bhkRigidBodyT` are created.

It is not really safe to assume that the required NIF blocks have been read by the time we encounter a `bhkCollisionObject` or a constraint.  This probably means we will be forced to do a couple of lookups.

First, `mBhkRigidBodyMap` can provide the block number of the bhkEntity based on the NiNode block number.

Next, we can check if the bhkEntity has any constraints.  If so, we will need to provide an `Ogre::SceneNode` to the entity created from the NiNode.

## Combine ragdoll and animation

How to do this? Do we need a separate animation code for entities tied to a scene node?  Or do we attach the entities to scene nodes at the time a ragdoll is enabled?  Maybe the animation "Unequip" has this magic to disable ragdoll?

Related question is - how do we know when a ragdoll is enabled?  Those with an attached script may be easier to figure that out.  Maybe try using "Enable Parent" flag to decide?

## Ragdoll activation

If we decide that the `Ogre::SceneNode` for an `Ogre::Entity` with a rigidbody is assigned at the time of the ragdoll activation, then it would be somewhere in `MWRender::ObjectAnimation`.  Looking at Git blame, looks like simiar code has been there since February/March 2020.

## Issues

  * Doors with havok and animations ignore havok (see sewerTunnelDoor01.NIF)
  * The raycasting shapes do not move with the non-raycasting shapes. (worked around 07/01/21)
  * UpperScales01.NIF - the strays are not being rendered correctly (the collision shapes are fine)
    - probably because the model has animation enabled - see `buildSubMesh()` (worked around 08/01/21)
  * static objects with havok ignores havok (RicketyFence01.NIF) - if they clip through to the ground then they'll fall down
  * either the rendering and/or collision shape placement for root havok models are wrong (fixed 08/01/21)
  * Ragdoll with skinned meshes are not yet implemented (fixed 08/01/21)
  * How to deal with animation combined with havok? `CTrapSwingMaceLong01.NIF`

# [08/01/2021 - 09/01/2021] Ragdoll with skinned mesh

  * `Dungeons\Misc\RicketyFence01.NIF` has wrong collision shape position
  * `Dungeons\Caves\RopeRock01.NIF` has animation as well as havok; also seems to have wrong collision shape positions
  * bhkStiffSpringConstraint not implemented
  * Occasional glitches and crashes in `stepSimulation()`

## Testing sites

  * COC "WellspringCave"
  * COC "ImperialDungeon05"
  * COC "DarkFissure"

# [10/01/2021 - 11/01/2021] Collision shapes and Ragdoll for Actors

They kinda work, but there are a few issues:

  * The constraints are too loose, NPCs usually fold over fully at the waist
  * They do not fall down from gravity alone - seem to need an external impulse
  * their momentum at the time of death is not carried over to the ragdoll
  * Enabling local inertia messes up `RootHavok02.NIF`

# [12/01/2021] Debugging CRopeRock01

    FormId 0x00051AD3

    scn CRopeRock01SCRIPT

    ; activates parent

    short init
    short busy
    ref target
    ref mySelf

    begin onActivate

        if init == 0
            set target to getParentRef
            set mySelf to getSelf
            set init to 1
        endif

        if isActionRef mySelf == 0 && busy == 0
            set busy to 1
            target.activate mySelf 1
            playgroup forward 0
        endif

    end

    begin gameMode

        if isAnimPlaying == 0 && busy == 1
            set busy to 0
        endif

    end

    0x0000002c
    0x00000008
    0x00000000
    0x00000008
    0x00000000 index for local short
    0xc8000015 fetch local short (init)
    0x00000000 index for fetch int literal
    0xc8000004 fetch int literal (value 0)
    0xc800001a cmp eq
    0xc8000019 skip non zero
    0x0100000b ---------------------+
    // set target to getParentRef   |
    0x00000000 local ref index? (target)
    0xca00060c getParentRef         |
    0xc800004b store local ref      |
    // set mySelf to getSelf        |
    0x00000001 local ref index? (myself)
    0xca00060d getSelf implcit      |
    0xc800004b store local ref      |
    // set init to 1                |
    0x00000000 index for local short? (init)
    0x00000001 index for fetch int literal
    0xc8000004 fetch int literal (value 1)
    0xc8000000 store local short (init)
    0x00000000 <--------------------+

    // isActionRef mySelf == 0
    0xca0005f0 isActionRef implicit <------------ this doesn't look right, where is "myself"?
    0x00000002 index for fetch int literal
    0xc8000004 fetch int literal (value 0)
    0xc800001a cmp eq

    // set busy to 1
    0x00000001 index for local short
    0xc8000015 fetch local short (busy)
    0x00000003 index for fetch int literal
    0xc8000004 fetch int literal (value 0)

    0xc800001a cmp eq
    0xc8000048 logical and
    0xc8000019 skip non zero
    0x0100000f ---------------------+
    // set busy to 1                |
    0x00000001 index for local short? (busy)
    0x00000004 index for fetch int literal
    0xc8000004 fetch int literal (value 1)
    0xc8000000 store local short (busy)
                                    |
    // target.activate mySelf 1     |
    0x00000005 index for fetch int literal
    0xc8000004 fetch int literal (value 1)
    0x00000001 index for string literal (mySelf)
    0x00000006 index for fetch int literal
    0xc8000004 fetch int literal    |
    0xc2006f02 <- Activate explicit |
                                    |
    // playgroup forward 0          |
    0x00000007 index for fetch int literal
    0xc8000004 fetch int literal (value 0)
    0x00000003 push int (3 which is probably the index of string literal "forward")
    0xca0004d4 PlayGroup implicit   |
    0x00000000 <--------------------+
    0x00000001 <- int literal
    0x00000000
    0x00000000
    0x00000001
    0x00000001
    0x00000002
    0x00000000
    0x6573796d <- string literal
    0x6d00666c
    0x6c657379
    0x61740066
    0x74656772
    0x726f6600
    0x64726177
    0x00000000

Some notes before I forget:

  * To stop at the beginning of an "if", put a breakpoint in `ControlParser::parseKeyword()`
  * To stop at a "set" command, put a breakpoint in `LineParser::parseName()` or `LineParser::parseKeyword()` in the block:

```cpp
        else if (mState==SetLocalVarState && keyword==Scanner::K_to)
```

## Explicit function call

The code generation looks wrong:

    // target.activate mySelf 1
    0x00000005 index for fetch int literal
    0xc8000004 fetch int literal (value 1)
    0x00000001 index for string literal (mySelf)
    0x00000006 index for fetch int literal
    0xc8000004 fetch int literal
    0xc2006f02 <- Activate explicit

This would be parsed by `LineParser` where `mState == IfBodyState`.  The `LineParser::parseName()` would get to `mState == StartState` and we find that we have a local ref variable.  Maybe we need to fetch the local ref variable value here?

Anyway we are now in `PotentialExplicit` state with `mExplicit` set to "target".  Now `LineParser::parseSpecial()` sees "." and we are now in `Explicit` state.

`LineParser::parseKeyword()` sees "activate" as an instruction.  `ExprParser::parseArguments()` generates code for the arguments (`/cl`, i.e. optional string and optional integer).

The first argument is "mySelf" which `StingParser::parseName()` generates code using `Generator::pushString()`.  I guess the interpreter needs to check if it is a local ref variable. So here we get:

    0x00000001 <-- push 1 to stack (1 is the index to string literal "mySelf")

Then we get the next argument which is integer "1".  Since this is on the stack the order appears reversed.

    0x00000005 index for fetch int literal
    0xc8000004 fetch int literal (value 1)

We finally get to `Extensions::generateInstructionCode()`.  Since we have `mExplict` set to "target", the generator will push that as a string literal.  But for some reason the code for this string literal looks different:

    0x00000006 index for string literal
    0xc8000004 fetch int literal

So the issue might be the generator pushing a string literal when it should be recognising "target" as a local ref varialbe and simply pushing its index instead.

Similarly with argument "mySelf" the generator should be able recognise it as a local ref variable and generate a code to retrieve its value (but then how do we deal with non ref variables such as editor ids?)

A solution might be to convert _all_ these to local ref variables.  Doing so might reduce the double-searching (once during compilation and once during runtime) as well.

So an `EditorId` name for an explicit call should result in a store local ref variable (of the `FormId`) then pushing the index of that to the stack where as a local ref variable for an explicit call should be just pushing the index of the variable.

## Explicit function call - rethink

The trouble with creating a local ref variable is that the interpreter context won't know about these local variables.

This means we need to go back to using string literals and have some logic in interpreter context to figure out the different usages indicated above.  That seems better than trying to propagate additional local declarations to various objects and scripts.

One hack would be to use some kind of indicator to distinguish between a local ref variable and a literal string.  This can be done by using one or two bits of the indices for the local ref variable and the literal string.

# [13/01/2021 - 15/01/2021] Combining animation and havok

Currently several places have differences, including:

  * `ObjectAnimation` ctor - disables havok if animation (`NiMultiTargetTransformController` exists)
  * `NiTriBasedGeom::buildSubMesh()` - different transform
  * `bhkRigidBody::getShape()` - different transform and bone name
  * `BtRigidBodyCI::loadImpl()` - different transform

Also note that there are complications with skinned meshes as well.  However these transform differences maybe ok if havok mesh's parent NiNode is the controlledNode for animated meshes.

## Variety 1 - `RichetyFence01.NIF`

Static but havok enabled with non-zero mass.

See the notes on 08/01/21 - 09/01/21.  The issue here is that `getShape()` is called indicating that the shape is "dynamic" when it is not.  As a result the required transforms are not baked into the collision shape.

No idea yet on how to fix this.

## Variety 2 - `RopeRock01.NIF`

This one has it all - animation, havok and skinned meshes. The issue here is that the NIF file's vertices seem to have the parent `NiNode`'s local transforms baked in.  As a result the rendered mesh is not in the correct place.

Fixed 15/01/21 by using different transforms for animated skinned meshes.

## Variety 3 - `TrapSwingMaceLong01.NIF`

This one has animation and havok.  The meshes are not skinned, so the resulting entities are attached to scene nodes (like `CathedralCryptLight02.NIF`).

## Unification strategy

There has to be a common way to deal with all these different cases, especially how the transforms are applied.  Maybe the best way is to standardise to exclude the parent NiNode's local transforms however the skinned meshes seem to need them for Ogre (but the NPC/Creature animations seem fine?)

Strangly, the door animations look wrong even though their meshes are not skinned.

### Experiment 1

  * Enable animation and havok at the same time by disabling the check for `NiMultiTargetTransformController`
  * Disable "fake skin" used for node animation
  * Use the same transform for rendering and physics (i.e. local transform only)
  * Attach both rendering entities and physics rigid bodies to the same node - either `SceneNode` or `Bone` (if skinned) - unless static in which case to the root `SceneNode`.

Having a common transform for skinned and non-skinned meshes turns out to be more difficult than anticipated.  If the mesh always includes the parent `NiNode`'s local transform, then by using that transform's inverse as an offset when attaching the mesh to a bone should work.  However using this approach the wheel in `Dungeons\Sewers\SewerWheel01.NIF` has wrong center of rotation.

# [18/01/2021 - 19/01/2021] Activation and deactivation

It is unclear when havok should be enabled and disabled if the model has both havok and animation. There are a couple of examples both of which have havok, animation and attached scripts:

  * `RopeRock01.NIF` - can have havok enabled except when animation is playing after activation
  * `CTrapLogs01.NIF` - enabling havok at the start will result in the logs moving due to gravity

The rigid bodies in the two models have `MO_SYS_KEYFRAMED` motion system.  According to Nifskope:

    Simulation is not performed as a normal rigid body. The keyframed rigid body has an infinite mass when viewed by the rest of the system. (used for creatures)

That description appears to suggest that havok is not fully enabled at the start.  Maybe only `MO_SYS_DYNAMIC` motion system does that.  Interestingly `RicketyFencd01.NIF` also has its rigid body as `MO_SYS_KEYFRAMED`.

## Motion System

It is unlikely Bullet has a directly equivalent concept of Motion System in Havok, but below might be loose approximation (just a guess):

  Motion System       | Bullet
  --------------------+------------------------
  `MO_SYS_DYNAMIC`    | dynamic objects
  `MO_SYS_FIXED`      | static objects
  `MO_SYS_KEYFRAMED`  | kinematic objects

# [13/03/2021 - 14/03/2021] Back from a long break

Not sure what to do next.  Some possibilities are:

  * Figure out how CTrabpLogs01.NIF is triggered (e.g. velocity greater than a certain pre-defined limit)
  * Improve the configuration of Bullet rigid body constraints
  * Enable Bullet multi-threading
  * Something other than physics and come back to it (e.g. character controller, AI packages, etc)

## Try starting with AI Packages

Call sequence:

    >	openmw.exe!MWMechanics::Actors::addActor(const MWWorld::Ptr & ptr, bool updateImmediately) Line 1023	C++	Symbols loaded.
        openmw.exe!MWClass::ForeignNpc::insertObject(const MWWorld::Ptr & ptr, const std::string & model, MWWorld::PhysicsSystem & physics) Line 196	C++	Symbols loaded.
        openmw.exe!`anonymous namespace'::addObject(const MWWorld::Ptr & ptr, MWWorld::PhysicsSystem * physics, MWRender::RenderingManager & rendering, bool dist) Line 81	C++	Symbols loaded.
        openmw.exe!MWWorld::Scene::addObjectToScene(const MWWorld::Ptr & ptr) Line 2014	C++	Symbols loaded.
        openmw.exe!MWWorld::World::copyObjectToCell(const MWWorld::Ptr & object, MWWorld::CellStore * cell, ESM::Position pos, bool adjustPos) Line 2219	C++	Symbols loaded.
        openmw.exe!MWWorld::World::safePlaceObject(const MWWorld::Ptr & ptr, MWWorld::CellStore * cell, ESM::Position pos) Line 1537	C++	Symbols loaded.
        openmw.exe!MWClass::LevelledCreature::insertObjectRendering(const MWWorld::Ptr & ptr, const std::string & model, MWRender::RenderingInterface & renderingInterface) Line 85	C++	Symbols loaded.
        openmw.exe!`anonymous namespace'::addObject(const MWWorld::Ptr & ptr, MWWorld::PhysicsSystem * physics, MWRender::RenderingManager & rendering, bool dist) Line 79	C++	Symbols loaded.
        openmw.exe!`anonymous namespace'::InsertFunctor::operator()(const MWWorld::Ptr & ptr) Line 148	C++	Symbols loaded.
        [Inline Frame] openmw.exe!MWWorld::CellStore::forEachImp(`anonymous-namespace'::InsertFunctor &) Line 419	C++	Symbols loaded.
        openmw.exe!MWWorld::CellStore::forEach<`anonymous namespace'::InsertFunctor>(`anonymous-namespace'::InsertFunctor & functor) Line 232	C++	Symbols loaded.
        openmw.exe!MWWorld::Scene::insertCell(MWWorld::CellStore & cell, bool rescale, Loading::Listener * loadingListener) Line 2001	C++	Symbols loaded.
        openmw.exe!MWWorld::Scene::loadForeignCell(MWWorld::CellStore * cell, Loading::Listener * loadingListener, unsigned int worldId) Line 468	C++	Symbols loaded.


        openmw.exe!MWMechanics::AiWander::init() Line 99	C++	Symbols loaded.
        openmw.exe!MWMechanics::AiWander::AiWander(int distance, int duration, int timeOfDay, const std::vector<unsigned char,std::allocator<unsigned char>> & idle, bool repeat) Line 91	C++	Symbols loaded.
        openmw.exe!MWMechanics::AiSequence::fill(const ESM::AIPackageList & list) Line 297	C++	Symbols loaded.
    >	openmw.exe!MWClass::Npc::ensureCustomData(const MWWorld::Ptr & ptr) Line 233	C++	Symbols loaded.


AI Package data is currently loaded during the setup of the custom data of an actor.  It may be beneficial to make it more explicit?

# [10/04/2021 - 11/04/2021] Another attempt to kickstart

# [30/05/2021] Another attempt to kickstart

# [03/06/2021 - 10/06/2021] Another attempt to kickstart

Finally got the code compiled and running again.  For some reason collision to the hanging roots (`Dungeons\Misc\RootHavok06.NIF`) was not working in WellspringCave - it turned out to be something related to `btCollisionObject::CF_KINEMATIC_OBJECT` but can't remember why that code was required...

## AI package compilation to pre-determine location

It would be highly inefficient to go through all the NPCs each time a cell is loaded.

Current thinking is to "compile" all NPC AI packages and cache the results somewhere.  When a cell is loaded, the cache can be queried to see if an NPC needs to be in that cell.

However implementing the pre-determination of locations may not be trivial.  For example:

  * Sergius Verus has a package "Wander" to go to `ICPalace02 (07, 16)` on Sundas between 20 and 24.
  * Palonirya has a package "Accompany" Sergius Verus on Sundas between 20 and 24.

So, when loading the cell `ICPalace02 (07, 16)` on Sundas at 21 hours, both Sergius Verus and Palonirya need to be spawned there.

However it is unclear what happens at 20 hours. Maybe they begin travelling?  If so does Palonirya head straight to `ICPalace02` or towards Sergius's current location?

## AI package location

It may be possible to go through the location data of each package for a given NPC and "register" the NPC's `FormId` for the relevant cell and time.  Note, however, that the condition data may invalidate it - i.e. will probably have to check the condition data before spawning any `NPC`.

## Record group load order

PACK records are loaded __after__ CELL and WRLD records (i.e. ACHR and ACRE).  This means we can't pre-process the AI package locations until all the loading is completed.

Note that all the DLCs should be loaded because a DLC may modify the records.  The best place, therefore, seems to be `ESMStore::setUp`.

## Travel package - Regner

With a Travel AI package, we know the destination but we don't know the starting location.  For example, Regner sleeps in his house ("Editor Location") between 0 and 6, then wanders near the "Editor Location" (default package) until "Regner Sit" travel package starts at 8.  Based on above, the travel starts in his house and ends in cell "BrumaExteria06" which is just outside his house.  Without this detailed examination of Regner's activities before the travel, the starting location won't be known.  Also, some kind of path finding will need to be done in order to find all the cells visited during this travel.

Also complicating matters is the conditions for the packages, which can change during the gameplay (e.g. quest stage update).  One possible way to deal with this is to ignore the conditions for now and check at the time of spawning.

# [11/06/2021 - 12/06/2021] Road records

Maybe required for predicting visited cells during a Travel package.















# [14/06/2022 - 20/06/2022] Quests

In OpenMW a Quest is a dialogue Topic.  However in TES4+DLCs there are 0x1a0 QUST records in ESM (i.e. 416).  Some of these are "global" - they are running at the start of the game (221, which is more than half of all quests).

Not sure if there should be a quest manager (probably).  And if so whether it should be active or passive.  Well, since scripts can query a quest's current stage, it should have at least a passive/query function.  i.e. there should be a list of current quests and completed quests.

## Quest Manager

Not sure if I can get away with adding some methods in the DialogueManager.  Well, we'll start that way for now.

## TES4 Dialogue Manager

We may need a new DialogueManager if the interface is sufficiently different to allow for TES4 gameplay.  But for now we will just piggy back on the TES3 one.

```cpp
    void ESMStore::setUp()
    {
        mIds.clear();

        std::map<int, StoreBase *>::iterator storeIt = mStores.begin();
        for (; storeIt != mStores.end(); ++storeIt)
        {
            storeIt->second->setUp();

            if (isCacheableRecord(storeIt->first))
            {
                std::vector<std::string> identifiers;
                storeIt->second->listIdentifier(identifiers);

                for (std::vector<std::string>::const_iterator record = identifiers.begin(); record != identifiers.end(); ++record)
                    mIds[*record] = storeIt->first;
            }
        }

        mSkills.setUp();
        mMagicEffects.setUp();
        mAttributes.setUp();
        mDialogs.setUp();

```

Note that `mDialogs` is

```cpp
        Store<ESM::Dialogue>        mDialogs;
```

and we have

```cpp
        ForeignStore<ESM4::Quest>      mForeignQuests;
```

So we will need to create a new method to setup the starting quests, e.g.:

```cpp
        mForeignQuests.setUp();
```
## Persistent References

In order to get the quest target all the "persistent references" must be loaded in memory.  Need to verify for sure, but I think they are stored in `MWWorld::ForeignStore<ESM4::Reference>`.

## Tracking Quests

In order to populate the quest logs, as well as to maintain the player's progress, there must be something in the savefile.

The function `GetStageDone` seems purplexing - the stage must be "done" only if the player was in the stage to begin with.  Also, if there are multiple options within the stage, how does the game keep track of which option was taken?

Left some questions at a couple of Discord servers but so far nothing.

### Save 222 - Ejek - Benirus Manor, Level 27, Playing Time 237.52.10.ess

Examine a savefile, using the quest MG05A as a guide.  The quest `FormId` 0x00028C05 occurs at file address 0x871E9.  Using [UESP](https://en.uesp.net/wiki/Oblivion_Mod:Save_File_Format/QUST):

    058C0200  formid of the changed record
    3B        type (59 == QUST)
    04000018  flags (0x18000004)
    7D        version (125)
    BB00      size

    02        flags (one byte since flags above has 0x04); address 0x871F5
    0B        stageNum (11, same as the number of stages for this quest as seen in the TES Construction Set)

    05        stageIndex (5)
    00        stageFlag
    01        stageEntryNum
    00        EntryNum (0)
    00000000
    0A        stageIndex (10)
    01        stageFlag
    01        stageEntryNum
    01        EntryNum (1)
    F400B101                <- GetStageDone 1.00
    0F        stageIndex (15)
    00        stageFlag
    01        stageEntryNum
    02        EntryNum (2)
    00000000
    14        stageIndex (20)
    01        stageFlag
    01        stageEntryNum
    03        EntryNum (3)
    F400B101                <- GetStageDone 1.00
    19        stageIndex (25)
    00        stageFlag
    01        stageEntryNum
    04        EntryNum (4)
    00000000
    1E        stageIndex (30)
    01        stageFlag
    01        stageEntryNum
    05        EntryNum (5)
    F400B101                <- GetStageDone 1.00
    28        stageIndex (40)
    01        stageFlag
    01        stageEntryNum
    06        EntryNum (6)
    F700B101                <- GetStageDone 1.00
    64        stageIndex (100)
    01        stageFlag
    02        stageEntryNum <- note: 2
    07        EntryNum (7)
    F700B101                <- GetStageDone 1.00, must have chosen the first option
    08        EntryNum (8)
    00000000
    96        stageIndex (150)
    00        stageFlag
    01        stageEntryNum
    09        EntryNum (9)
    00000000
    C8        stageIndex (200)
    00        stageFlag
    01        stageEntryNum
    0A        EntryNum (10)
    00000000
    FF        stageIndex (255)
    00        stageFlag
    02        stageEntryNum <- note: 2
    0B        EntryNum (11)
    00000000
    0C        EntryNum (12)
    00000000

    0700      quest script dataNum (present since flags above has 0x08000000)
    01
    00 00 00 00 00 00 00 00 00 F0 3F 05
    00 00 00 00 00 00 00 00 00 08 40 07
    00 00 00 00 00 00 00 00 00 F0 3F 06
    00 00 00 00 00 00 00 00 00 F0 3F 02
    00 00 00 00 00 00 00 00 00 22 40 03
    00 00 00 00 00 00 00 00 00 22 40 04
    00 00 00 00 00 00 00 00 00 00 40 00 <- 7 entries, ends at address before 0x871F5+0x00BB = 0x872B0
                                           (but MG05AScript has 8 variables? maybe doonce doesn't count?)

    8DEE0100
    31       type (49 == REFR)
    ...

In-game log shows when the quest was completed.  It is unclear where in the savefile this information is stored.  Might be something to do with the value `0x01B100F7`.  It doesn't look like a float, so it is either 2 shorts or a long integer.

If 2 shorts:

    0x00F7 = 247
    0x01B1 = 433

Well, Oblivion starts on Morndas, 27th of Last Seed, 3E 433.  The value 247 is probably translates to 4th of Heartfire.  This matches the date of the in-game log entry.

## Tracking Quest States

Ok, so we may as well track quest states similarly to the savefile.  Let's see how OpenMW deals with Dialogue states.

CPhHWE3xfLcnqNe UESP

Made an account on UESP and made some updates.  I should try to remember other issues that I had found earlier and update those as well.

## Active Quests

It is unclear how to detect the `Active` quest from a savefile.  Below are snippets from 2 different savefiles where the only difference is that the first one has "No Stone Unturned" quest set as `Active`.

In both files 0x00185FE9 only occur twice.

    301
    E9 5F 18 00 3B 04 00 00 10 7D 2A 00 01 05 0A 00 01 00 00 00 00 00 14 01 01 01 87 00 B2 01 1E 00 01 02 00 00 00 00 64 00 01 03 00 00 00 00 C8 00 01 04 00 00 00 00

    299
    E9 5F 18 00 3B 04 00 00 10 7D 2A 00 01 05 0A 00 01 00 00 00 00 00 14 01 01 01 87 00 B2 01 1E 00 01 02 00 00 00 00 64 00 01 03 00 00 00 00 C8 00 01 04 00 00 00 00


    301
    51 87 0A 00
    31
    00 00 00 08 <- "Inventory"
    7D
    93 00
    07 00          Num Items
    BB 04 00 00    iref
    01 00 00 00    stacked
    01 00 00 00    changed entries
    01 00          properties
    36
    06 00 00 00 00 D3 01 00 00 01 00
    00 00 01 00 00 00 01 00 36 06 00 00 00 00 2A 02 00 00 01 00 00 00 01 00 00 00 01 00 36 06 00 00 00 00 2E 03 00 00 01 00 00 00 01 00 00 00 01 00 36 05 00 00 00 00 7C 04 00 00 01 00 00 00 01 00 00 00 01 00 36 02 00 00 00 00 40 01 00 00 09 00 00 00 01 00 00 00 02 00 36 00 00 00 00 00 2A 09 00 D5 0C 00 00 00 00 00 00 01 00 00 00 01 00 12 D6 0C 00 00 00 00 00

    299
    51 87 0A 00
    31
    00 00 00 08 <- "Inventory"
    7D
    93 00
    07 00          Num Items
    D5 0C 00 00    iref
    00 00 00 00    not stacked?
    01 00 00 00    changed entries
    01 00          properties
    12
    D6 0C 00 00 00 00 00 40 01 00 00
    09 00 00 00 01 00 00 00 02 00 36 00 00 00 00 00 2A 09 00 7C 04 00 00 01 00 00 00 01 00 00 00 01 00 36 02 00 00 00 00 2E 03 00 00 01 00 00 00 01 00 00 00 01 00 36 05 00 00 00 00 2A 02 00 00 01 00 00 00 01 00 00 00 01 00 36 06 00 00 00 00 D3 01 00 00 01 00 00 00 01 00 00 00 01 00 36 06 00 00 00 00 BB 04 00 00 01 00 00 00 01 00 00 00 01 00 36 06 00 00 00 00

# [06/09/2022 - 09/09/2022] Taking A Breather

Took a bit of time to commit the chnages so far.

## Loading A Different Game Type

Going from one game type to another results in a crash.  The issue seems to be:

    1. `StateManager::loadGame()` calls `cleanup()` which then calls `World::clear()` that puts an empty `RefData` to the player character it keeps.
    2. `StateManager::loadGame()` eventually calls `World::setupPlayer()` which sets up a new player then calls `RenderingManager::setupPlayer()`.  The `RefData` of the player character `Ptr` is then setup with a base `SceneNode`.
    3. The trouble is that the player character at this point is a different one, e.g. TES4.
    4. Subsquently `World::renderPlayer()` and then `RenderingManager::renderPlayer()`.  `RenderingManager` tries to refresh its copy of player animation (i.e. `mPlayerAnimation`) but it still has the old `Ptr`, e.g. TES3.
    5. Because the old `Ptr` doesn't have a valid `RefData` the dtor throws an exception.

So, we should probably update `RenderingManager` with a new `Ptr` before `renderPlayer()`.  Or, alternatively, put the base `SceneNode` to both `Ptr`s, knowing that one will be destructed shortly.

## FONV Scripts

### Comments

FONV allows "//" as comment leader in addition to ";".  Also seen are long strings of "-----------------" or "==================".

### Different Function Signatures

In FONV many functions with the same name accpet additional optional parameters.

### Space character in SCN Name

FormId 000E8948.  Worked around by introducing a state after reading the script name but before "Begin" keyword is encountered.

    scn 188tradingpostbehavior Script

### Local Variable Same as Keyword

Since TES4/FONV uses `GetRandomPercent` simply changed the keyword in the `Scanner`.  One difference is that `GetRandomPercent` does not have a parameter.

    VOVFiendEncountersScript (0013AE15)

    Short Random

### Else With Only Whitespace

    VES01VictorGSMyBodyguardScript (00154150)

    if player.GetDistance GSVictorRef >= 10000
        GSVictorRef.MoveTo Player 2500 2500
        GSVictorRef.AddScriptPackage VES01VictorGSPathToPCPackage
        ;GSVictorRef.SetPlayerTeammate 1					; Victor will now fight with the Player (and enemies will attack Victor)
        GSVictorRef.AddToFaction VESVictorMyBodyguardFaction 1
        set nVictorAttack to 1 										; Victor is close to the Player and the Player is in combat so Victor is attacking (has attacked) too
        set nVictorArrived to 1									; Victor has arrived
    else GSVictorRef.AddScriptPackage VES01VictorGSPathToPCPackage
        if GSVictorRef.GetDistance player <= 1000
            ;GSVictorRef.SetPlayerTeammate 1				; Victor will now fight with the Player (and enemies will attack Victor)
            GSVictorRef.AddToFaction VESVictorMyBodyguardFaction 1
            set nVictorAttack to 1									; Victor is now close enough to the Player to see enemies so Victor is attacking (has attacked) too
            set nVictorArrived to 1								; Victor has arrived
        endif
    endif

### Debugging Missing Variable

NVDLC01MQ03Script (01001D1D)

    ; Whoops! The player has reached a failure state leading to his doom.
    if (VaultCodeBox.bElijahTeamsWithPlayer == 1) || (VaultCodeBox.bPlayerTrapped == 1) || (VaultMainTerminalREF.bReadPersonal == 1)


    ScriptParser::parseKeyword
        K_if
        ControlParser::parseKeyword
        StartState, K_if
            Scanner using ExprParser
            VaultCodeBox
                ExprParser::parseSpecial
                S_open, mOperators.push_back('(')
                ExprParser::parseName
                    not local var
                    not global var (FIXME: using TES3 globals here)
                    CompilerContext::getReference
                        search Ptr via EditorId
                        search persistent actor characters using EditorId
                        search persistent refs using EditorId -> formId = 0x0100ae1e
                        mPotentialExplicit = vaultcodebox
                        mPotentialReference = 0x0100ae1e
            '.' special = S_ref_or_member
                ExprParser::parseSpecial
                    mExplicit = VaultCodeBox, mRefOp = true, mNextOperand = true
            bElijahTeamsWithPlayer
                ExprParser::parseName
                    ExprParser::handleMemberAccess
                        CompilerContext::getMemberType
                            search Scripts via EditorId
                            search Quests via EditorId
                            search ActorCharacter via EditorId
                            search ActorCreature via EditorId
                            search Reference via EditorId
                                baseobj is an activator, get its script and convert to string (FIXME: why string?)
                                use the ScriptManager::getLocals to get the local variable of the script
                            Generator::fetchMember

The code doesn't find the type of the base object (0x0100ABE1) for `VaultMainTerminalREF` and fails.  Need to figure out why.  It could be because it is a terminal?

__FIXME:__ Some of the code could really do with some refactoring, for example `CompilerContext::getMemberType()`.

### Elseif Without Matching If

FormId 0x0017B778.  Should be treated as "If" but it isn't clear how the `ControlParser::parseKeyword` handles it.

    scn BeatrixFXSCRIPT

    float timer
    int reset
    int bump

    begin gamemode

        if reset == 0
            VFSBeatrixREF.SetRestrained 1
            DisablePlayerControls 1 1 1 0 1 1 1
            imod FadeToBlack9sISFX
            set timer to 0
            set bump to 0
            set reset to 1
        endif

        set timer to timer + getsecondspassed

        if timer > 1.5 && bump == 0
            PlaySound NPCIdleScratchShoulder
            set bump to 1
        endif
        elseif timer > 2 && bump == 1
            PlaySound NPCIdleSwattingSlap
            set bump to 2
        endif
        elseif timer > 2.3 && bump == 2
            PlaySound NPCIdleScratchSelf
            set bump to 3
        endif
        elseif timer > 2.5 && bump == 3
            PlaySound NPCIdleSwattingSlap
            set bump to 4
        endif
        elseif timer > 3.5 && bump == 4
            PlaySound NPCIdleScratchSelf
            set bump to 5
        endif
        elseif timer > 4.5 && bump == 5
            PlaySound NPCFeralGhoulAlert
            set bump to 6
        endif
        elseif timer > 5.5 && bump == 6
            PlaySound NPCFeralGhoulAware
            set bump to 7
        endif
        if timer > 9
            set reset to 0
            enableplayercontrols

            if GameHour <= 23
                set GameHour to GameHour + 1
            else
                set GameDaysPassed to GameDaysPassed + 1
                set Gamehour to 1
            endif

            set VFSBeatrixREF.iWorking to 0
            VFSBeatrixREF.SetRestrained 0
            VFSBeatrixREF.evp
            stopquest BeatrixFX
        endif

    end

[//]: # (/* spell spelllang=en_au syntax=cpp */)
[//]: # (/* vim: set ft=markdown tw=0 lbr bri fen fdm=marker fdl=0: */)
